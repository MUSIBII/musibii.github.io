<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python模块之sys与os]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E4%B9%8Bsys%E4%B8%8Eos%2F</url>
    <content type="text"><![CDATA[python常用模块系列（二）：sys模块与os模块 sys模块是python解释器和环境有关的一个模块； os是python用来和操作系统进行交互的一个模块。 一 sys 查看当前环境变量 查看已经加载的模块 可以看出sys.modules是一个字典，key为加载模块的名字，values为加载模块的路径。 获取终端调用时的参数 终端输入的参数为argv[1]，默认当前文件名为第一个参数。 获取解释器的版本信息 获取当前运行平台名称（windows为nt，macOS为darwin） 退出信号 123import syssys.exit(0) # 正常退出sys.exit(1) # 错误退出 接口版本 123import sysprint(sys.api_version)# 运行结果 1013 了解 123456import sysprint(sys.maxsize)print(sys.maxunicode)# 运行结果# 9223372036854775807# 1114111 二 os 获取当前的工作目录 123import osprint(os.getcwd())# 运行结果 /Users/jingxing/PycharmProjects/python全栈/day20/代码 切换工作目录 1234import osprint(os.chdir('/Users/jingxing/PycharmProjects/python全栈'))print(os.getcwd())# 运行结果 /Users/jingxing/PycharmProjects/python全栈 获取当前目录 123import osprint(os.curdir)# 运行结果 . 获取上级目录 123import os print(os.pardir)# 运行结果 .. 获取系统的环境变量 123import osprint(os.environ)# environ(&#123;'PATH': '/Users/jingxing/.nvm/versions/node/v4.9.1/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/python_study/mongodb/bin://Volumes/python_study/mongodb/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/VMware Fusion.app/Contents/Public:/python_study/Applications/mongodb-osx-x86_64-3.6.3/bin::/usr/local/mysql/bin', 'COMMAND_MODE': 'unix2003', 'VERSIONER_PYTHON_VERSION': '2.7', 'LS_OPTIONS': '--color=auto', 'LOGNAME': 'jingxing', 'XPC_SERVICE_NAME': 'com.apple.xpc.launchd.oneshot.0x10000004.pycharm', 'PWD': '/Users/jingxing/PycharmProjects/python全栈/day20/代码', 'PYCHARM_HOSTED': '1', 'NODE_PATH': '/Users/jingxing/.nvm/versions/node/v4.9.1/lib/node_modules', 'PYCHARM_MATPLOTLIB_PORT': '49379', 'PYTHONPATH': '/Applications/PyCharm.app/Contents/helpers/pycharm_matplotlib_backend:/Users/jingxing/PycharmProjects/python全栈', 'NVM_CD_FLAGS': '', 'NVM_DIR': '/Users/jingxing/.nvm', 'SHELL': '/bin/bash', 'LSCOLORS': 'CxfxcxdxbxegedabagGxGx', 'PYTHONIOENCODING': 'UTF-8', 'SECURITYSESSIONID': '186a7', 'VERSIONER_PYTHON_PREFER_32_BIT': 'no', 'USER': 'jingxing', 'CLICOLOR': 'Yes', 'TMPDIR': '/var/folders/yl/3drd7wf93f90sfkgpc2zg9cr0000gn/T/', 'SSH_AUTH_SOCK': '/private/tmp/com.apple.launchd.bIB1b2eyOD/Listeners', 'XPC_FLAGS': '0x0', 'PYTHONUNBUFFERED': '1', '__CF_USER_TEXT_ENCODING': '0x1F5:0x19:0x34', 'Apple_PubSub_Socket_Render': '/private/tmp/com.apple.launchd.bHuC64fYdd/Render', 'LC_CTYPE': 'zh_CN.UTF-8', 'NVM_BIN': '/Users/jingxing/.nvm/versions/node/v4.9.1/bin', 'HOME': '/Users/jingxing', '__PYVENV_LAUNCHER__': '/Library/Frameworks/Python.framework/Versions/3.6/bin/python3'&#125;) 创建多级目录 123import osos.makedirs('a/b/c')# 会在当前文件路径创建多级目录 创建一个目录 123import osos.mkdir('aa')# 能且仅能创建一个目录 递归删除 123import osos.removedirs('a/b/c')# 递归删除，只能删除空目录 删除一个目录 123import osos.rmdir('aa')# 删除一个目录 删除文件 123import osos.remove(r'/Users/jingxing/PycharmProjects/python全栈')# 删除文件 列出当前目录所有的文件及文件夹 12import osprint(os.listdir(r'/Users/jingxing/PycharmProjects/python全栈')) 获取当前平台路径分隔符 123import osprint(os.seq)# 运行结果 / 获取当前平台换行符 12import osprint(os.lineseq, end='')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python模块之time与datetime]]></title>
    <url>%2F2018%2F10%2F16%2FPython%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E4%B9%8Btime%E4%B8%8Edatetime%2F</url>
    <content type="text"><![CDATA[python常用模块系列（一）：time模块与datetime time模块是python内置查看当前时间戳的一个模块； datetime模块是用来对日期和时间进行操作的一个模块。 一 time1 获得时间戳时间戳：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行‘’type(time.time())‘’，返回的是float类型。 123import timeprint(time.time())# 运行结果 1539678307.779871 2 结构化时间字符串123import timeprint(time.localtime()) # 返回一个元祖对象，里面是每个时间的值(东八区)# 运行结果 time.struct_time(tm_year=2018, tm_mon=10, tm_mday=16, tm_hour=16, tm_min=48, tm_sec=4, tm_wday=1, tm_yday=289, tm_isdst=0) 123import timeprint(time.localtime().tm_year) # 单独获取某个时间属性# 运行结果 2018 123import timeprint(time.gmtime()) # 世界统一时间，比北京时间晚8小时# 运行结果 time.struct_time(tm_year=2018, tm_mon=10, tm_mday=16, tm_hour=8, tm_min=51, tm_sec=16, tm_wday=1, tm_yday=289, tm_isdst=0) 3 格式化的字符串时间123456import time print(time.strftime('%Y-%m-%d %H:%M:%S %p'))print(time.strftime('%Y-%m-%d %X %p'))# 运行结果 # 2018-10-16 16:54:56 PM# 2018-10-16 16:54:56 PM 4 三种格式之间的相互转换 时间戳转为结构化 123import timeprint(time.localtime(time.time()))# 运行结果 time.struct_time(tm_year=2018, tm_mon=10, tm_mday=16, tm_hour=16, tm_min=57, tm_sec=18, tm_wday=1, tm_yday=289, tm_isdst=0) 结构化转字符串 123import timeprint(time.strftime("%Y-%m-%d",time.localtime(time.time())))# 运行结果 2018-10-16 字符串转结构化 123import timeprint(time.strftime('2018-10-16', '%Y-%m-%d'))# 运行结果 time.struct_time(tm_year=2018, tm_mon=10, tm_mday=15, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=288, tm_isdst=-1) 结构化转时间戳 123import timeprint(time.mktime(time.strptime('2018-10-15', '%Y-%m-%d')))# 运行结果 1539532800.0 格林威治时间 123456import timeprint(time.asctime(time.localtime()))print(time.ctime())# 运行结果# Tue Oct 16 17:12:34 2018# Fri Jan 2 08:00:00 1970 二 datetimedatetime是一个包，里面包含对时间的处理和日期的处理 获取当前详细时间 123import datetimeprint(datetime.datetime.now())# 运行结果 2018-10-16 17:25:16.186114 获取时间的某一部分 123import datetimeprint(datetime.datetime.now().hour) # 分钟、年份等同理# 运行结果 17 替换时间的某一部分 12345import datetimet1 = date.datetime.now()t1 = t1.replace(year=2019)print(t1)# 运行结果 2019-10-16 18:36:42.166986 时间差对象 12345import datetimet2 = datetime.timedelta(weeks=1)t3 = datetime.datetime.now()print(t2 + t3)# 运行结果 2018-10-23 18:40:10.481854]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>内置模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件目录规范]]></title>
    <url>%2F2018%2F10%2F15%2F%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[随着功能的增多，代码逻辑也会越来越多，导致代码逻辑混乱不便于管理项目。为了解决这个问题，可以将相同功能的代码集合在一个文件夹，设置一个入口函数，一些设置文件放在一个文件，主要逻辑代码放一个文件夹。。。 这样对于整个业务有很好的可读性和扩展性。 对于之前的ATM+购物车项目最开始所有的逻辑代码都在一个文件，当我们需要修改某些函数时，遇到了一点困难，就是整个项目有600+行代码，而且什么都在里面，对于想快速具体的找到想修改的地方确实需要花费一些时间，效率低下。所以重新修改后，将具体功能代码放在一起，很明显逻辑清晰了，而且看的也很舒服。 如下为我的项目结构中的bin文件夹： bin目录下的start.py文件为启动函数，首先在启动函数里面导入os和sys模块，目的是为了将当前项目的根路径加入环境变量，接着导入相关函数和变量。该py文件仅仅作为程序的入口，里面没有逻辑代码。 如下为conf文件夹： conf是configuration的缩写，为配置的意思，里面只有settings文件，可以看出里面都是定义的一些变量，（在这里的变量其实应该使用大写的） 接下来是主要业务逻辑代码文件夹core（核心）： 里面有三个py文件，因为项目有三个主要功能，分别是ATM、SHOPP、USER，所以分了三个，里面的代码大同小异。 接下来是记录用户消费流水的文件夹，（db）里面也包括了用户信息，比如账号名、密码、余额、状态等信息。 这些信息文件在每一个账户登录时，会根据登录名创建一个文件，模式为追加，当退出时将数据刷入文件并关闭文件。 接下来为lib，lib是library的缩写，表示库的意思。里面只有common文件（里面可以放共用的一些功能代码或者第三方库） common文件里面是几个通用的功能函数，比如日志装饰器、读取用户所有信息的函数、、、 接下来为log文件夹，记录日志，哪个用户登陆了，做了什么事情都会记录下来（仔细想来，生活中我们在某些应用中做的事情是不是也会记录下来？答案是肯定的） 最后一个是README.md文件，通常是用来给用户看的，说明程序怎么使用，叫做帮助文档。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>包、文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块与包]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%2F</url>
    <content type="text"><![CDATA[一 什么是模块模块就是一组功能的集合体，可以通过导入模块来复用模块的功能。 比如我在同一个文件夹定义两个.py文件，分别命名为A.py和B.py，那么可以通过在A文件里通过import B来使用B文件里的名称空间。 python中，模块的使用方式都是一样的，可以分为四个通用类别： 使用python编写的.py文件 已被编译为共享库或DLL的C或C++扩展 把一系列模块组织到一起的文件夹（注：文件夹下有一个init.py文件，该文件夹称之为包） 使用C编写并链接到python解释器的内置模块 二 为何要使用模块 从文件级别组织程序，便于管理 随着需求的增多，功能也会越来越多，为了方便管理，通常将程序分成多个文件，这样项目的结构会更加清晰，方便管理。这时不仅仅可以把这些文件当做脚本去执行，还可以把他们当做模块来导入到其他的模块中，实现功能复用。 使用别人写好的模块，提高开发效率 使用别人已经写好的轮子，在自己的项目中使用，可以极大地提高开发效率。 注意：当退出python解释器的时候，重新进入那么之前定义的函数和变量都会丢失，因此通常将程序写到文件中以便永久保存，需要时可以在命令行通过python *.py方法执行。 1234567891011121314# test1.pyprint('from test1')money = 10def func1(): print('test1模块:', money) def func2(): print('test1模块') func1() def change(): global money money = 100 123# test2.pyimport test1test1.func1() 123# 运行结果from test1test1模块: 10 当在tes2t导入的时候会执行test1中的代码，所以首先会打印from test1接着执行test1中的func1函数。 三 使用模块之import1 import的使用模块可以包含可执行的语句和函数的定义，这些语句的目的是初始化模块，它们只在模块名第一次导入时才会执行（import语句可以在程序中的任意位置使用的，且针对同一个模块可以import多次，python为了防止重复导入，当第一次导入模块时就将模块的名称空间加载到内存了，后续的import语句仅是对已经加载到内存中的模块对象增加了一次引用，并不会重复执行模块内的语句） 12# test3print('from test3') 12345# test4import test3import test3import test3import test3 12# 运行结果from test3 ps:可以导入sys模块，调用sys.module查看当前加载到内存中的模块，sys.module是一个字典，内部包含模块名和模块名路径的对应关系。该字典决定了导入模块时是否需要重新导入。 2 导入模块时发生了什么运行py文件导入一个模块时，解释器做了三件事： 在执行文件中为被导入文件创建新的名称空间，在被导入模块中定义的函数和方法若是使用到了global时访问的就是这个名称空间。 在新创建的名称空间中执行模块中的包含的代码。函数定义也是‘’被执行‘’的语句，模块级别函数定义的执行将函数名放入模块全局名称空间表，可以用globals()可以查看。 在执行文件的名称空间创建被导入模块的名称来引用该名称空间。 这个名字和变量名没什么区别，都是‘’第一类‘’的，且使用句点表示法可以访问被导入模块的名称空间，导入的模块与被导入的模块是独立的两个名称空间。 3 被导入模块有独立的名称空间每个模块都是一个独立的名称空间，定义在这个模块中的函数，把这个模块的名称空间当做全局名称空间，这样就不用担心定义在不同的模块中全局变量在导入时与使用者的全局变量冲突。 测试1 1234# test5.pyimport test1money = 100print(test1.money) 123# 运行结果from test110 测试2 123456# test6import test1def func1(): print('from test6 func1')test1.func1()func1() 12345# 运行结果from test1test1模块: 10from test6 func1# 这说明 test6中的函数和test1中的函数不冲突 测试3 12345# test7import test1money = 1test1.change()print(money) 12345# 运行结果from test1test1模块: 101# 这说明test1中的change函数只是修改了test1中的全局变量，对test7中的变量没有操作权限 四 使用模块之from…import…1 from…import…与import …的区别区别就是：使用from…import…是将被导入模块中的名字直接导入到当前的名称空间中，所以在当前名称空间中，直接使用名字就可以了，不需要在前面加上模块名前缀。 from…import…导入方式的优缺点： 好处：使用方便 坏处：容易与当前执行文件的名字冲突 2 验证 验证1：当前位置直接使用test1中的函数名，执行时仍然以test1.py文件为全局名称空间 12345# 导入的函数func1，执行时仍然回到test1.py中寻找全局变量money# test8from test1 import func1money = 50func1() 123# 运行结果from test1test1模块: 10 123456# 导入的函数func2，执行时需要调用func1，仍然回到test1.py中找func1#test9.pyfrom test1 import func2def func1(): print('-----')func2() 1234# 运行结果from test1test1模块test1模块: 10 验证2：如果当前名称空间和被导入的模块中的名字重合，那么会覆盖掉前面的名字 123456# 导入的函数fun1,被当前位置定义的func1覆盖掉了# test10from test1 import func1def func1(): print('======')func1() 1234# 运行结果from test1======# 这说明func1把被导入名字func1覆盖掉了 123456# 当前位置定义的func1导入func1# test11def func1(): print('======')from test1 import func1func1() 1234# 运行结果from test1test1模块: 10# 这说明在后面导入的话会覆盖掉前面的 验证3：被导入的方法执行时，始终以源文件为准 12345# test12from test1 import money,func1money=100 #将当前位置的名字money绑定到了100print(money) #打印当前的名字func1() #读取spam.py中的名字money,仍然为1000 12345# 运行结果from the test100test1模块: 10# 可以看出运行func1的时候依然从原名称空间查找的 3 from … import *from … import * 是把被导入文件中所有不是以下划线(_)开头的名字都导入到当前名称空间。 大部分情况下不应该以这种导入方式，因为不知道被导入包中的名字是否会和当前名称空间中的名字重合造成名字覆盖。 解决方法是在被导入文件中使用all = []来控制被导入的名字，只有在all里面的才会被导入。 4 模块循环导入问题模块循环/嵌套导入抛出异常的根本原因是由于在python中模块被导入一次之后，就不会重新导入。 1234# test1.pyprint('正在导入1')from test2 import yx = '1' 1234# test2.pyprint('正在导入2')from test1 import xy = '2' 12# run.pyimport test1 1234567891011# 运行结果正在导入1正在导入2Traceback (most recent call last): File "/Users/jingxing/PycharmProjects/python全栈/day18/pack/run.py", line 6, in &lt;module&gt; import test1 File "/Users/jingxing/PycharmProjects/python全栈/day18/pack/test1.py", line 7, in &lt;module&gt; from test2 import y File "/Users/jingxing/PycharmProjects/python全栈/day18/pack/test2.py", line 8, in &lt;module&gt; from test1 import xImportError: cannot import name 'x' 分析：在run文件中执行导入test1，运行test1的代码，打印并且从test2中导入y，回到test2，打印并且从test1中导入，因为已经导入test1了（没导入完全，因为代码没执行完），所以直接找’x’，但因为在test1中的代码执行不下去，所以报错。执行文件不等于就完全导入文件了。 解决方法1：导入语句放在最后 解决方法2：导入语句放在函数中（因为在导入模块时，函数内的代码并不会执行，只会判断语法错误，所以这时候导入模块可以完全导入） 5 模块的重载考虑到性能的原因，每个模块只被导入一次，放入字典sys.module中，如果你改变了模块的内容，必须重启程序（python不支持重新加载或卸载之前导入的模块） 就算在修改已经导入的模块里面的代码对运行结果也没影响。 6 py文件区分两种用途：模块与脚本 脚本，一个文件就是整个程序，用来被执行 模块，文件中存放着一堆功能，用来被导入使用 python内置了全局变量name, 当文件被当做脚本执行时：name等于’main‘ 当文件被当做模块导入时：name等于模块名 作用：用来控制.py文件在不同的应用场景下执行不同的逻辑 12if __name__ == '__main__': pass 7 模块搜索路径模块的查找顺序是：内存中已经加载的模块–》内置模块–》sys.path路径中包含的模块 详细：在第一次导入某个模块式，会先检查该模块是否已经被加载到内存中（当前执行文件的名称空对应的内存），如果有则直接引用； ps:python解释器会在启动时自动加载一些模块到内存中，可以使用sys.module查看。 如果在内存中没有，解释器会查找同名的内建模块； 如果还没有则去sys.path给出的目录列表中查找。 了解：sys.path的初始化的值来自于： The directory containing the input script (or the current diretory whrn no files is specified). PYTHONPATH (a list of directory names, with the same syntax as the shell variable PATH). The installation-dependent default. 在初始化后，python程序可以修改sys.path，路径放在前面的优于标准库被加载。 搜索时按照sys.path中从左到右的顺序查找，位于前面的优先被查找，sys.path中还可能包含.zip归档文件和.egg文件，python会把.zip归档文件当成一个目录去处理。 .egg文件是setuptools创建的包，这是按照第三方python库和扩展时使用的一种常见格式，.egg文件实际上只是添加了额外元数据（如版本号，依赖项等）的.zip文件。 只能从.zip文件中导入.py，.pyc等文件。使用C编写的共享库和扩展块无法直接从.zip文件中加载（此时setuptools等打包系统有时能提供一种规避方法），且从.zip中加载文件不会创建.pyc或者.pyo文件，因此一定要事先创建他们，来避免加载模块是性能下降。 8 编译python文件为了提高加载模块的速度，强调强调强调：提高的是加载速度而绝非运行速度。python解释器会在pycache目录中下缓存每个模块编译后的版本，格式为：module.version.pyc。通常会包含python的版本号。例如，在CPython3.3版本下，spam.py模块会被缓存成pycache/spam.cpython-33.pyc。这种命名规范保证了编译后的结果多版本共存。 Python检查源文件的修改时间与编译的版本进行对比，如果过期就需要重新编译。这是完全自动的过程。并且编译的模块是平台独立的，所以相同的库可以在不同的架构的系统之间共享，即pyc使一种跨平台的字节码，类似于JAVA火.NET,是由python虚拟机来执行的，但是pyc的内容跟python的版本相关，不同的版本编译后的pyc文件不同，2.5编译的pyc文件不能到3.5上执行，并且pyc文件是可以反编译的，因而它的出现仅仅是用来提升模块的加载速度的，不是用来加密的。 五 包1 什么是包？包是一种通过’.模块名’来组织python模块名称的方式。 具体的：包就是一个包含有init.py文件的文件夹，所以其实我们创建包的目的就是为了用文件夹将文件/模块组织起来。 2 为何使用包？包的本质就是一个文件夹，文件夹的功能就是将同类型的文件组织起来。 其实使用包的原因和使用模块的原因是一样的，都是为了提高程序的结构性和可维护性。 3 注意事项 关于包相关的导入语句也分为import和from … import …两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入时带点的，点的左边都必须是一个包，否则非法。可以带有一连串的点，但都必须遵循这个原则。但对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。 import导入文件时，产生名称空间中的名字来源于文件，import 包，产生的名称空间的名字同样来源于文件，即包下的init.py，导入包本质就是在导入该文件 包A和包B下如果有同名模块也不会冲突，因为他们的名称空间是独立的。 4 绝对导入和相对导入包是写给别人用的，然而在包的内部也会有彼此之间互相导入的需求，这时候就有绝对导入和相对导入两种方式： 绝对导入：以包作为起点 相对导入：以.或..的方式作为起点（只能在一个包中使用，不能用于不同目录内） **包以及包所包含的模块都是用来被导入的，而不是直接执行的。而环境变量都是以执行文件为准。 5 绝对导入与相对导入总结12345678910111213绝对导入与相对导入# 绝对导入: 以执行文件的sys.path为起始点开始导入,称之为绝对导入# 优点: 执行文件与被导入的模块中都可以使用# 缺点: 所有导入都是以sys.path为起始点,导入麻烦# 相对导入: 参照当前所在文件的文件夹为起始开始查找,称之为相对导入# 符号: .代表当前所在文件的文件加,..代表上一级文件夹,...代表上一级的上一级文件夹# 优点: 导入更加简单# 缺点: 只能在导入包中的模块时才能使用 #注意: 1. 相对导入只能用于包内部模块之间的相互导入,导入者与被导入者都必须存在于一个包内 2. attempted relative import beyond top-level package # 试图在顶级包之外使用相对导入是错误的,言外之意,必须在顶级包内使用相对导入,每增加一个.代表跳到上一级文件夹,而上一级不应该超出顶级包]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名函数python内置高阶函数以及递归]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0python%E5%86%85%E7%BD%AE%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[匿名函数python定义一个函数通常使用def关键词，后面跟函数名，然后是注释、代码块等。 123def func(): '''注释''' print('from func') 这样就在全局命名空间定义了一个叫func的函数，func表示函数体的内存地址，因为func指向函数体内存地址，所以可以通过func来调用函数。 那么匿名函数呢？从名字就可看出，匿名。想想就有点像以前小时候的佚名一样，带点说不清楚的神秘色彩，现在想来之所以感觉神秘可能是因为那时候不认识‘’佚‘’这个字。。。 1234强调: 匿名函数的定义就相当于只产生一个变量在值,而没有绑定任何名字, 所以会在定义完之后就被回收,无法重复使用,只能在定义时使用一次应用:当某一个功能仅使用一次就没有再重复使用的必要了,就应该定义成匿名函数 言归正传，匿名和佚名一样没有名字或者不需要知道名字，对就是这么酷。 定义一个匿名函数使用lambda关键词，和def比较的话会发现其实定义逻辑很像。 1lambda x: x**2 定义的匿名函数的意思是参数为x，返回x的平方，返回？怎么没看到return？因为lambd引号后面的值默认返回，所以没必要加return了，但是我一定要加呢？就是这么不讲道理。那么解释器只好报错了，因为你不认同我的语法，那我也没必要惯着你了。就是这么拽。 匿名函数的使用场景通常为使用一次就结束了，不会频繁的使用。而且匿名函数通常和python里面自带的高阶函数结合使用，在某些应用场景下会达到事倍功半的效果哦。 高阶函数mapmap的意思是地图的意思，由此引申出映射表示一一对应。 翻译过来的意思是：创建一个迭代器，使用每个迭代的参数计算函数。 当最短的可迭代用尽时停止。 map函数有两个参数，第一个为某种规则的函数，第二个位多个可迭代对象。 12345def func(x): return x * 2lis = [1, 2, 3, 4, 5, 6]print(type(map(func, lis)))print(list(map(func, lis))) map函数把可迭代对象中的元素自动传给func，通过func的加工，得到一个生成器对象，通过list函数转化为一个列表。 当然，map函数可以接收多个可迭代对象，比如 123456def func(x, y): return x + ylis1 = [1,2,3,4,5,6]lis2 = [2,3,4,5,6,7,8,9,10,11]print(list(map(func, lis1,lis2)))# 结果为[3, 5, 7, 9, 11, 13] map函数会把后面迭代器对象中的元素迭代出来经过func加工，当最短的可迭代用尽是停止，所以只进行到6+7就结束了。 reducereduce是减少、合并的意思，会把可迭代对象中的元素经过函数的加工进而产生新的结果。 翻译过来就是：从左到右累加两个参数的函数到序列的项目，以便将序列减少为单个值。例如，reduce（lambda x，y：x + y，[1,2,3] ，4,5]计算（（（（（1 + 2）+3）+4）+5）。如果存在初始值，则将其放置在计算中序列的项之前，并在序列为空时用作默认值。 reduce函数有三个参数，函数和序列都是必须参数，初始值为可选参数。 应用：比如求1-100的和 12345from functools import reducedef func(x, y): return x+yprint(reduce(func, [i for i in range(1,101)]))# 结果为 5050 filterfilter的意思为过滤，通过函数的返回值对序列进行过滤。 翻译过来：返回一个迭代器，产生函数（item）为真的迭代项。 如果函数为None，则返回结果为真的项。 12345def func(x): return x.isdigit()lis = ['12', 'ad', '34', 'bc', '46']print(list(filter(func, lis)))# 结果为 ['12', '34', '46'] filter过滤结果为真的值放进迭代器中。 高阶函数和匿名函数map和匿名函数在之前map函数中的func参数都是定义了一个有名参数，然后用函数名传入map函数的，有了匿名函数就不用这么麻烦了。 123lis = [1, 2, 3, 4, 5, 6]print(list(map(lambda x: x*2, lis)))# 结果为 [2, 4, 6, 8, 10, 12] reduce和匿名函数12print(reduce(lambda x, y: x + y, [i for i in range(101)], 100))# 输出结果为 5050 filter和匿名函数12345678sala = &#123; 'MAC': 30000, 'iPhone': 9000, 'lenovo': 10000, 'xiaomi': 3000&#125;print(list(filter(lambda x: sala[x] &gt; 5000, sala)))# 输出结果为 [‘iPhone', 'lenovo'] 匿名函数的使用场景较为单一，一次性使用，随用随时定义。在某些场景下和高阶函数结合会提升效率，同时使代码更加简洁。 递归一 递归调用的定义递归调用时函数嵌套调用的一种特殊形式，函数在调用时，直接或间接地调用了自身，就是递归调用。 1234567891011121314151617181920# 直接调用自身def f1(): print('from f1') f1()f1()# 间接调用自身def f1(): print('from f1') f2()def f2(): print('from f1') f1()f2()# 调用函数会产生局部的名称空间，占用内存，因为上述这种调用会无限调用自身，python解释器的内存管理机制为了防止无限占用内存，对函数的递归调用做了层级限制，可以通过代码修改最大层级限制。import syssys.setrecursionlimit(100000) 二 递归调用的两个阶段递归调用包含两个明确的阶段：回溯，递推 回溯就是从外向里一层一层递归调用下去，回溯阶段必须要有一个明确的结束条件（不然会成为死循环），每进入下一次递归时，问题的规模都应该有所减少。 递推就是从里向外一层层结束递归。 递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈实现的，每当进入一个函数调用，在栈下面会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以递归调用次数过多，会导致栈溢出） 三 二分法从一个排序的数字列表中找到指定的数字，使用遍历的效率太低，使用二分法可以极大地缩小问题规模。 实现in的效果 123456789101112131415nums = [1,5,12,23,34,46,59,99,443]def fucn(num, nums): if len(nums) == 0: return mid_index = len(nums) // 2 if num &gt; nums[mid_index]: nums = nums[mid_index+1:] fucn(num, nums) elif num &lt; nums[mid_index]: nums = nums[:mid_index] fucn(num,nums) else: print('not exis') 实现index的效果 1234567891011121314151617181920212223nums = [1, 13, 15, 23, 27, 31, 33, 57, 73, 81, 93, 94, 97, 101] # 从小到大排列的数字列表def binary_search(find_num,nums): print(nums) if len(nums) == 0: print('not exists') return # 功能 mid_index = len(nums) // 2 if find_num &gt; nums[mid_index]: # in the right nums=nums[mid_index+1:] # 重新运行功能,传入新列表 binary_search(find_num,nums) elif find_num &lt; nums[mid_index]: # in the left nums=nums[:mid_index] # 重新运行功能,传入新列表 binary_search(find_num,nums) else: print('find it') binary_search(95,nums)]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符编码]]></title>
    <url>%2F2018%2F10%2F08%2F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[本来都以为自己完全弄懂字符编码了，昨天一个小问题给难倒了，思考了很久才得出答案，惭愧 字符编码的简介字符编码可以说每一种编程语言都会遇到的问题，为什么会有这么多的问题呢，就是因为计算机发展速度太快了，不仅计算机的诞生国要使用，第三世界国家也要使用，所以人和计算机的交流方式就变得复杂起来。像英语国家最简单，直接用一个字节也就是7bit，总共128种状态就可以满足交流需求；但是像中国等不以英语为第一母语的国家就会出很多问题了，但中文就有60000+个，那么很显然，7bit满足不了需求，所以为了满足需求，中国出了gb2312编码，不过gb2312也不能满足需求，所以又出来了gbk编码，可以表示60000+汉子。 虽然可以通过自己国家去规定本国的字符编码方式，可是这么多国家，每个国家都有自己的编码方式，那么跨过交流会变得困难起来。为了解决这种问题，在1990年开始起草unicode码，简称万国码。里面是一张超级大的对照表，包含了所有的编码集，比如：utf-8、shiftjis、gbk、iso-8859-1。既然包含这么多的对照表，那么每个国家都继续用自己的编码操作文件，但是在内存中都用unicode码，存的时候又根据unicode对照映射成自己国家的编码方式存储不就可以解决跨国交流的问题了嘛。 文本编辑器打开文件文本编辑器打开文件通常分为三步： 首先启动文本编辑器 文本编辑器将存储在硬盘中的文件读入内存 文本编辑器识别内存中文件的编码方式进而解码 第一步不用多解释了，重要在第二步和第三步。 硬盘中的文件会有一种编码方式，如下图 可以看出来有ASCII和UTF-8两种编码方式，所以当文本编辑器将它们读入内存中时，需要按照ASCII和UTF-8分别解码成unicode码（内存中默认编码都为unicode），第三步需要在显示屏上显示出来，那么需要将内存中的unicode码解码出来，那么这时候按照什么解码方式呢？如果我们没指定的话按照当前环境的编码方式，比如windows系统默认编码方式为gbk，类linux系统默认编码方式为utf-8。所以这就会出现问题了，假如在windows系统中读取utf-8编码方式的文件时 在windows下使用python2进行试验，定义了一个变量，并且是unicode编码的，当我分别是用utf-8和gbk对unicode编码时，然后打印发现utf-8码乱码了，这就说明在打印的时候会根据当前环境的编码方式进行解码，这和windows默认编码为gbk是相符的。 python中的编码在python中有两种编码：分别为文件编码以及运行代码时定义字符串的编码 第一种在前面解释了，总的来说一个文本编辑器从硬盘中读入文件时，第一步按照文件存储的编码解码为unicode码存入内存，然后根据文件头声明的编码解码（如果有文件头声明编码方式的话），否则就按照环境默认编码进行解码。 而python2和python3有很大的不同，python2默认编码为ascii，python3默认编码为utf-8，即python2编写的文件默认为ASCII编码，python3编写的文件默认为utf-8编码，但是读入内存中都需要解码为unicode。 第二种的话，在上幅图中为了演示，把字符串定义为unicode码，那么字符串前面不加’u’呢？ 按照我们之前的认识，ASCII识别不了中文，所以在print(a)时应该会报错才对啊，为什么不报错呢？这个应该是python2做的改变，当识别不了中文时，使用当前系统默认编码进行编码和解码，来证明一下，我使用linux做个试验就知道了。 真相大白了，python2这个改进不得不说挺机智的，因为历史遗留问题才导致python2的编码问题经过这样算是一种比较完美的解决方式。而完美的python3会有这种问题吗？怎么可能。python3是完美的。]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ssh免钥登陆github]]></title>
    <url>%2F2018%2F10%2F01%2Fgit-ssh%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[设置Git的user name和emai：（如果是第一次的话）$ git config --global user.name &#39;musibii&#39;$ git config --global user.email &#39;shaozuanzuan@gmail.com&#39; 生成秘钥$ ssh-keygen -t rsa -C &#39;shaozuanzuan@gmail.com&#39;从图上可以看到生成秘钥保存的地址，通常都会默认保存在家目录下面的.ssh下，前面加点表示是个隐藏目录。 添加秘钥到ssh-agentssh-agent是一个帮助程序，用于跟踪用户的身份密钥及其密码。 然后，代理可以使用密钥登录其他服务器，而无需用户再次键入密码或密码.运行ssh-agent之后，使用ssh-agent将私钥交给ssh-agent保管，其他程序需要身份验证的时候就可以将验证申请交给ssh-agent来完成整个认证过程。添加生成的ssh key到ssh-agent$ ssh-add ~/.ssh/id_rsa 登录github，添加ssh秘钥可以看到我有两个密钥，一个是macOS的，一个是Ubuntu的。 测试是否成功$ ssh -T git@github.com万万没想到，报错了。。。报错原因居然是没联网。。。靠北！！！重新联网成功了。。]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mac下配置github个人博客]]></title>
    <url>%2F2018%2F09%2F29%2FMac%E4%BD%BF%E7%94%A8Hexo%E9%85%8D%E7%BD%AEGItHub%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一 前言本来一直用博客园写博客的，奈何博客园界面惨不忍睹，而且自带的markdown编辑器更是烂的可以，于是在室友makeupstories的建议下开始尝试搭建自己的github博客，真是一路心酸啊！不过成就感也是大大滴。 二 准备工作创建Github域名和放博客的库 首先需要注册一个Github账号。 注册之后需要新建一个库(repository)来存储网站，点击首页任意位置出现的New repository按钮创建仓库，注意这个仓库名不能随便写。例如我的Github账号为musibii，那么库名为musibii.github.io。 安装Git、Nodejs和HexoHexo可以说是最流行的博客框架了，基于Nodejs，想要搭建好，需要安装Git、Nodejs和Hexo。 安装Git可以直接在命令行使用brew来安装Git$ brew install git 因为我之前已经安装了Git，所以这次给我安装了两个扩展包。 安装Nodejs为了便于管理Nodejs版本，首先安装nvm，这是Nodejs版本管理器，可以实现Nodejs多版本切换。$ curl -o- [https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh](https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh) | bash安装完成后，重启终端并执行下列命令即可安装Node.js$ nvm install \d后面跟的是Node.js的版本，今天就是被这个给坑了，应该安装较新的版本，之前安装的为 4，然后一直报错。$ nvm install 8安装后在终端输入$ nvm use node就会使用最新的nodejs版本了。 安装Hexo$ sudo npm install hexo-cli -g注意需要sudo权限，不然会出错 配置博客接下来需要使用Hexo来初始化一个博客，然后根据自己的需求更改一些自定义配置，比如字体、动画效果、主题等等。 创建博客为自己的博客创建一个文件夹，然后cd 文件夹，并执行下面的代码。$ hexo init username.github.io 更改主题 基础配置然后需要的就是在_config.yml里面修改个人信息，比如博客的主题、作者还有语言以及修改的主题名，最重要的是要和你的github仓库关联起来。其他的可以根据自己的需求酌情更改，比如我就增加了页面的动画效果Next主题动画效果 你的第一篇博客 $ hexo new &#39;你的博客名字&#39;执行完后会在‘username.github.io/source/_posts/‘目录下出现你的博客名字 博客使用markdown格式，编写完后执行$ hexo server如果出现下面的页面 在浏览器页面输入http://localhost:4000我的界面会和你们的不一样，出现了 Hello就说明成功了。 安装hexo-deployer-git –save自动部署发布工具$ npm install hexo-deployer-git --save 发布博客$ hexo deploy结束后进入博客就可以看见了！]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Hello,my name is musibii! Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
