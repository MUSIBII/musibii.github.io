<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Django（七）]]></title>
    <url>%2F2019%2F01%2F09%2FDjango%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django 系列博客（七）前言本篇博客介绍 Django 中的视图层中的相关参数，HttpRequest 对象、HttpResponse 对象、JsonResponse，以及视图层的两种响应方式 CBV 和 FBV，还有简单的文件上传。 视图函数一个视图函数，简称视图，是一个简单的Python 函数，它接受Web请求并且返回Web响应。响应可以是一张网页的HTML内容，一个重定向，一个404错误，一个XML文档，或者一张图片. . . 是任何东西都可以。无论视图本身包含什么逻辑，都要返回响应。代码写在哪里也无所谓，只要它在你的Python目录下面。除此之外没有更多的要求了——可以说“没有什么神奇的地方”。为了将代码放在某处，约定是将视图放置在项目或应用程序目录中的名为views.py的文件中。 下面是一个返回当前日期和时间作为 HTML 文档的视图： 1234567from django.shortcuts import render, HttpResponse, HttpResponseRedirect, redirectimport datetimedef current_datetime(request): now = datetime.datetime.now() html = "&lt;html&gt;&lt;body&gt;It is now %s.&lt;/body&gt;&lt;/html&gt;" % now return HttpResponse(html) 这段代码解析： 从 django.shortcuts模块导入了HttpResponse类，以及Python的datetime库； 定义了current_datetime函数。它就是视图函数。每个视图函数都使用HttpRequest对象作为第一个参数，并且通常称之为request； 注意,视图函数的名称并不重要；不需要用一个统一的命名方式来命名，以便让Django识别它。我们将其命名为current_datetime，是因为这个名称能够精确地反映出它的功能。 会返回一个HttpResponse对象，其中包含生成的响应。每个视图函数都负责返回一个HttpResponse对象。 在视图层最重要的就是要熟悉两个对象：请求对象（request）和响应对象（HttpResponse）。 HttpRequest 对象request 属性Django 将请求报文中的请求行、请求头、请求体封装成 HttpRequest 类中的属性。除了特殊说明之外，其他的均为只读属性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181.HttpRequest.GET 一个类似于字典的对象，包含 HTTP GET 的所有参数。详情请参考 QueryDict 对象。2.HttpRequest.POST 一个类似于字典的对象，如果请求中包含表单数据，则将这些数据封装成 QueryDict 对象。 POST 请求可以带有空的 POST 字典 —— 如果通过 HTTP POST 方法发送一个表单，但是表单中没有任何的数据，QueryDict 对象依然会被创建。 因此，不应该使用 if request.POST 来检查使用的是否是POST 方法；应该使用 if request.method == "POST" 另外：如果使用 POST 上传文件的话，文件信息将包含在 FILES 属性中。 注意：键值对的值是多个的时候,比如checkbox类型的input标签，select标签，需要用： request.POST.getlist("hobby")3.HttpRequest.body 一个字符串，代表请求报文的主体。在处理非 HTTP 形式的报文时非常有用，例如：二进制图片、XML,Json等。 但是，如果要处理表单数据的时候，推荐还是使用 HttpRequest.POST 。4.HttpRequest.path 一个字符串，表示请求的路径组件（不含域名）。 例如："/music/bands/the_beatles/"5.HttpRequest.method 一个字符串，表示请求使用的HTTP 方法。必须使用大写。 例如："GET"、"POST"6.HttpRequest.encoding 一个字符串，表示提交的数据的编码方式（如果为 None 则表示使用 DEFAULT_CHARSET 的设置，默认为 'utf-8'）。 这个属性是可写的，你可以修改它来修改访问表单数据使用的编码。 接下来对属性的任何访问（例如从 GET 或 POST 中读取数据）将使用新的 encoding 值。 如果你知道表单数据的编码不是 DEFAULT_CHARSET ，则使用它。7.HttpRequest.META 一个标准的Python 字典，包含所有的HTTP 首部。具体的头部信息取决于客户端和服务器，下面是一些示例： 取值： CONTENT_LENGTH —— 请求的正文的长度（是一个字符串）。 CONTENT_TYPE —— 请求的正文的MIME 类型。 HTTP_ACCEPT —— 响应可接收的Content-Type。 HTTP_ACCEPT_ENCODING —— 响应可接收的编码。 HTTP_ACCEPT_LANGUAGE —— 响应可接收的语言。 HTTP_HOST —— 客服端发送的HTTP Host 头部。 HTTP_REFERER —— Referring 页面。 HTTP_USER_AGENT —— 客户端的user-agent 字符串。 QUERY_STRING —— 单个字符串形式的查询字符串（未解析过的形式）。 REMOTE_ADDR —— 客户端的IP 地址。 REMOTE_HOST —— 客户端的主机名。 REMOTE_USER —— 服务器认证后的用户。 REQUEST_METHOD —— 一个字符串，例如"GET" 或"POST"。 SERVER_NAME —— 服务器的主机名。 SERVER_PORT —— 服务器的端口（是一个字符串）。 从上面可以看到，除 CONTENT_LENGTH 和 CONTENT_TYPE 之外，请求中的任何 HTTP 首部转换为 META 的键时， 都会将所有字母大写并将连接符替换为下划线最后加上 HTTP_ 前缀。 所以，一个叫做 X-Bender 的头部将转换成 META 中的 HTTP_X_BENDER 键。8.HttpRequest.FILES 一个类似于字典的对象，包含所有的上传文件信息。 FILES 中的每个键为&lt;input type="file" name="" /&gt; 中的name，值则为对应的数据。 注意，FILES 只有在请求的方法为POST 且提交的&lt;form&gt; 带有enctype="multipart/form-data" 的情况下才会 包含数据。否则，FILES 将为一个空的类似于字典的对象。9.HttpRequest.COOKIES 一个标准的Python 字典，包含所有的cookie。键和值都为字符串。10.HttpRequest.session 一个既可读又可写的类似于字典的对象，表示当前的会话。只有当Django 启用会话的支持时才可用。 完整的细节参见会话的文档。11.HttpRequest.user(用户认证组件下使用) 一个 AUTH_USER_MODEL 类型的对象，表示当前登录的用户。 如果用户当前没有登录，user 将设置为 django.contrib.auth.models.AnonymousUser 的一个实例。你可以通过 is_authenticated() 区分它们。 例如： if request.user.is_authenticated(): # Do something for logged-in users. else: # Do something for anonymous users. user 只有当Django 启用 AuthenticationMiddleware 中间件时才可用。 ------------------------------------------------------------------------------------- 匿名用户 class models.AnonymousUser django.contrib.auth.models.AnonymousUser 类实现了django.contrib.auth.models.User 接口，但具有下面几个不同点： id 永远为None。 username 永远为空字符串。 get_username() 永远返回空字符串。 is_staff 和 is_superuser 永远为False。 is_active 永远为 False。 groups 和 user_permissions 永远为空。 is_anonymous() 返回True 而不是False。 is_authenticated() 返回False 而不是True。 set_password()、check_password()、save() 和delete() 引发 NotImplementedError。 New in Django 1.8: 新增 AnonymousUser.get_username() 以更好地模拟 django.contrib.auth.models.User。 request常用方法1234567891011121314151.HttpRequest.get_full_path() 返回 path，如果可以将加上查询字符串。 例如："/music/bands/the_beatles/?print=true" 注意和path的区别：http://127.0.0.1:8001/order/?name=lqz&amp;age=102.HttpRequest.is_ajax() 如果请求是通过XMLHttpRequest 发起的，则返回True，方法是检查 HTTP_X_REQUESTED_WITH 相应的首部是否是字符串'XMLHttpRequest'。 大部分现代的 JavaScript 库都会发送这个头部。如果你编写自己的 XMLHttpRequest 调用（在浏览器端），你必须手工设置这个值来让 is_ajax() 可以工作。 如果一个响应需要根据请求是否是通过AJAX 发起的，并且你正在使用某种形式的缓存例如Django 的 cache middleware， 你应该使用 vary_on_headers('HTTP_X_REQUESTED_WITH') 装饰你的视图以让响应能够正确地缓存。 HttpResponse 对象响应对象主要有三种形式：前面的博客有相关介绍 HttpResponse()； render()； redirect(). HttpResponse()括号内直接跟一个具体的字符串作为响应体，比较直接和简单，所以这里介绍后两种 render()1render(request, template_name[, context]) 结合给定的模板和一个上下文字典，返回一个经过 Django渲染后的HttpResponse 对象到前端。 参数： request：用于生成响应的请求对象； template_name：要使用的模板的完整名称，可选的参数； context：添加到模板上下文的一个字典。默认是一个空字典，如果字典中的某个值是可调用的，视图将在渲染模板之前调用它； render 方法就是将一个模板页面中的模板语法进行渲染，最终渲染成一个 HTML 页面作为响应返回给前端。 redirect()传递要重定向的一个硬编码的URL 123def my_view(request): ... return redirect('/some/url/') 也可以是一个完成的 url 123def my_view(request): ... return redirect('http://www.baidu.com/') JsonResponse对象向前端返回一个 json 格式的字符串，有两种方式： 第一种方式1234import jsondata = &#123;'name': 'musibii', 'age': 18&#125;return HttpResponse(json.dumps(data))# 从这里可以看出其实 Jsonresponse内部也是调用了 json 的 dumps 方法进行转换 第二种方式12345from django.http import JsonResponsedata = &#123;'name': 'musibii', 'age': 18&#125;return JsonResponse(data1,safe=False)# safe参数是一种安全机制，因为如果要传输列表类型的数据时，会因为内部的相关机制会产生错误。 CBV 和 FBVCBV 基于类的视图（Class Base View）和 FBV 基于函数的视图（Function Base View） CBV123456789101112131415161718192021222324252627282930313233343536373839from django.views import Viewclass Login(View): def dispatch(self, request, *args, **kwargs): print(request) print(args) print(kwargs) # 可以写类似装饰器的东西，在前后加代码 obj=super().dispatch(request, *args, **kwargs) return obj def get(self, request): return render(request, 'login.html') def post(self, request): name = request.POST.get('name') ret = BookInfo.objects.filter(name=name).first() print(type(ret)) dic = &#123;&#125; print(ret.name) print(type(ret.__dict__)) for key, value in (ret.__dict__).items(): if key[0].startswith('_'): continue print(key) dic[key] = value # print(dic) # ret = BookInfo.objects.all() # lis = [] # for info in ret: # dic = &#123;&#125; # for k, v in (info.__dict__).items(): # if key[0].startswitch(''): # continue # dic[key] = v # lis.append(dic) return JsonResponse(dic, json_dumps_params=&#123;'ensure_ascii': False&#125;) FBV12345678910111213141516171819def file_upload(request): if request.method=="GET": return render(request,'file_upload.html') else: print(request.POST) print(request.FILES) # print(request.body) # FILES是一个字典, # &lt;MultiValueDict: &#123;'myfile': [&lt;InMemoryUploadedFile: 1.jpg (image/jpeg)&gt;]&#125;&gt; # 拿到上传的文件对象 file=request.FILES.get('myfile') print(type(file)) from django.core.files.uploadedfile import InMemoryUploadedFile with open(file.name,'wb') as f: # for line in file.chunks(): for line in file: f.write(line) return HttpResponse('上传成功') 简单文件上传模板文件12345678910111213141516171819# upload_file.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="" method="post" enctype="multipart/form-data"&gt; &lt;p&gt;用户名:&lt;input type="text" name="name"&gt;&lt;/p&gt; &lt;input type="file" name="myfile"&gt;&#123;# &lt;input type="file" name="myfile2"&gt;#&#125; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 路由文件12345from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url(r'^upload_file/$', views.UploadFile.as_view()),] 视图文件123456789101112131415class UploadFile(View): def get(self, request): return render(request, 'upload_file.html') def post(self, request): file = request.FILES.get('myfile') # print(file['file']) from django.core.files.uploadedfile import InMemoryUploadedFile print(time.time()) filename = str(time.time()).split('.')[0] + file.name with open(filename, 'wb') as f: for line in file: f.write(line) return HttpResponse('上传成功')]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django（六）]]></title>
    <url>%2F2019%2F01%2F09%2FDjango%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django 系列博客（六）前言本篇博客介绍 Django 中的路由控制部分，一个网络请求首先到达的就是路由这部分，经过路由与视图层的映射关系再执行相应的代码逻辑并将结果返回给客户端。 Django 中路由的作用URL 配置（URLconf）可以比作是 Django 支撑网站的目录。它的本质是 URL 要为该 URL 滴啊用的视图函数之间的映射表。以这种方式告诉 Django，对于客户端发来的 URL 要具体调用视图层的哪段代码。 1234567from django.urls import urlfrom app import viewsurlpatterns = [ url(r'^$', views.home),]# ^$ 这个路由对应视图函数中的 home 方法，只要浏览器往该网址发送请求，就会响应到这个函数执行。 简单的路由配置12345from django.conf.urls import urlurlpatterns = [ url(正则表达式, views视图函数, 默认参数, 路由别名),] 正则表达式：一个正则表达式字符串； views 视图函数：一个可调用对象，通常为一个视图函数或一个指定视图路径的字符串； 默认参数：可选的要传递给视图函数的默认参数（字典形式）； 路由别名：一个可选的name 参数。 12345678from django.conf.urls import urlfrom app import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^article/(\d&#123;4&#125;)/(\d&#123;2&#125;)', views.article), url(r'^user/(?P&lt;name&gt;[a-z]&#123;3&#125;)', views.user_havename), url(r'^user/$', views.user)] 注意： 若要从 URL 中捕获一个值，只需要在它周围放置一对圆括号； 不需要添加一个前导的反斜杠，因为每个 url 都有。例如，应该是^articles而不是^/articles。 每个正则表达式前面的r是可选的，但是建议加上，表示这是个原生字符串，字符串中的任何字符都不应该转义。 urlpatterns 中的元素按照书写顺序从上往下逐一匹配正则表达式，一旦匹配成功则不再继续。 1234567一些请求的例子：/articles/2005/03/ 请求将匹配列表中的第三个模式。Django 将调用函数views.month_archive(request, '2005', '03')。/articles/2005/3/ 不匹配任何URL 模式，因为列表中的第三个模式要求月份应该是两个数字。/articles/2003/ 将匹配列表中的第一个模式不是第二个，因为模式按顺序匹配，第一个会首先测试是否匹配。请像这样自由插入一些特殊的情况来探测匹配的次序。/articles/2003 不匹配任何一个模式，因为每个模式要求URL 以一个反斜线结尾。/articles/2003/03/03/ 将匹配最后一个模式。Django 将调用函数views.article_detail(request, '2003', '03', '03')。 APPEND_SLASH该参数的作用是会在访问连接的时候，如果连接没有加斜杠，会自动加上。可以在global_settings.py中修改。 项目的 settings 中没有改配置的选项，一个项目会有两个 settings。 效果： 123456from django.conf.urls import urlfrom app_01 import viewsurlpatterns = [ url(r'^blog/$', views.blog),] 当我们访问http://www.example.com/blog时，默认将网址自动替换成http://www.example.com/blog/。如果将该配置值设为false，此时在向该网址发送请求时就会提示找不到页面。 分组当我们需要捕获 url 中的参数并要传递给视图函数时，有两种捕获方式：无名分组和有名分组。无名分组就是该值没有变量标识，传值的时候采用位置参数传递；有名分组就是给捕获的值赋值一个变量，这样就可以通过关键字参数传值了。 无名分组1234567# urls.py文件from django.conf.urls import urlfrom app_01 import viewsurlpatterns = [ url(r'^article/(\d&#123;4&#125;)/(\d&#123;2&#125;)', views.article),] 12345# views.py文件from django.shortcuts import HttpResponsedef article(reques, year, month): return HttpResponse('您要查看%s 年%s 月的文章' %(year, month)) 通过圆括号捕获年份和月份，然后通过位置参数传递给 year 和 month 变量，接着在 views 函数中使用。 有名分组123456import reret=re.search('(?P&lt;year&gt;[0-9]&#123;4&#125;)/([0-9]&#123;2&#125;)','2012/12')print(ret.group())print(ret.group(1))print(ret.group(2))print(ret.group('year')) 这些示例使用简单的、没有命名的正则表达式组（通过圆括号）来捕获 URL 中的值并以位置参数传递给视图。在更高级的用法中，可以使用命名的正则表达式组来捕获 URL 中的值并以关键子参数传递给视图函数。 在python 正则表达式中，命名有名分组的语法时(P&lt;变量名&gt;pattern)，其中变量名是分组的标识符，pattern 是要匹配的正则表达式。下面是上面 URLconf 使用有名分组的重写： 12345678910111213141516from django.urls import path, re_pathfrom app_01 import viewsurlpatterns = [ re_path(r'^articles/2003/$', views.special_case_2003), re_path(r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$', views.year_archive), re_path(r'^articles/(?P&lt;year[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/$', views.month_archive), re_path(r'^articles/(?P&lt;year[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/(?P&lt;day&gt;[0-9]&#123;2&#125;)/$', views.archive_detail),]# 捕获到的数据都是 str 类型# 视图函数里可以指定默认值url('blog/$', views.blog),# url('blog/?(?P&lt;num&gt;[0-9]&#123;1&#125;)', views.blog),def blog(request, num=1): print(num) return HttpResponse('ok') 这个实现与前面的示例完全相同，只有一个细微的差别：捕获的值作为关键字参数而不是位置参数传递给视图函数。例如： 12/articles/2005/03/ 请求将调用views.month_archive(request, year='2005', month='03')函数，而不是views.month_archive(request, '2005', '03')。 /articles/2003/03/03/ 请求将调用函数views.article_detail(request, year='2003', month='03', day='03')。 在实际应用中，这意味你的 URLconf 会更加清晰且不容易产生参数顺序问题的错误，可以在视图函数定义中重新安排参数的顺序。 路由分发其实和项目名相同的文件夹下面的urls.py文件是整个项目的根路由： 这是整个项目的根路由，所有向该项目发送的连接请求，首先需要从该路由配置里面过滤，如果只有一个应用，或者路由配置不多一个根路由就足够了，但当 app 多起来之后还是使用一个根路由配置会造成路由混乱，所以有了路由分发，比如这是发往app_01应用的连接，那么在根路由中进行路由分发，把连接转向app_01中的路由中进行处理，这就是路由分发。 123456789# 根路由配置from django.conf.urls import url, includefrom app_01 import viewsfrom app_01 import urlsurlpatterns = [ # url(r'^app_01/', include('app_01.urls')), # 注意前面的正则表达式后面不能加$ url(r'^app_01/', include(urls)),] 1234567# 应用路由配置from django.conf.urls import urlfrom app_01 import viewsurlpatterns = [ # url(r'^test/(?P&lt;year&gt;[0-9]&#123;2&#125;)/$', views.url_test),] 反向解析在使用 Django 项目时，一个常见的需求是获得 URL 的最终形式，以用于嵌入到生成的内容中（视图中和显示给用户的 URL 等）或者用于处理服务器端的导航（重定向等）。人们强烈希望不要硬编码这些 URL（费时费力、不可扩展且易产生错误）或者设计一种与 URLconf 毫不相关的专门的 URL 生成机制，因为这样容易导致一定程度上产生过期的 URL。 在需要 URL 的地方，对于不同层级，Django 提供不同的工具用于 URL 反查： 在模板中：使用 url 模板标签； 在 python 代码中：使用from django.urls import reverse。 1234567# urls.py文件from django.urls import path, re_pathfrom app_01 import viewsurlpatterns = [ re_path(r'^test/(?P&lt;year&gt;[0-9]&#123;2&#125;)/(P?&lt;month&gt;[0-9]&#123;2&#125;)/$', views.url_test, name='test'),] &lt;a href=&quot;&amp;#123;% url &#39;test&#39; 10 23 %&amp;#125;&quot;&gt;哈哈&lt;/a&gt; 123456# views.py文件from django.shortcuts import render, HttpResponse, redirect, reversedef url_test(request, year, month): url = reverse('test', args=(10, 20)) return HttpResponse('ok') 总结： 在 html 代码里面使用&amp;#123;% url &#39;别名&#39; 参数 参数... %&amp;#125;； 在视图函数中： url = reverse(&#39;test&#39;) url = reverse(&#39;test&#39;, args=(10, 20)) 当命名 URL 模式时，要确保使用的名称不会与其他应用中的名称产生冲突。如果你的 URL 模式叫做 comment，而另外一个应用中也有一个同样的名字，当你在模板中使用这个名称的时候不能保证将插入哪个 URL。在 URL 名称加上一个前缀，比如应用的名称，将会减少冲突的可能。建议使用myapp-comment。 名称空间命名空间（namespace）是表示标识符的可见范围。一个标识符可在多个命名空间中定义，它在不同命名空间中的含义是互不相干的。这样在一个新的命名空间中可以定义任何标识符，它们不会与任何已有的标识符产生冲突，因为已有的定义处于其他的命名空间中。 由于name没有作用域，Django 在返解 URL 时，会在项目的全局路径中按顺序搜索，当查找到第一个name指定的 URL 时，立即返回。 在开发项目时，会经常使用name属性反解出 URL，当不小心在不同的 app 的 urls 中定义相同的name时，可能会导致 URL 反解错误，为了避免发生引入了命名空间。 创建 app01和 app02python manage.py startapp app01 python manage.py startapp app02 根路由123456from django.urls import path,re_path,includeurlpatterns = [ path('app01/', include('app01.urls')), path('app02/', include('app02.urls'))] app01的 urls.py123456from django.urls import path,re_pathfrom app01 import viewsurlpatterns = [ re_path(r'index/',views.index,name='index'),] app02的 urls.py123456from django.urls import path, re_path, includefrom app02 import viewsurlpatterns = [ re_path(r'index/', views.index,name='index'),] app01的视图1234def index(request): url=reverse('index') print(url) return HttpResponse('index app01') app02的视图1234def index(request): url=reverse('index') print(url) return HttpResponse('index app02') 这样都找index.html，app01和 app02找到的都是app02的 index。如何处理？在路由分发的时候指定名称空间。根路由在路由分发是，指定名称空间。 1234567891011# 一path('app01/', include(('app01.urls','app01'))),path('app02/', include(('app02.urls','app02')))# 二url(r'app01/',include('app01.urls',namespace='app01')),url(r'app02/',include('app02.urls',namespace='app02'))# 三url(r'app01/',include(('app01.urls','app01'))),url(r'app02/',include(('app02.urls','app02'))) 在视图函数反向解析的时候，指定名称空间： 1234url=reverse('app02:index')print(url)url2=reverse('app01:index')print(url2) 在模板里面也是用相应的名称空间名： &lt;a href=&quot;&amp;#123;% url &#39;app02:index&#39;%&amp;#125;&quot;&gt;哈哈&lt;/a&gt; Django2.0版的 pathDjango2.0的re_path和1.0的url一样。2.0多了个path 思考情况如下： 123456urlpatterns = [ re_path('articles/(?P&lt;year&gt;[0-9]&amp;#123;4&amp;#125;)/', year_archive), re_path('article/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/detail/', detail_view), re_path('articles/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/edit/', edit_view), re_path('articles/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/delete/', delete_view), ] 考虑下这样的两个问题： 第一个问题，函数 year_archive 中year参数是字符串类型的，因此需要先转化为整数类型的变量值，当然year=int(year) 不会有诸如如TypeError或者ValueError的异常。那么有没有一种方法，在url中，使得这一转化步骤可以由Django自动完成？ 第二个问题，三个路由中article_id都是同样的正则表达式，但是你需要写三遍，当之后article_id规则改变后，需要同时修改三处代码，那么有没有一种方法，只需修改一处即可？ 在Django2.0中，可以使用 path 解决以上的两个问题。 基本示例12345678910from django.urls import path from . import views urlpatterns = [ path('articles/2003/', views.special_case_2003), path('articles/&lt;int:year&gt;/', views.year_archive), path('articles/&lt;int:year&gt;/&lt;int:month&gt;/', views.month_archive), path('articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug&gt;/', views.article_detail), # path才支持，re_path不支持 path('order/&lt;int:year&gt;',views.order),] 基本规则： 使用尖括号(&lt;&gt;)从 url中捕获值； 捕获值中可以包含一个转化器类型（converter type），比如使用&lt;int:name&gt;捕获一个整数变量。如果没有转化器，将匹配任何字符串，也包含/字符。 无需添加前导斜杠 以上是示例，分别和上面的基本示例对应： path 转换器 str：匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式； int：匹配正整数，包含0； slug：匹配字母、数字、横杠以及下划线组成的字符串； uuid：匹配格式化的uuid，如075194d3-6885-417e-a8a8-6c931e272f00。 path： 匹配任何非空字符，包含了路径分隔符（/） 注册自定义转化器对于一些复杂或者复用的需要，可以定义自己的转化器。转化器是一个类或接口，它的要求有三点： regex类属性，字符串类型； to_python(self, value)方法，value 是由类属性 regex 所匹配到的字符串，返回具体的 python 变量值，以供 Django 传递到对应的视图函数中； to_url(self, value)方法，和to_python相反，value 是一个具体的 python 变量值，返回其字符串，通常用于 url 反向引用。 示例12345678class FourDigitYearConverter: regex = '[0-9]&#123;4&#125;' def to_python(self, value): return int(value) def to_url(self, value): return '%04d' % value 使用register_converter将其注册到 URL 配置中： 123456789from django.urls import register_converter, pathfrom . import converters, viewsregister_converter(converters.FourDigitYearConverter, 'yyyy')urlpatterns = [ path('articles/2003/', views.spwcial_case_2003), path('articles/&lt;yyyy:year&gt;/', views.year_archive),]]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django（五）]]></title>
    <url>%2F2019%2F01%2F08%2FDjango%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django 系列博客（五）前言通过上一篇博客学习了 django 处理数据的协议 wsgi，现在应该可以学习 python 是如何处理数据的了。所以本篇博客介绍 Django 的运行方式与处理流程总结。当然还是借鉴学习大佬的博客，本篇博客参考点击，这篇博客我看了三遍，感觉还是没有完全搞懂。]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[wsgi 协议]]></title>
    <url>%2F2019%2F01%2F07%2Fwsgi%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[wsgi 协议前言本来没打算这么早就学习 wsgi 的，因为想要学习python 是如何处理网络请求的绕不开 wsgi，所以只好先学习一下 wsgi。先对 wsgi 有个印象，到了学习 Django 运行方式以及如何处理网络请求数据的时候就会感觉很顺畅了。本文参考 什么是 WSGIwsgi 的全称是Web Server Gateway Interface，这是一个规范，描述了 web server 如何与 web application 交互、web application 如何处理请求。该规范的具体描述在 PEP3333。WSGI 既要实现 web server，也要实现 web application。在 Django 中的 app 其实就是 web application，而 web server其实在使用命令行输入python manage.py runserver或者使用 pycharm 开启 Django 项目的时候就把runserver当做参数传给了 manage.py里面 经过判断然后执行execute_from_command_line(sys.argv)，sys.argv就是 runserver命令，进入该函数，发现执行了utility.execute()函数，进入函数查看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273def execute(self): """ Given the command-line arguments, this figures out which subcommand is being run, creates a parser appropriate to that command, and runs it. """ try: subcommand = self.argv[1] except IndexError: subcommand = 'help' # Display help if no arguments were given. # Preprocess options to extract --settings and --pythonpath. # These options could affect the commands that are available, so they # must be processed early. parser = CommandParser(None, usage="%(prog)s subcommand [options] [args]", add_help=False) parser.add_argument('--settings') parser.add_argument('--pythonpath') parser.add_argument('args', nargs='*') # catch-all try: options, args = parser.parse_known_args(self.argv[2:]) handle_default_options(options) except CommandError: pass # Ignore any option errors at this point. try: settings.INSTALLED_APPS except ImproperlyConfigured as exc: self.settings_exception = exc if settings.configured: # Start the auto-reloading dev server even if the code is broken. # The hardcoded condition is a code smell but we can't rely on a # flag on the command class because we haven't located it yet. if subcommand == 'runserver' and '--noreload' not in self.argv: try: autoreload.check_errors(django.setup)() except Exception: # The exception will be raised later in the child process # started by the autoreloader. Pretend it didn't happen by # loading an empty list of applications. apps.all_models = defaultdict(OrderedDict) apps.app_configs = OrderedDict() apps.apps_ready = apps.models_ready = apps.ready = True # Remove options not compatible with the built-in runserver # (e.g. options for the contrib.staticfiles' runserver). # Changes here require manually testing as described in # #27522. _parser = self.fetch_command('runserver').create_parser('django', 'runserver') _options, _args = _parser.parse_known_args(self.argv[2:]) for _arg in _args: self.argv.remove(_arg) # In all other cases, django.setup() is required to succeed. else: django.setup() self.autocomplete() if subcommand == 'help': if '--commands' in args: sys.stdout.write(self.main_help_text(commands_only=True) + '\n') elif len(options.args) &lt; 1: sys.stdout.write(self.main_help_text() + '\n') else: self.fetch_command(options.args[0]).print_help(self.prog_name, options.args[0]) # Special-cases: We want 'django-admin --version' and # 'django-admin --help' to work, for backwards compatibility. elif subcommand == 'version' or self.argv[1:] == ['--version']: sys.stdout.write(django.get_version() + '\n') elif self.argv[1:] in (['--help'], ['-h']): sys.stdout.write(self.main_help_text() + '\n') else: self.fetch_command(subcommand).run_from_argv(self.argv) 源码太长了。。。我把关键地方抠出来： 123456789101112131415161718192021222324252627if settings.configured: # Start the auto-reloading dev server even if the code is broken. # The hardcoded condition is a code smell but we can't rely on a # flag on the command class because we haven't located it yet. if subcommand == 'runserver' and '--noreload' not in self.argv: try: autoreload.check_errors(django.setup)() except Exception: # The exception will be raised later in the child process # started by the autoreloader. Pretend it didn't happen by # loading an empty list of applications. apps.all_models = defaultdict(OrderedDict) apps.app_configs = OrderedDict() apps.apps_ready = apps.models_ready = apps.ready = True # Remove options not compatible with the built-in runserver # (e.g. options for the contrib.staticfiles' runserver). # Changes here require manually testing as described in # #27522. _parser = self.fetch_command('runserver').create_parser('django', 'runserver') _options, _args = _parser.parse_known_args(self.argv[2:]) for _arg in _args: self.argv.remove(_arg) # In all other cases, django.setup() is required to succeed. else: django.setup() 这里也是注释最多的地方，可以看到有runserver这条命令，然后这里面在经过一系列的判断最后要执行最后一行代码： 1self.fetch_command(subcommand).run_from_argv(self.argv) 这行代码等学习 Django 处理流程的时候在详细解释，反正只要知道目前经过这个函数的执行，Django 的 web server 成功运行了。 实现了 WSGI 的模块/库有 wsgiref（python 内置，下面也是用这个来举例）、werkzeug.serving、twisted.web等。 当前运行在 wsgi 之上的 web 框架有 Bottle、Flask、Django 等。WSGI server 所做的工作仅仅是将客户端收到的请求传递给 WSGI application，然后将 WSGI application 的返回值作为相应传给客户端。WSGI application 可以是栈式的，这个栈的中间部分叫做中间件，两端是必须要实现的 application 和 server。所以对客户端来说，中间件扮演服务器；对服务器来说，中间件扮演客户端。在 Django 中wsgi 收到的数据用 request对象表示，要传给客户端的数据用 Httpresponse对象表示。 搭建一个 wsgi 服务在上章节说了 python 有个内置的 WSGI 库叫 wsgiref。 首先看下项目结构： 1234# templates为模板（HTML）文件夹# start.py 为项目入口，# urls.py 为路由配置# views.py 为具体处理路由逻辑代码 start 文件123456789101112131415161718192021222324252627282930313233343536# start.py文件from wsgiref.simple_server import make_serverfrom urls import urlsdef app(env, response): # 在这里， print(env) route = env['PATH_INFO'] print(response) # 设置状态码与响应头 response('200 OK', [('Content-type', 'text/html')]) # 设置错误处理 data = urls['/error']() # 设置路由处理 if route in urls: data = urls[route]() # 返回二进制响应体 return [data]if __name__ == '__main__': # 创建服务器对象 server = make_server('', 8808, app) print('服务：http://localhost:8808') # 服务保持运行状态 server.serve_forever() # WSGI server 是一个 web server，其处理一个 HTTP 请求的逻辑如下： # iterable = app(env, response) # for date in iterable: # send data to client 其实这个模块底层使用了 sockserver 模块，我前面的博客也有介绍。经过 make_server就成功开启了wsgi server，然后server_forever()是为了将服务器持续接收客户端请求，采用的是轮询方法，该方法里面的参数 poll_interval=0.5，采用的是0.5秒轮询一次，轮询采用的是 selector学名叫多路复用技术。 urls 文件123456# urls.py文件from views import *urls = &#123; '/index': index, # 函数地址 '/error': error&#125; 该文件就是处理路由的，然后将对应的路由映射到相应的逻辑处理函数。 views 文件123456789101112131415161718192021222324# 处理请求的功能函数(处理结果返回的都是页面 =&gt; 功能函数)# 利用 jinja2来渲染模板，将后台数据传给前台from jinjia2 import Template# 处理主页请求def index(): with open('templates/index.html', 'r') as f: dt = f.read() tem = Template(dt) # 将后台数据通过模板渲染功能渲染传给前台页面 resp = tem.render(name='主页') return resp.encode('utf-8')# 处理图标请求def ico(): with open('favicon.ico', 'rb') as f: dt = f.read() return dt# 处理错误请求def error(): return b'404' templates该文件夹里面放的伪要返回给前端相关资源，比如index.html 测试 index 测试 error 测试 WSGI application接口在上面wsgi 服务中的 app 就是 wsgi 中的 application，该接口应该实现为一个可调用对象，例如函数、方法、类、含__call__方法的实例。这个可调用对象可以接收两个参数： 一个字典，该字典可以包含了客户端请求的信息以及其他信息，可以认为是请求上下文，一般叫做 environment（在这里我取名为 env）； 一个用于发送 HTTP 状态码与响应头的回调函数。（具体怎么回调的还不清楚） 同时，可调用对象的返回值是响应体（response body），响应正文是可迭代的、并包含了多个字符串。（加了中括号可以减少迭代次数，提高效率） 把上面的 app 代码拷下来： 123456789101112131415161718def app(env, response): # 在这里， print(env) route = env['PATH_INFO'] print(response) # 设置状态码与响应头 response('200 OK', [('Content-type', 'text/html')]) # 设置错误处理 data = urls['/error']() # 设置路由处理 if route in urls: data = urls[route]() # 返回二进制响应体 return [data] 当我对服务端发起请求时，会打印出 env，如下： 1&#123;'PATH': '/Users/jingxing/Virtualenv/py3-env1/bin:/Users/jingxing/.nvm/versions/node/v4.9.1/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/python_study/mongodb/bin://Volumes/python_study/mongodb/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/VMware Fusion.app/Contents/Public:/python_study/Applications/mongodb-osx-x86_64-3.6.3/bin::/usr/local/mysql/bin', 'PS1': '(py3-env1) ', 'VERSIONER_PYTHON_VERSION': '2.7', 'LS_OPTIONS': '--color=auto', 'LOGNAME': 'jingxing', 'XPC_SERVICE_NAME': 'com.jetbrains.pycharm.23248', 'PWD': '/Users/jingxing/django_project/day01', 'PYCHARM_HOSTED': '1', 'NODE_PATH': '/Users/jingxing/.nvm/versions/node/v4.9.1/lib/node_modules', 'PYCHARM_MATPLOTLIB_PORT': '62845', 'PYTHONPATH': '/Users/jingxing/django_project/day01:/Users/jingxing/django_project/day04:/Users/jingxing/django_project/day02:/Users/jingxing/PycharmProjects/youku/youkusecond:/Users/jingxing/django_project/day03:/Applications/PyCharm.app/Contents/helpers/pycharm_matplotlib_backend', 'NVM_CD_FLAGS': '', 'NVM_DIR': '/Users/jingxing/.nvm', 'SHELL': '/bin/bash', 'LSCOLORS': 'CxfxcxdxbxegedabagGxGx', 'PYTHONIOENCODING': 'UTF-8', 'VERSIONER_PYTHON_PREFER_32_BIT': 'no', 'USER': 'jingxing', 'CLICOLOR': 'Yes', 'TMPDIR': '/var/folders/yl/3drd7wf93f90sfkgpc2zg9cr0000gn/T/', 'SSH_AUTH_SOCK': '/private/tmp/com.apple.launchd.ujA3r16JUC/Listeners', 'VIRTUAL_ENV': '/Users/jingxing/Virtualenv/py3-env1', 'XPC_FLAGS': '0x0', 'PYTHONUNBUFFERED': '1', '__CF_USER_TEXT_ENCODING': '0x1F5:0x0:0x0', 'Apple_PubSub_Socket_Render': '/private/tmp/com.apple.launchd.gOrXw3Il2u/Render', 'LC_CTYPE': 'en_US.UTF-8', 'NVM_BIN': '/Users/jingxing/.nvm/versions/node/v4.9.1/bin', 'HOME': '/Users/jingxing', 'SERVER_NAME': 'jingxingdeMacBook-Pro.local', 'GATEWAY_INTERFACE': 'CGI/1.1', 'SERVER_PORT': '8808', 'REMOTE_HOST': '', 'CONTENT_LENGTH': '', 'SCRIPT_NAME': '', 'SERVER_PROTOCOL': 'HTTP/1.1', 'SERVER_SOFTWARE': 'WSGIServer/0.2', 'REQUEST_METHOD': 'GET', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', 'CONTENT_TYPE': 'text/plain', 'HTTP_HOST': '127.0.0.1:8808', 'HTTP_CONNECTION': 'keep-alive', 'HTTP_UPGRADE_INSECURE_REQUESTS': '1', 'HTTP_USER_AGENT': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36', 'HTTP_ACCEPT': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'HTTP_ACCEPT_ENCODING': 'gzip, deflate, br', 'HTTP_ACCEPT_LANGUAGE': 'en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7', 'HTTP_COOKIE': 'csrftoken=YjPgsyb6TW4fen2fxjy6DHzZYFlBU4SsAuE9AVqWRjLIhymeAlukqjVBpL7KTPPH', 'wsgi.input': &lt;_io.BufferedReader name=7&gt;, 'wsgi.errors': &lt;_io.TextIOWrapper name='&lt;stderr&gt;' mode='w' encoding='UTF-8'&gt;, 'wsgi.version': (1, 0), 'wsgi.run_once': False, 'wsgi.url_scheme': 'http', 'wsgi.multithread': True, 'wsgi.multiprocess': False, 'wsgi.file_wrapper': &lt;class 'wsgiref.util.FileWrapper'&gt;&#125; 这些参数值得关注的为： PATH_INFO：路由信息； SERVER_PORT：端口； HTTP_HOST：ip； SERVER_PROTOCOL：服务器端通信协议 可迭代响应在 app 中向客户端返回数据时，写的为 return [data]，如果改为return date，这将会导致 WSGI 程序的响应变慢。原因是字符串date也是可迭代的，它的每一次迭代只能得到 1bytes 的数据量，这也意味着每一次只向客户端发送1bytes 的数据，直到发送完毕为止。所以推荐使用return [data]。这里的数据是怎么返回的目前还不清楚，保留疑问。。。 如果可迭代响应含有多个字符串，那么Content-Length应该是这些字符串长度之和。 解析 GET 请求运行 start.py文件，在浏览器中访问http://localhost:8808/?id=1&amp;name=musibii，可以在响应内容中找到到： 12'QUERY_STRING': 'id=1&amp;name=musibii''REQUEST_METHOD': 'GET' cgi.parse_qs()函数可以很方便的处理 QUERY_STRING，同时需要cgi.escape()处理特殊字符以防止脚本注入，如下： 12345678from cgi import parse_qs, escapeQUERY_STRING = 'id=1&amp;name=musibii'd = parse_qs(QUERY_STRING)print(d.get('id', [''])[0]) # ['']是默认值，如果在QUERY_STRING中没找到则返回默认值print(d.get('name',[]))print(escape('&lt;script&gt;alert(123);&lt;/script&gt;')) 运行结果： 1231['musibii']&amp;lt;script&amp;gt;alert(123);&amp;lt;/script&amp;gt; 处理 GET 请求的动态网页123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from wsgiref.simple_server import make_serverfrom cgi import parse_qs, escape# html中 form 的 method 默认为 get，action 是当前页面html = '''&lt;html&gt;&lt;body&gt; &lt;form method="get" action=""&gt; &lt;p&gt; Age: &lt;input type="text" name="age" value="%(age)s"&gt; &lt;/p&gt; &lt;p&gt; Hobbies: &lt;input name="hobbies" type="checkbox" value="software" %(checked-software)s &gt; Software &lt;input name="hobbies" type="checkbox" value="tunning" %(checked-tunning)s &gt; Auto Tunning &lt;/p&gt; &lt;p&gt; &lt;input type="submit" value="Submit"&gt; &lt;/p&gt; &lt;/form&gt; &lt;p&gt; Age: %(age)s&lt;br&gt; Hobbies: %(hobbies)s &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'''def app(env, response): # 解析QUERY_STRING d = parse_qs(env['QUERY_STRING']) age = d.get('age', [''])[0] # 返回 age 对应的值 hobbies = d.get('hobbies', []) # 以 list 形式返回所有的 hobbies # 防止脚本注入 age = escape(age) hobbies = [escape(hobby) for hobby in hobbies] response_body = html% &#123; 'checked-software': ('', 'checket')['software' in hobbies], 'checked-tunning': ('', 'checked')['tunning' in hobbies], 'age': age or 'Empty', 'hobbies': ','.join(hobbies or ['No Hobbies?']) &#125; status = '200 OK' response_body = [ ('Content-Type', 'text/html'), ('Content-Length', str(len(response_body))) ] start_response(status, response_headers) return [response_body]httpd = make_server('', 8088, app)httpd.serve_forever() 处理 POST 请求的动态网页对于POST 请求，查询字符串是放在 HTTP 请求正文（request body）末尾的，不是显式在 url 中。请求正文在 env 字典变量中键为wsgi.input对应的值中，这是一个类似 file 的变量： 1'wsgi.input': &lt;_io.BufferedReader name=7&gt; 我看源码看晕了还是没找到这个 name 具体是什么意思，经过 google 猜测这个应该是个标识符。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from wsgiref.simple_server import make_serverfrom cgi import parse_qs, escape# html中form的method是posthtml = """&lt;html&gt;&lt;body&gt; &lt;form method="post" action=""&gt; &lt;p&gt; Age: &lt;input type="text" name="age" value="%(age)s"&gt; &lt;/p&gt; &lt;p&gt; Hobbies: &lt;input name="hobbies" type="checkbox" value="software" %(checked-software)s &gt; Software &lt;input name="hobbies" type="checkbox" value="tunning" %(checked-tunning)s &gt; Auto Tunning &lt;/p&gt; &lt;p&gt; &lt;input type="submit" value="Submit"&gt; &lt;/p&gt; &lt;/form&gt; &lt;p&gt; Age: %(age)s&lt;br&gt; Hobbies: %(hobbies)s &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"""def application(environ, start_response): # CONTENT_LENGTH 可能为空，或者没有 try: request_body_size = int(environ.get('CONTENT_LENGTH', 0)) except (ValueError): request_body_size = 0 request_body = environ['wsgi.input'].read(request_body_size) d = parse_qs(request_body) # 获取数据 age = d.get('age', [''])[0] hobbies = d.get('hobbies', []) # 转义，防止脚本注入 age = escape(age) hobbies = [escape(hobby) for hobby in hobbies] response_body = html % &#123; 'checked-software': ('', 'checked')['software' in hobbies], 'checked-tunning': ('', 'checked')['tunning' in hobbies], 'age': age or 'Empty', 'hobbies': ', '.join(hobbies or ['No Hobbies?']) &#125; status = '200 OK' response_headers = [ ('Content-Type', 'text/html'), ('Content-Length', str(len(response_body))) ] start_response(status, response_headers) return [response_body]httpd = make_server('localhost', 8051, application)httpd.serve_forever() 中间件中间件位于 WSGI server 和 WSGI application 之间。所以对客户端来说，中间件扮演服务器；对服务器来说，中间件扮演客户端。在 Django 中wsgi 收到的数据用 request对象表示，要传给客户端的数据用 Httpresponse对象表示。 示例： 123456789101112131415161718192021222324252627282930from wsgiref.simple_server import make_serverdef application(environ, start_response): response_body = 'hello world!' status = '200 OK' response_headers = [ ('Content-Type', 'text/plain'), ('Content-Length', str(len(response_body))) ] start_response(status, response_headers) return [response_body]# 中间件class Upperware: def __init__(self, app): self.wrapped_app = app def __call__(self, environ, start_response): for data in self.wrapped_app(environ, start_response): yield data.upper()wrapped_app = Upperware(application)httpd = make_server('localhost', 8051, wrapped_app)httpd.serve_forever()]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django（四）]]></title>
    <url>%2F2019%2F01%2F07%2FDjango%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django 系列博客（四）前言本篇博客介绍 django 如何和数据库进行交互并且通过 model 进行数据的增删查改 ORM简介ORM全称是：Object Relational Mapping(对象关系映射)，其主要作用是在编程中，把面向对象的概念跟数据库中表的概念对应起来。举例来说就是，我定义一个对象，那就对应着一张表，这个对象的实例，就对应着表中的一条记录。 比如在大名鼎鼎的 pythonWEB 框架 Django 就是使用了对象关系映射，这个对应 Django 中的 model文件。 12345678from django.db import models# Create your models here.class UserInfo(models.Model): id = models.AutoField(primary_key=True) name = models.CharField(max_length=32) pwd = models.CharField(max_length=32) 通过对象关系映射，这个类就会对应数据库中的 UserInfo 表，里面有三个字段，id 为自增并且为主键，另外两个为 name 和 pwd 字段，都是可变长类型。 通过 orm 和数据库进行交互进行增删查改，获取的数据会在 views 文件中来进行逻辑判断。 数据返回当前后端进行交互后需要往前端传送数据，在 Django 中有三种方式： render：返回一个模板（页面） 该函数有五个参数： request：这是前端发过来的数据集合，里面可以获取表单中的数据，或者获取请求方式、状态码等； template_name：这个是模板名称，模板为 templates 中的 index 文件； context：内容，需要返回的数据，默认为 None； content_type：数据内容类型，默认为 None； using：未知。 当调用这个函数时，会找到模板文件，打开，如果 context 不为空的话，就会用 django 的模板渲染方式将数据加到模板中，然后返回给前端。 content为经过loader.render_to_string加工后的数据，然后经过 HttpResponse 类的实例化生成一个对象返回给前端，那么在前端可以通过对象的点语法进行取值。 redirect：重定向到某个地址 查看源码可知，首先在 redirect 函数中进行了判断，假设该函数没有参数，只有一个重定向路径，也就是 to 这个参数，那么 redirect_class为 HttpResponseRedirect 类，然后进行实例化返回。 查看 resolve_rul源码，在里面对 to 变量进行了一些判断等工作然后再返回，返回之后经过 redirect_class类（在这里也就是 HTTPResponseRedirect）进行实例化， 查看源码： 发现状态码为302，然后进入 HTTPResponseRedirectBase，查看源码： 经过 HTTPResponseRedirect 实例化得对象返回到前端。 HttpResponse：返回字符串。 这个类也是 render 和 redirect 需要调用的类来实例化对象。不过直接由 HttpResponse 类生成的对象是字符串，没有页面显示。 ORM 连接数据库ORM 连接 sqlite3 配置 settings 文件 其实不用配置，默认就是连接 sqlite3 在 settings 里面有个数据库配置选项： 12345DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125; 可以知道 django 默认的数据库引擎为 sqlite3，数据库名字为数据库的路径。连接数据分为两步： 在 models 中创建类和字段 12345678from django.db import models# Create your models here.class UserInfo(models.Model): id = models.AutoField(primary_key=True) name = models.CharField(max_length=32) pwd = models.CharField(max_length=32) 把表同步到数据库（因为 orm 不能创建表，所以需要手动创建一个对应的数据库）。创建完成后在项目根目录下运行两条命令。 python3 manage.py makemigrations 这条命令并没有将 models 中的表同步到数据库，只是在 migrations 中做了一个记录，并且会在 migrations 文件夹中生成一个0001_initial.py文件 123456789101112131415161718192021222324# -*- coding: utf-8 -*-# Generated by Django 1.11.9 on 2019-01-07 06:59from __future__ import unicode_literalsfrom django.db import migrations, modelsclass Migration(migrations.Migration): initial = True dependencies = [ ] operations = [ migrations.CreateModel( name='UserInfo', fields=[ ('id', models.AutoField(primary_key=True, serialize=False)), ('name', models.CharField(max_length=32)), ('pwd', models.CharField(max_length=32)), ], ), ] python3 manage.py migrate 将数据表同步到数据库中 经过这两步会在数据库中创建出来一些表： 这些表都是什么意思呢？ 第一张表app_userinfo为 models 中创建的类所对应的表（mysql 不区分大小写），并且会自动将 app 的名字拼接到表名之前，之后 auth 开头的表示关于认证的表，django 开头的表示 django 认证的表，目前来说不用关心。 ORM 连接Mysql连接 mysql 也很简单，比连接 sqlite3多了两步，并且这两步是在之前就要进行的。 配置 settings 文件 因为是连接 mysql，所以 settings 中的数据库需要更改配置。 12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'django_03', 'HOST': '127.0.0.1', 'PORT': 3306, 'USER': 'root', 'PASSWORD': 'password' &#125;&#125; 注意：default 对应的value 中的 key 必须使用大写，其他除了 ENGINE 一样外，其他的参数都需要根据自身的数据库来配置。配置成功后可以通过 pycharm 自带的数据库模块来进行测试是否连接成功： 连接成功会显示 successful。 配置 app 下的 init 文件，不要写错地方了 123import pymysqlpymysql.install_as_MySQLdb() 在 models 中创建类和字段 和 sqlite3的一样， 12345678from django.db import models# Create your models here.class UserInfo(models.Model): id = models.AutoField(primary_key=True) name = models.CharField(max_length=32) pwd = models.CharField(max_length=32) 把表同步到数据库 1234#数据库表并没有同步到数据库，只是在migrations内做了一个记录-python3 manage.py makemigrations#才将数据表同步到数据库-python3 mangae.py migrate 使用 orm 进行增删查改和数据库连接成功后，可以通过表所对应的对象来进行操作，在本文的数据库对象就是UserInfo.object，打印出来可知该对象是app.UserInfo.objects类 通过这个这个类（对应数据库中的表）可以操作数据库 增1234# 该表有两个三个字段，其中 id 是自增可以不用传值name = 'musibii'pwd = '123'UserInfo.objects.create(name=name, pwd=pwd) 删12# 比如 id 为1，想要删除一个数据首先需要根据 id 获取数据UserInfo.objects.filter(id=1).delete() 查查一个12ret = UserInfo.object.filter(id=1).first()print(ret) 查多个1ret = UserInfo.objects.all() 改123name = 'maffia'pwd = 'abc'ret = UserInfo.objects.filter(id=1).update(name=name, pwd=pwd)]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django（三）]]></title>
    <url>%2F2019%2F01%2F05%2FDjango%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django 系列博客（三）前言本篇博客介绍 django 的前后端交互及如何处理 get 请求和 post 请求。 get 请求get请求是单纯的请求一个页面资源，一般不建议进行账号信息的传输。 配置路由1234567891011121314from django.conf.urls import urlfrom django.contrib import adminimport app.views as app_viewsimport newApp.views as new_viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^$', app_views.home), # 路由采用正则匹配, ^以什么开头 $以什么结果 # 注: 当路由没有子路由是,才在末尾添加$ url(r'^index/$', app_views.index), url(r'login', app_views.login_action), url(r'^new/index/$', new_views.index)] 配置视图12345678910111213141516171819202122from django.shortcuts import render, redirectfrom django.http import HttpResponse# Create your views here.# 每一个请求,都对应一个视图响应函数,来出现请求,完成响应# def index(abc):# return HttpResponse('hello django') # 第一个响应import django.core.handlers.wsgidef login_action(request): return render(request, 'login.html') # 第一个响应页面# def home(request):# return redirect('/index/') # 第一个重定向def home(request): return render(request, 'index.html')def index(request): return redirect('/') 配置页面资源12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 style="text-align: center"&gt;app的主页&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 style="color: red"&gt;登录&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; post 请求配置路由1234567891011from django.conf.urls import urlfrom django.contrib import adminfrom app import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^$', views.home), url(r'^index/$', views.index), url(r'^login/$', views.login, name='lg'),] 配置视图12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from django.shortcuts import render, redirectimport pymysql# Create your views here.def home(request): return render(request, 'index.html')def index(request): return redirect('/')'''def login(request): print(request.method) # 如果获取GET请求的提交数据 # import django.core.handlers.wsgi # print(type(request)) # import django.http.request.QueryDict # print(type(request.GET)) print(request.GET) # usr = request.GET['usr'] # 不安全 usr = request.GET.get('usr', 'USR') # 安全, 第一个参数为数据的key, 第二个参数为默认值 print(usr) pwd = request.GET.get('pwd') # 不设默认值,没有取到值时,返回值为None print(pwd) return render(request, 'login.html')'''from django.http import HttpResponsedef login(request): if request.method == 'GET': stus = request.GET.getlist('stu') print(stus) return render(request, 'login.html') # 没有GET分支, 发来的请求为POST usr = request.POST.get('usr') pwd = request.POST.get('pwd') print(usr, pwd) # 连接数据库 =&gt; ORM conn = pymysql.connect(host='localhost', port=3306, user='root', password='root', db='django') cur = conn.cursor(pymysql.cursors.DictCursor) # cur.execute('select * from user') # users = cur.fetchall() cur.execute('select * from user where usr=%s and pwd=%s', [usr, pwd]) res = cur.fetchone() print(res) if res != None: return HttpResponse('登录成功') return HttpResponse('登录失败') 配置页面资源123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;主页&lt;/title&gt;&#123;# &lt;link rel="stylesheet" href="./index.css"&gt;#&#125;&#123;# &lt;link rel="stylesheet" href="/static/index.css"&gt;#&#125;&#123;# &lt;link rel="stylesheet" href="/static/temp.css"&gt;#&#125;&#123;# &lt;link rel="stylesheet" href="/ooo/index.css"&gt;#&#125;&#123;# &lt;link rel="stylesheet" href="/ooo/temp.css"&gt;#&#125;&#123;# &lt;link rel="stylesheet" href="/static/css/test.css"&gt;#&#125; &lt;link rel="stylesheet" href="/static/css/index.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 style="text-align: center"&gt;主页&lt;/h1&gt; &lt;img src="/static/img/001.png" alt=""&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel="stylesheet" href="/static/bootstrap-3.3.7-dist/css/bootstrap.css"&gt; &lt;style&gt; .box &#123; border: 1px solid #ccc; padding: 20px; border-radius: 20px; height: 380px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&#123;#&lt;button class="btn btn-warning"&gt; 按钮&lt;/button&gt;#&#125;&#123;#&lt;div class="btn-group"&gt;#&#125;&#123;# &lt;button class="btn btn-default btn-lg dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true"#&#125;&#123;# aria-expanded="false"&gt;#&#125;&#123;# Large button &lt;span class="caret"&gt;&lt;/span&gt;#&#125;&#123;# &lt;/button&gt;#&#125;&#123;# &lt;ul class="dropdown-menu"&gt;#&#125;&#123;# &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt;#&#125;&#123;# &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt;#&#125;&#123;# &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt;#&#125;&#123;# &lt;li role="separator" class="divider"&gt;&lt;/li&gt;#&#125;&#123;# &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt;#&#125;&#123;# &lt;/ul&gt;#&#125;&#123;#&lt;/div&gt;#&#125;&lt;div class="container"&gt; &lt;div class="box row col-sm-6 col-sm-offset-3"&gt; &#123;# action: 没写 | http://localhost:8801/login | /login/ | &#123;% url 'url_name' %&#125; #&#125; &lt;form action="&#123;% url 'lg' %&#125;" method="GET"&gt;&#123;# &#123;% csrf_token %&#125;#&#125; &lt;div class="form-group"&gt; &lt;label for="usr"&gt;用户名:&lt;/label&gt; &lt;input type="text" class="form-control" name="usr" id="usr" placeholder="请输入用户名"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="pwd"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" name="pwd" id="pwd" placeholder="请输入密码"&gt; &lt;/div&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input name="stu" type="checkbox" value="stu1"&gt; 学生1 &lt;/label&gt; &lt;label&gt; &lt;input name="stu" type="checkbox" value="stu2"&gt; 学生2 &lt;/label&gt; &lt;label&gt; &lt;input name="stu" type="checkbox" value="stu3"&gt; 学生3 &lt;/label&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-info pull-right"&gt;登录&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&#123;#&lt;a href="/index/"&gt;前往主页&lt;/a&gt;#&#125;&lt;/body&gt;&lt;script src="/static/bootstrap-3.3.7-dist/js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;script src="/static/bootstrap-3.3.7-dist/js/bootstrap.js"&gt;&lt;/script&gt;&lt;/html&gt; 前后端交互Django请求生命周期]]></content>
      <categories>
        <category>django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django（二）]]></title>
    <url>%2F2019%2F01%2F04%2FDjango%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django 系列博客（二）前言今天博客的内容为使用 Django 完成第一个 Django 页面，并进行一些简单页面的搭建和转跳。 命令行搭建 Django 项目创建纯净虚拟环境在上一篇博客中已经安装好了虚拟环境，所以用虚拟环境来安装指定版本的 Django。为了可以从头到尾的走一遍流程，我重新创建了一个虚拟环境。 激活虚拟环境并安装 Django 首先进入虚拟环境路径下的 bin 目录 使用命令激活虚拟环境 安装指定版本 Django 首先使用 pip3 list 命令查看 可以看到都是创建虚拟环境时安装的依赖包，现在使用 pip 命令安装指定 django 版本，因为做项目需要稳定，所以安装的版本不是最新的。 可以看到新安装了2个包，pytz 是 python time zone 的缩写，是用来转换时区的包。 创建项目前往目标路径创建项目，在这里我的 django 项目都在我的家目录下面的 django_project里面。 进入要创建项目的路径下，使用下面的命令创建一个 django 项目。 1django-admin startproject project_name 可以看到多了个文件夹。查看项目结构 创建应用进入项目根目录使用下面命令创建一个 app。 1python3 manage.py startapp app_name 创建成功并查看项目结构。 启动项目使用下面命令 1python3 manage.py runserver 127.0.0.1:8888 成功后会在本机上的8888端口开启 django 服务 访问8888端口会显示下图页面 好了，到现在你已经开启了第一个 django 服务，并且还是使用了命令行。 pycharm 创建 Django 项目其实会使用命令行创建项目那么使用 pycharm 应该是手到擒来，毕竟 pycharm 已经做了很多工作了。不过也有点麻烦。。。 在虚拟环境下使用 pycharm 安装指定django 版本 创建项目 项目目录结构及作用1234567项目目录：包含项目最基本的一些配置 -- __init__.py：模块的配置文件，将blog_proj文件夹变成了模块 -- settings.py：配置总文件 -- urls.py：url配置文件，django项目中的所有页面都需要对其配置url地址 -- wsgi.py：(web server gateway interface)，服务器网关接口，python应用与web服务器直接通信的接口templates：模板文件夹，存放html文件的(页面)，支持使用Django模板语言(DTL)，也可以使用第三方(jinja2)manage.py：项目管理器，与项目交互的命令行工具集的入口，查看支持的所有命令python3 manage.py settings.py结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import os# 项目根目录BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))# 项目安全码SECRET_KEY = 'guwba1u$18=&amp;*8kf44_u&amp;swqb@xlwgel7n$0rs=(+f10yvz)p0'# 调试模式，上线项目要关闭debug模式，不然后台出现异常会直接抛给前台展现给用户看了DEBUG = True# 在上线项目中，规定只能以什么ip地址来访问django项目# DEBUG = FALSE# ALLOWED_HOSTS = ['localhost']ALLOWED_HOSTS = []# 项目自带的应用# 我们创建了自己的应用就要将自定义应用添加到该配置INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',]# 中间件# django自带的工具集MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]# 配置url配件文件的根文件，执行urls.pyROOT_URLCONF = '项目目录.urls'# 模板，一个个html文件TEMPLATES = [ &#123; # 如果使用第三方，可以在这个地方修改模板引擎 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')] , 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,]# 服务器网关接口应用WSGI_APPLICATION = '项目目录.wsgi.application'# 数据库配置# 要配置自定义数据库去下面链接去查询详细配置# https://docs.djangoproject.com/en/1.11/ref/settings/#databasesDATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125;# 密码认证配置# https://docs.djangoproject.com/en/1.11/ref/settings/#auth-password-validatorsAUTH_PASSWORD_VALIDATORS = [ &#123; 'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator', &#125;, &#123; 'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator', &#125;,]# 国际化相关配置# https://docs.djangoproject.com/en/1.11/topics/i18n/LANGUAGE_CODE = 'en-us'TIME_ZONE = 'UTC'USE_I18N = TrueUSE_L10N = TrueUSE_TZ = True# 静态文件地址 (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/1.11/howto/static-files/STATIC_URL = '/static/' 创建项目应用使用 pycharm 自带的命令行工具来创建应用 应用创建完后将应用名添加到 settings.py文件中 1234567INSTALLED_APPS = [ 'django.contrib.admin', ... 'django.contrib.staticfiles', # 添加的自定义应用 'app',] app目录结构创建后的 app 目录结构和使用命令行创建的一样，下面来看看具体都有什么作用 12345678migrations：数据迁移(移植)模块，内容都是由Django自动生成 -- __init__.py__init__.pyadmin.py：应用的后台管理系统配置apps.py：django 1.9后，本应用的相关配置models.py：数据模型模块，使用ORM框架，类似于MVC模式下的Model层tests.py：自动化测试模块，可以写自动化测试脚本views.py：执行相应的逻辑代码模块(相应什么，如何相应)，代码逻辑处理的主要地点，项目的大部分代码所在位置 页面响应第一个响应通过配置路由和视图文件来响应第一次连接请求。 配置路由123456789101112from django.conf.urls import urlfrom django.contrib import admin# 导入应用视图import app.views as app_view # 取别名# 配置路由urlpatterns = [ url(r'^admin/', admin.site.urls), # 为指定函数配置 url url(r'^index/&amp;', app_view.index)] 配置视图1234567# 导入处理请求的 http 相应功能from django.http import HttpResponse# django中每一个请求都会设置相应函数来进行处理# 函数的参数约定为 requestdef index(request): return HttpResponse('index page!') 启动服务启动服务后访问 localhost:8000/index/，可以看到响应为 index 函数里填写的响应，说明服务成功启动并且响应了自己想要的响应字符串。 第一个模板页面项目目录下有个 templates 文件夹是专门用于存放页面资源的，比如index.html 12345from django.shortcuts import renderdef index(request): # 参数：请求对象 request，模板 html 文件，传给前台的资源 return render(request, 'index.html') index.html 文件 12345678910 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是主页&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 配置完成后，访问127.0.0.1:8000/index/后显示为： 在 views.py文件中编写对应响应功能函数时，会自动出现模板文件 这是因为在 settings.py文件中已经把模板路径配置好了 123456789101112TEMPLATES = [ &#123; # 如果使用第三方，可以在这个地方修改模板引擎 'BACKEND': 'django.template.backends.django.DjangoTemplates', # 模板页面默认路径：项目根路径下的templates文件夹 'DIRS': [os.path.join(BASE_DIR, 'templates')] , # 允许所有app均拥有自己的模板文件夹 'APP_DIRS': True, ... &#125;,] 第一个重定向和上面的一样，首先在 views.py文件中配置响应函数 1234567from django.shortcuts import render, redirect# / 路径渲染index.html页面def home(request): return render(request, 'index.html')# /index/ 路径重定向到 / 路径，达到渲染index.html页面def index(request): return redirect('/') 响应的路由配置为 123456789from django.conf.urls import urlfrom django.contrib import admin# 导入应用视图import app.views as app_viewurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/$', app_view.index), url(r'^$', app_view.home),] 状态码显示为301说明发生了转跳，查看网络详细信息发现在index/中有个 location 字段， 该字段值为 /，说明转跳到了根目录下。 其他配置url应用移植项目目录下的urls.py文件123456789# 导入include功能，将url配置转移到指定应用内部的自身url配置文件from django.conf.urls import url, includefrom django.contrib import adminurlpatterns = [ url(r'^admin/', admin.site.urls), # 将url配置操作交给app_test自身的urls.py来进行操作 # app-test/为app_test应用的总路径 url(r'^app-test/', include('app_test.urls')),] app_test下的urls.py文件123456789from django.conf.urls import urlfrom . import viewsurlpatterns = [ # 1.不要直接留空，直接留空 http://localhost:8000/app-test/* 均可以访问 # 2.如果要配置index，访问的地址为 http://localhost:8000/app-test/index # 3.配置方式：r'^index/$'，不要省略 / 符号 # 4.正则是否以$标识结尾取决于该路径是否会有下一级路径 url(r'^$', views.index),] 多应用相同模板页面冲突如果在两个应用中均有相同的模板页面假如为index.html 123456# 1.在应用templates文件夹下建立与应用同名的文件夹，eg：app_text下就建立app_text# 2.将模板创建在与应用同名的模板文件夹下# 3.修改指定应用下views.py处理请求的render模板指向def index(request): # 模板指向：blog_app应用的templates下的blog_app文件夹中的index.html return render(request, 'app_text/index.html') 静态资源的配置假如页面需要一些静态资源，比如需要 css 样式、js 文件等，那么就需要在 settings 文件中配置好静态文件的路径。 配置 settings.py文件123456789# 静态文件地址 (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/1.11/howto/static-files/STATIC_URL = '/static/'# 在项目根目录下新建static文件夹，静态资源均放在该文件夹中# 增加STATICFILES_DIRS配置STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static')]# 前端页面加载静态资源的路径：/static/... (...为具体在static文件夹中的路径) 拓展静态资源配置1234567# 如果要将项目根目录下source文件夹也作为静态资源路径# STATICFILES_DIRS增加source配置STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'), os.path.join(BASE_DIR, 'source')]# 前端页面加载静态资源路径依旧不变，Django会自动索引：/static/... (...为具体在source文件夹中的路径) url正则原生字符串123456789# urls.py配置路由url(r'test', app_view.test)# views.py设置响应函数def test(request): return HttpResponse('test')# 问题：请求地址包含test均可以访问# http://127.0.0.1:8000/test =&gt; /test | /atest | /testa | /atesta | /test/a | /test/ 开头123456789# urls.py配置路由url(r'^test', app_view.test)# views.py设置响应函数def test(request): return HttpResponse('test')# 问题：请求地址以test开头均可以访问# http://127.0.0.1:8000/test =&gt; /test | /testa | /test/a | /test/ 结尾1234567891011# urls.py配置路由url(r'^test$', app_view.test)# views.py设置响应函数def test(request): return HttpResponse('test')# 问题：只能一种方式访问# http://127.0.0.1:8000/test =&gt; /test# 不能以 /test/ 访问# http://127.0.0.1:8000/test/ 优化结尾1234567891011121314# urls.py配置路由url(r'^test/$', app_view.test)# views.py设置响应函数def test(request): return HttpResponse('test')# /test 和 /test/ 均可以访问# http://127.0.0.1:8000/test# http://127.0.0.1:8000/test/# 问题：不能作为应用总路由# eg：app_test应用在项目urls.py# url(r'^app-test/', include('app_test.urls')) 末尾不能加$，因为作为应用总目录，是有下一级，如果用$标识结尾了，就代表不能有下一级路由 地址捕获1234567891011# urls.py配置路由url(r'^test/(\d+)/\d+/(\d+)/$', app_view.test)# 对应请求路径# http://127.0.0.1:8000/test/1/22/333/# 对应响应函数def test(request, arg1, arg2): # arg1: str 1 # arg2: str 333 return HttpResponse('test') 小结123456789101112131415# 常规路由配置# r'^index/$'# r'^page/2/$'# 应用路由配置# r'^app/'# 根路由配置# r'^$'# 路由配置均以 / 结尾# ()中的字段会被请求响应函数捕获# 限制响应函数捕获的变量名# (?P&lt;num&gt;[0-9]+) 响应函数参数(requset, num)]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django（一）]]></title>
    <url>%2F2019%2F01%2F03%2FDjango%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django 系列博客（一）前言学习了 python 这么久，终于到了Django 框架。这可以说是 python 名气最大的web 框架了，那么从今天开始会开始从 Django框架的安装到使用一步步的学习，这系列博客不会像前端的那样水了（立个 flag），希望可以成为高质量的博客。那么本篇博客介绍 Django 的安装以及如何在电脑上运行第一个 Django 应用。 Django 的安装Django 的安装很简单，在 win 和 mac 上面都可以使用 pip 安装命令安装，也可以通过 pycharm 安装，或者下载文件在命令行使用安装工具安装。 接下来我在 ubuntu 上安装做示例。 在这里还安装了一个依赖包 pytz。这是用来做时区转换的一个第三方库。 其他平台的 pip 安装方式一样，不过要选用 python3的对应 pip 来安装，因为现在的 Django 版本已经不支持 python2了。 虚拟环境的安装什么是虚拟环境 对真实的 python 解释器的一个拷贝版本 事实有效，可以独立存在并运行解释 python 代码 可以在计算机上拷贝多个虚拟环境 为什么要使用虚拟环境 保证真实环境的纯净性 框架的多版本共存 方便做框架的版本迭代 降低多框架共存的维护成本 安装虚拟环境 通过 pip 安装虚拟环境库 因为我之前已经下载好了，所以这里直接显示请求已经完成，并且后面是安装的绝对路径。 前往目标文件夹 这个文件夹是你用来保存虚拟环境的文件夹，该文件夹一旦确定就不要轻易更改。 这个 py3-env1是创建的一个纯净虚拟环境。 创建纯净的虚拟环境 1virtualenv 虚拟环境名 (py3-env2) 终端启动虚拟环境 12cd py3-env1\Scriptsactivate 进入虚拟环境下的 python 开发环境 1python3 关闭虚拟环境 1deactivate Pycharm的开发配置 12添加：创建项目 -&gt; Project Interpreter -&gt; Existing interpreter -&gt; Virtualenv Environment | System Interpreter -&gt; 目标路径下的 python.exe删除：Setting -&gt; Project -&gt; Project Interpreter -&gt; Show All mac 电脑从第三步直接到最后一步就好 了解12# 创建非纯净环境：# -- virtualenv-clone 本地环境 虚拟环境名 1234# Mac配置终端，在终端运行虚拟环境# 在用户根目录下的.bash_profile（没有需手动创建）文件中设置# alias 终端指令名(env-py3)='/Library/Virtualenv/虚拟环境名/bin/python3'# alias 终端指令名(env-pip3)='/Library/Virtualenv/虚拟环境名/bin/pip3' HTTP 协议因为 Django 框架应用层是采用的 HTTP 协议，所以有必要了解 HTTP 协议。 什么是 HTTP 协议 HTTP（HyperText Transport Protocol） 是超文本传输协议，而 HTTPS 也归属于 HTTP 协议，S 代表安全。 基于 TCP/IP协议基础上的应用层协议，底层实现仍为 socket 基于请求-响应模式：通信一定是从客户端开始，服务端接收到客户端一定会做出对应响应 无状态：协议不对任何一次通信状态和任何数据做保存 无连接：一次连接只完成一次请求-响应，请求-响应完毕后会立即断开连接。 HTTP 工作原理一次 HTTP 连接称之为一个事务，过程可以分为四步 客户端与服务端建立连接 客户端发生一个 HTTP 协议指定格式的请求 服务端接收请求后，回应一个 HTTP 协议指定格式的响应 客户端将服务端的响应展现给用户 HTTP 状态码 1开头： 2开头： 3开头： 4开头： 5开头： 请求报文12345678910111213# 请求行 请求头 请求体'''POST / HTTP/1.1\r\nHost: 127.0.0.1:8001\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\nAccept-Encoding: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\n\r\nusr=abc&amp;pwd=123''' 响应报文1234567# 响应行 响应头 响应体'''HTTP/1.1 200 OK\r\nContent-type:text/html\r\n\r\nLogin Success''' 使用原生 socket 完成和浏览器的交互目录结构1234501_socket -- 01_client.html：前台通过form表单访问后台的页面 -- 01_login.html：后台测试渲染给前台的登录页面 -- 01_index.html：后台测试渲染给前台的主页 -- 01_server.py：后台服务器文件 因为 B/S架构的客户端已经由浏览器写好，所以只需要关注服务器端就ok。 服务器端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from socket import socket# 设置响应头(包含响应行)RESP_HEADER = b'HTTP/1.1 200 OK\r\nContent-type:text/html;charset=utf-8\r\n\r\n' # 连续两个\r\n表示响应头结束# 设置服务器 socket 相关信息server = socket()server.bind('', 8080) # 空字符串表示绑定本机server.listen(5)print(('服务：http://localhost:8080'))while True: # 获取Browser以 http 协议发来的请求 client, addr = server.accept() data = client.recv(1024) # 数据报文 包含请求行 请求头 请求体 print(data) client.send(RESP_HEADER) # /index =&gt; 响应主页 # /login =&gt; 登录页面 # 错误 =&gt; 404 # 数据 data, 字节形式 =&gt; 字符串形式 strData = str(data, encodeing) # 解析请求的数据，分析得到路由 my_route = strData.split('\r\n')[0].split(' ')[1] # 后台没有设置的路由，统统由404来处理 dt = b'404' # 设置的路由返回响应的页面文件 if my_route == '/index': with open('index 页面路径', 'rb') as f: dt = f.read() if my_route == '/login': with open('login 页面路径', 'rb') as f: dt = f.read() # /favicon.ico该请求是往后台请求标签图标 if my_route == '/favicon.ico': with open('favicon.ico', 'rb') as f: dt = f.read() # 服务器发送响应体 client.send(dt) # 一次循环，代表一次响应，也就是一次事务的完成，要关闭 http 请求连接 client.close() 修改返回数据，完善响应体1234# 字符串client.send(b'HTTP/1.1 200 OK\r\n')client.send(b'\r\n')client.send(b'Normal Socket Web') 12345# html代码，请求头要设置支持 html 代码client.send(b'HTTP/1.1 200 OK\r\n')client.send(b'Content-type:text/html\r\n')client.send(b'\r\n')client.send(b'&lt;h1&gt;Normal Socket Web&lt;/h1&gt;') 12345678# html文件（同级目录建立一个index.html页面）client.send(b'HTTP/1.1 200 OK\r\n')client.send(b'Content-type:text/html\r\n')client.send(b'\r\n')# 利用文件方式读取页面with open('01_index.html', 'rb') as f: dt = f.read()client.send(dt) 拓展修改接收数据，模拟后台路由 12345678910111213141516# 分析接收到的数据data = client.recv(1024)# 保证接收到的数据作为字符串进行以下处理data = str(data, encoding='utf-8')# 拆分出地址位route = data.split('\r\n')[0].split(' ')[1]# 匹配地址，做出不同的响应if route == '/index': with open('01_index.html', 'rb') as f: dt = f.read()elif route == '/login': with open('01_login.html', 'rb') as f: dt = f.read()else: dt = b'404'client.send(dt) 框架演变目录结构123402_frame -- favicon.ico -- index.html -- manage.py manage.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import socketimport pymysql# 响应头RESP_HEADER = b'HTTP/1.1 200 OK\r\nContent-type:text/html\r\n\r\n'# 请求处理def index(): # 以字节方式读取文件 with open('index.html', 'rb') as f: dt = f.read() return dtdef ico(): with open('favicon.ico', 'rb') as f: dt = f.read() return dtdef user(): # 数据库操作 conn = pymysql.connect(host='127.0.0.1', port=3306, db='django', user='root', password='root') cur = conn.cursor(pymysql.cursors.DictCursor) cur.execute('select * from user') users = cur.fetchall() print(users) users = '''%d:%s %d:%s''' % (users[0]['id'], users[0]['name'], users[1]['id'], users[1]['name']) return users.encode('utf-8')# 设置路由urls = &#123; # 请求路径与请求处理函数一一对应 '/index': index, '/favicon.ico': ico, '/user': user&#125;# 设置socketdef serve(host, port): server = socket.socket() server.bind((host, port)) print('start:http://' + host + ':' + str(port)) server.listen(5) while True: sock, addr = server.accept() data = sock.recv(1024) data = str(data, encoding='utf-8') print(data) route = data.split('\r\n')[0].split(' ')[1] resp = b'404' if route in urls: resp = urls[route]() sock.send(RESP_HEADER) sock.send(resp) sock.close()# 启服务if __name__ == '__main__': serve('127.0.0.1', 8002) 项目演变目录结构1234567803_proj -- template -- index.html -- user.html favicon.ico start.py urls.py views.py index.html1&lt;h1&gt;&#123;&#123; name &#125;&#125;&lt;/h1&gt; user.html1234567891011121314&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;password&lt;/th&gt; &lt;/tr&gt; &#123;% for user in users%&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;user.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;user.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;user.password&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125;&lt;/table&gt; start.py123456789101112131415161718192021from wsgiref.simple_server import make_serverfrom urls import urlsdef app(env, response): print(env) # 设置响应头 response("200 OK", [('Content-type', 'text/html')]) route = env['PATH_INFO'] print(route) data = urls['error']() if route in urls: data = urls[route]() # 返回二进制响应体 return [data]if __name__ == '__main__': server = make_server('127.0.0.1', 8003, app) print('start:http://127.0.0.1:8003') server.serve_forever() urls.py1234567from views import *urls = &#123; '/index': index, '/favicon.ico': ico, '/user': user, 'error': error&#125; views.py123456789101112131415161718192021222324252627282930313233import pymysql# 利用jinja2来渲染模板，将后台数据传给前台from jinja2 import Templatedef index(): with open('templates/index.html', 'r') as f: dt = f.read() tem = Template(dt) resp = tem.render(name='主页') return resp.encode('utf-8')def ico(): with open('favicon.ico', 'rb') as f: dt = f.read() return dtdef user(): # 数据库操作 conn = pymysql.connect(host='127.0.0.1', port=3306, db='django', user='root', password='root') cur = conn.cursor(pymysql.cursors.DictCursor) cur.execute('select * from user') users = cur.fetchall() print(users) with open('templates/user.html', 'r') as f: dt = f.read() tem = Template(dt) resp = tem.render(users=users) return resp.encode('utf-8')def error(): return b'404']]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jQuery（一）]]></title>
    <url>%2F2018%2F12%2F30%2FjQuery%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[jQuery 系列博客（一）前言]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript（八）]]></title>
    <url>%2F2018%2F12%2F30%2FJavaScript%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JavaScript 系列博客（八）前言本篇博客介绍页面节点概念、文档结构以及如何使用 js 操作文档节点还有事件 target 以及 BOM 操作。 节点 dom与dom属性 12// DOM: 文档对象模型 =&gt; 提高给用户操作document obj的标准接口// DOM树: 以document为根, 树状展开所有子节点 节点分类 12// 节点分类: 6个// document | doctype | element | text | attr | comment 节点常规操作 123456var info_node = document.createAttribute("info"); // 创建console.log(info_node.nodeName);console.log(info_node.nodeType);info_node.value = '123'; // 设置console.log(info_node.nodeValue);sup1.setAttributeNode(info_node); // 添加 文档结构(element元素范围)1234567891011121314// 父级console.log(sup.parentElement)// 子级们console.log(sup.children);// 第一个子级console.log(sup.firstElementChild);// 最后一个子级console.log(sup.lastElementChild);// 上兄弟console.log(sup.previousElementSibling);// 下兄弟console.log(sup.nextElementSibling);// 注: 文档结构操作是可以采用连.语法// sup.children[0].parentElement // 自己 文档元素节点操作1234// 操作步骤// 1. 创建div(元素节点)// 2. 设置div属性(单一css | css类名 | 文本 | 子标签 | 事件 | ...)// 3. 添加到(文档结构中)指定位置 123456789101112// 创建:只能由document调用var box = document.createElement('div');// 在body元素的最后追加一个子元素body.appendChild(box);// 在body元素oldEle之前插入一个子元素body.insertBefore(box, oldEle);// 从body中删除box元素,可以接受返回值,就是删除的元素var res = body.removeChild(div);// 将body中oldEle元素替换为box,可以接受返回值,就是被替换的元素res = bodyreplaceChild(box, oldEle);// true深拷贝,拷贝自身与内容, false浅拷贝,只拷贝自身标签box.cloneNode() 事件对象target属性12345// ev.target通过父级的事件对象,获取具体相应区域位置的子级元素// 应用场景// 1. 父级的子元素类型不同一,采用循环绑定不方便// 2. 父级子元素较多或不确定 BOM操作1234// BOM: Browser Object Model, 提供用户与浏览器交互的标准接口// BOM的顶级对象为window对象, 页面中出现的其实所有对象都是window的子对象// 重要的子对象// document | history | location | navigator | screen 12345678910// location =&gt; url信息console.log(location);// 域名:端口号console.log(location.host);// 域名console.log(location.hostname);// 端口号console.log(location.port);// 查询信息console.log(location.search); 12// historyhistory.back() | history.forward() | history.go(-num | num) 123// navigatorconsole.log(navigator.userAgent)// Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36]]></content>
      <categories>
        <category>JavaStript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript（七）]]></title>
    <url>%2F2018%2F12%2F30%2FJavaScript%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JavaScript 系列博客（七）前言本篇博客介绍 js 操作高级，通过 js 获取标签的全局属性、设置标签的全局属性，以及事件的绑定与取消、js 盒模型与 js 动画。 对象使用的高级 对象的key为字符串类型, value为任意类型 1234567var obj = &#123; name: "name", "person-age": 18&#125;// 访问obj.name | obj["name"]obj["person-age"] 对象的属性可以任意添加与删除 12345678var obj = &#123; name: "obj"&#125;// 删除delete obj.name// 添加obj.age = 18 // 如果age的key已存在就是修改值, 不存在就是添加键值对, 添加的key任意// 注: 获取的页面元素(标签对象)也可以任意添加/删除属性 页面标签全局属性操作123456ele.getAttribute("alert");// 获取页面标签ele的alert全局属性的值, 如果没有该全局属性值为nullele.setAttribute("attr_key", "attr_value");// 页面标签ele已有该全局属性,就是修改值, 没有就是添加该全局属性并赋相应值// 注: 一般应用场景, 结合css的属性选择器完成样式修改 事件 事件的绑定 1234567891011// 第一种box.onclick = function()&#123;&#125;// 只能绑定一个实现体, 如果有多次绑定, 保留最后一次// box.onclick = null来取消事件的绑定// 第二种var fn = function() &#123;&#125;box.addEventListener('click', fn)// 能绑定多个实现体, 如果有多次绑定, 按顺序依次执行// box.removerEventListener('click', fn)来取消事件的绑定// 了解: 第三个参数决定冒泡顺序(子父级谁先相应事件) 事件对象 12345678910111213// 系统回调事件函数时, 传递了一个 事件(event) 实参// 如果要使用传递来的实参 事件(event), 定义接收的 形参 即可box.onclick = function(ev)&#123; // 使用事件对象 // 特殊按键 eg: ev.altKey: true | false // 鼠标触发点: ev.clientX | ev.clientY // 取消冒泡 ev.cancelBubber = true; // 取消默认事件 return false;&#125; 事件总结 鼠标事件 123456789101112131415161718192021222324252627282930var box = document.querySelector('.box');// 1. 点击事件box.onclick = function () &#123; console.log("单击");&#125;;// 2. 双击事件(应用场景不广)box.ondblclick = function () &#123; console.log("双击");&#125;;// 3. 鼠标右键box.oncontextmenu = function () &#123; console.log("右键了"); return false;&#125;;// 4. 鼠标悬浮 | 移动 | 按下 | 抬起 | 离开box.onmouseover = function () &#123; console.log("悬浮");&#125;;box.onmousemove = function () &#123; console.log("移动");&#125;;box.onmousedown = function () &#123; console.log("按下");&#125;;box.onmouseup = function () &#123; console.log("抬起");&#125;;box.onmouseout = function () &#123; console.log("离开");&#125; 12345678910111213// over | out VS enter | leave// 总结:// 1. 将子级与父级分开考虑, 大家都有各自的悬浮离开事件, 采用 over | out 组合// 2. 将子级纳入父级考虑范围, 也就是只有父级去相应悬浮离开事件, 采用 enter | leave 组合// 3. 单独考虑一个盒子的悬浮离开事件, 两套均可以// 特性// 从父级移至子级, 会触发out事件, 紧接着触发子级的over事件, 并可以冒泡给父级// 从父级移至子级, leave事件并不会触发, 它认为子级是属于父级的一部分, enter事件, 也不会再次触发// 悬浮子级:// sub over =&gt; sup over 支持冒泡// sup enter =&gt; sub enter 不支持冒泡 键盘事件 1234// onkeydown: 键盘按下会触发, 长按会持续触发// onkeyup: 键盘抬起会触发// ev.keyCode: 按下的键盘键的标号 其他事件 12// window.onload: 页面加载完毕触发// window.onscroll | document.onscroll =&gt; window.scrollY(页面下滚距离): 页面滚动触发 js盒模型1234// content: 通过计算后样式获取// padding + content: box.clientWidth | box.clientHeight// border + padding + content: box.offsetWidth | box.offsetHeight// 绝对定位top|left: box.offsetTop | box.offsetLeft 动画 定时器 1234567891011121314151617181920// 一次性定时器var timeout = setTimeout(function(a, b)&#123;&#125;, 1000, 10, 20);// 持续性定时器var timer = setInterval(function(a, b)&#123;&#125;, 1000, 10, 20);// 清除定时器// clearTimeout | clearInterval//结论:// 1. 定时器不会立即执行// 2. 一次性定时器只执行一次, 持续性定时器不做清除的话会一直执行// 3. 声明定时器第一个参数为逻辑函数地址, 第二个参数为事件间隔, 第三个为逻辑函数所需参数(可以为多个,一般省略)// 4. 清除定时器可以混用, 本质就是清除创建定时器时的数字标号, 该编号就是创建定时器时的返回值// 小技巧: 如果页面中有n个定时器var n = setTimeout(function () &#123;&#125;, 1);for (var i = 1; i &lt; n; i++) &#123; clearInterval(i)&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python 中的深浅复制]]></title>
    <url>%2F2018%2F12%2F26%2Fpython-%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[python 中的深浅复制前言想起来写这篇博客是因为这段时间学习 js 的时候涉及到了变量的深浅复制问题，然后想先把 python 中的深浅复制理解的更深入一些，再写 js 中的深浅复制，因为 python 对我来说已经很熟悉了。 在 python 中，标识一个对象的唯一身份有三个状态：对象的 id（内存地址），对象类型，对象值。 赋值 赋值是将一个对象的地址赋值给一个变量，使得变量指向该内存地址； 修改不可变对象时（str、tuple、int）需要开辟新的内存空间； 修改可变对象时（list、dict、set）不需要开辟新的内存空间。 赋值是将 id 重新赋值给了一个新的变量，引用计数加1。 浅拷贝浅拷贝只是拷贝父对象，而对于父对象中的子对象并不会进行拷贝。 12345678a = &#123;1: [1, 2, 3]&#125;b = a.copy()a['name'] = 'musibii'a # &#123;1: [1, 2, 3], 'name': 'musibii'&#125;b # &#123;1: [1, 2, 3]&#125;a[1].append(4)a # &#123;1: [1, 2, 3, 4], 'name': 'musibii'&#125;b # &#123;1: [1, 2, 3, 4]&#125; 也就是说浅拷贝将a的值复制到一个新的内存空间，并将内存地址赋值给 b，所以对 a 对象添加新的属性，b 并不会改变；但是因为浅拷贝只是拷贝了一层，对于子对象的内存空间是原对象的内存引用，所以修改 a 相应的 b 中也会改变。 浅拷贝只拷贝父对象，不会拷贝对象内部的子对象。 深拷贝深拷贝完全赋值被复制对象的元素，不是复制内存地址，是开辟新的内存空间将被复制对象的值放在了新的内存空降中，并将新的内存地址指向了新的变量，这样的话，修改原对象不会对新的对象产生影响。 深拷贝是在另一块地址中创建一个新的变量，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。 在Python 中深拷贝需要引入 copy 模块： 123456import copyc = copy.deepcopy(a)c # &#123;1: [1, 2, 3], 'name': 'musibii'&#125;a[1].append(4)a # &#123;1: [1, 2, 3, 4], 'name': 'musibii'&#125;c # &#123;1: [1, 2, 3], 'name': 'musibii'&#125; 解析 b = a：赋值引用，a 和 b 都指向同一个对象 b = a.copy()：浅拷贝，a 和 b 是一个独立的对象，但他们的子对象还是指向同一个对象（引用）。 b = copy.deepcopy(a)：深拷贝，a 和 b 完全拷贝了父对象及其子对象，两者完全独立。 更多实例1234567891011121314import copya = [1, 2, 3, 4, ['a', 'b']] #原始对象 b = a #赋值，传对象的引用c = copy.copy(a) #对象拷贝，浅拷贝d = copy.deepcopy(a) #对象拷贝，深拷贝 a.append(5) #修改对象aa[4].append('c') #修改对象a中的['a', 'b']数组对象 print( 'a = ', a )print( 'b = ', b )print( 'c = ', c )print( 'd = ', d ) 输出 1234('a = ', [1, 2, 3, 4, ['a', 'b', 'c'], 5])('b = ', [1, 2, 3, 4, ['a', 'b', 'c'], 5])('c = ', [1, 2, 3, 4, ['a', 'b', 'c']])('d = ', [1, 2, 3, 4, ['a', 'b']]) 以上部分参考菜鸟教程]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript（六）]]></title>
    <url>%2F2018%2F12%2F22%2FJavaScript%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JavaScript 系列博客（六）前言本篇博客学习 js 选择器来控制 css 和 html、使用事件（钩子函数）来处理事件完成后完成指定功能以及js 事件控制页面内容。 js 选择器在学习 js 选择器前需要了解几个概念。 节点（一）：在文档（document）中出现的所有内容都是 document 中的节点。 节点（二）：标签节点（元素 element） | 注释节点 | 文本节点 | &lt;!doctype&gt;节点。 js 选择器是将 js 与 html 建立起连接的桥梁，就好比 css 选择器是 css 与 html 的桥梁，不过js 中将 html 标签称为元素。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;js选择器&lt;/title&gt; &lt;style&gt; #d &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body id="bd"&gt; &lt;!--注释--&gt; &lt;div id="d" class="dd"&gt;我是ddd111&lt;/div&gt; &lt;div id="d" class="dd"&gt;我是ddd222&lt;/div&gt; &lt;div class="sup1"&gt; &lt;div id="div"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="sup2"&gt; &lt;div id="div"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 通过 id 名进行匹配123&lt;script&gt; console.log(d); // 两个都可以匹配到 &lt;/script&gt; 通过 getElement所有显示在页面中的内容都是属于文档（document）对象的内容，存放在文档中。 123456789console.log(document)// id 获取getElementById('id 名'); // 只能由 document 来调用// class 获取getElementByClassName('class 名'); // 可以由 document 以及所有父级调用// tag 获取getElementByTagName('标签名'); // 可以由 document 以及所属父级调用 querySelector123456789// 获取第一个满足要求的目标querySelector()// 获取所有满足要求的目标querySelectorAll()// 1. 参数：采用的为 css 选择器语法// 2. 可以由 document 以及父级来调用// 3. 对 id 检索不严谨，慎用 id 选择器 js 操作页面内容 文本内容 12box.innerText// 可以设置，也可以直接获取值 标签内容 12345box.innerHTML// 可以设置，也可以获取值，能解析 html 语法代码box.outerHTML// 获取包含自身标签信息的所有子内容信息 样式 12345/ box.style.样式名 ==&gt; 可以设值,也可以获取,但操作的只能是行间式// getComputedStyle(box, null).样式名 ==&gt; 只能获取值,不能设值, 能获取所有方式设置的值(行间式 与 计算后样式)// 注: 获取计算后样式,需要关注值的格式 页面标签全局属性操作 123456ele.getAttribute("alert");// 获取页面标签ele的alert全局属性的值, 如果没有该全局属性值为nullele.setAttribute("attr_key", "attr_value");// 页面标签ele已有该全局属性,就是修改值, 没有就是添加该全局属性并赋相应值// 注: 一般应用场景, 结合css的属性选择器完成样式修改 事件12345678910111213// js事件: 页面标签在满足某种条件下可以完成指定功能的这种过程, 成之为事件// 某种条件: 如鼠标点击标签: 点击事件 | 鼠标双击标签: 双击事件 | 键盘按下: 键盘按下事件// 指定功能: 就是开发者根据实际需求完整相应的功能实现// 钩子函数: 就是满足某种条件被系统回调的函数(完成指定功能)// 点击事件: 明确激活钩子的条件 = 激活钩子后改处理什么逻辑, 完成指定功能(函数)// 获取页面标签是前提var div = document.querySelector('.div');// 钩子条件: 双击 = 指定功能(自身背景颜色变红)div.ondblclick = function () &#123; this.style.backgroundColor = 'red';&#125; 事件的绑定1234567891011// 第一种box.onclick = function()&#123;&#125;// 只能绑定一个实现体, 如果有多次绑定, 保留最后一次// box.onclick = null来取消事件的绑定// 第二种var fn = function() &#123;&#125;box.addEventListener('click', fn)// 能绑定多个实现体, 如果有多次绑定, 按顺序依次执行// box.removerEventListener('click', fn)来取消事件的绑定// 了解: 第三个参数决定冒泡顺序(子父级谁先相应事件) 事件对象12345678910111213// 系统回调事件函数时, 传递了一个 事件(event) 实参// 如果要使用传递来的实参 事件(event), 定义接收的 形参 即可box.onclick = function(ev)&#123; // 使用事件对象 // 特殊按键 eg: ev.altKey: true | false // 鼠标触发点: ev.clientX | ev.clientY // 取消冒泡 ev.cancelBubber = true; // 取消默认事件 return false;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[websocket 初识]]></title>
    <url>%2F2018%2F12%2F22%2Fwebsocket-%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[websocket 初识前言其实很早就知道了 websocket 这个概念了，像现在大火的直播等使用的就是 websocket。之前找爬虫工作，对面问我爬过 websocket 网站没，很汗颜，那时候还只是听说过。现在想了解一下，基于 JavaScript 语言。 Websocket 是什么websocket 是一种网络通信协议，运行在 TCP 协议之上。 对于传统的 HTTP 协议来说，通信只能由客户端发起，然后服务端响应。HTTP 协议做不到服务器制动向客户端推送信息。HTTP 协议的这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。只能使用‘’轮询‘’：（非阻塞通信），每隔一段时候，就发出一个询问，了解服务器有没有新的消息。轮询的效率低，非常浪费资源。 websocket 协议在2008年诞生，它的最大特点就是服务器可以主动向客户端推送消息，客户端也可以主动向服务器发送消息，是真正的双向平等对话，属于服务器推送技术的一种。websocket 允许服务器端与客户端进行全双工通信。其特点如下： 建立在 TCP 协议之上，服务端的实现比较容易； 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器； 数据个数比较轻量，性能开销小，通信高效； 可以发送文本，也可以发送二进制数据； 没有同源限制，客户端可以与任意服务器通信，完全可以取代 AJAX； 协议标识符是 ws（加密就是 wss），服务器网址为 URL。 1ws://example.com:80/some/path websocket 握手浏览器发出的 websocket 握手请求类似于下面： 1234567GET / HTTP/1.1Connection: UpgradeUpgrade: websocketHost: example.comOrigin: nullSec-WebSocket-Key: ...Sec-WebSocket-Version: 13 这是数据头，HTTP1.1协议规定，Upgrade 字段表示将通信协议从 HTTP/1.1转向该字段指定的协议。Connection 字段表示浏览器通知服务器，如果可以的话就升级到 WebScoket 协议。Origin 字段用于提供请求发出的域名，供服务器验证是否许可的范围内（服务器可以不验证）。Sec-Websocket-Key 则是用于握手协议的密钥，是 Base64编码的16字节随机字符串（可以反解）。 服务器的 WebSocket 回应如下： 123456HTTP/1.1 101 Switching ProtocolsConnection: UpgradeUpgrade: websocketSec-WebSocket-Accept: ...Sec-WebSocket-Origin: nullSec-WebSocket-Location: ws://exammple.com/ 服务器同样用 Connection 字段通知浏览器，可以改变协议为 Websocket，Sec-WebSocket-Accept 字段是服务器在浏览器提供的 Sec-Webscoket-Key 字符串后面，添加 RFC6465（不了解）标准规定的‘’258EAFA5-E914-47DA-95CA-C5AB0DC85B11‘’字符串，然后再取 SHA-1的哈希值。浏览器将对这个值进行验证，以证明确实是目标服务器回应了 Websocket 请求。Sec-WebSocket-Location 字段表示进行通信的 Websocket 网址。 完成握手以后，WebSocket 协议就在 TCP 协议之上，开始传送数据。 客户端的示例1234567891011121314var ws = new WebSocket('wss://echo.websocket.org'); // 网址不可达ws.open = function(ev) &#123; console.log('Connection open...'); ws.send('Hello WebSocket!');&#125;;ws.onmessage = function(ev) &#123; console.log('Recevied Message: ' + ev.data);&#125;;ws.onclose = function(ev) &#123; console.log('Connection closed.');&#125; 客户端 API浏览器对 WebSocket 协议的处理，无非是三件事： 建立连接和断开连接； 发送数据和接收数据； 处理错误。 构造函数 WebSocketWebSocket 对象作为一个构造函数，用于新建 WebSocket实例。 1var ws = new WebSocket('ws://localhost:8080'); 执行上面语句后，客户端就会与服务器进行连接。 WebSocket.readyState跟 HTTP 协议一样，WebSocket 也有自己的状态码： CONNECTING：值为0，表示正在连接； OPEN：值为1，表示连接成功，可以进行通信； CLOSING：值为2，表示连接正在关闭； CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 实例： 1234567891011121314151617switch (ws.readyState) &#123; case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happend break;&#125; webSocket.onopen实例对象的 onopen 属性，用于指定连接成功后的回调函数。 123ws.onopen = function () &#123; ws.send('Hello MUSIBII');&#125; 如果要指定多个回调函数，可以使用 addEventListener 方法。 123ws.addEventListener('open', function () &#123; ws.send('Hello MUSIBII');&#125;) webSocket.onclose实例对象的 onclose 属性，用于指定连接关闭后的回调函数。 12345678910111213ws.onclose = function (ev) &#123; var code = ev.code; var reason = ev.reason; var wasClean = ev.wasClean; // handle close event&#125;;ws.addEnentListener('close', function (ev) &#123; var code = ev.clde; var reason = ev.reason; var wasClean = ev.wasClean; // handle close event&#125;) webSocket.onmessage实例对象的 onmessage 属性，用于指定收到服务器数据后的回调函数。 123456789ws.onmessage = function (ev) &#123; var data = ev.data; // handle data&#125;;ws.addEvendListener('message', function (ev) &#123; var date = ev.data; // handle data&#125;) 注意：服务器的数据可能是文本，也可能是二进制数据（blob 对象或 Arraybuffer 对象）。 12345678910ws.onmessage = function (ev) &#123; if(typeof ev.data === String) &#123; console.log('Received data string'); &#125; if(ev.data instanceof ArrayBuffer) &#123; var buffer = ev.data; console.log('Received arraybuffer'); &#125;&#125; 除了动态判断收到的数据类型，也可以使用 binaryType 属性，显式指定收到的二进制数据类型。 1234567891011// 收到的是 blob 数据ws.binaryType = 'blob';ws.onmessage = function (ev) &#123; console.log(ev.data.size);&#125;;// 收到的是 ArrayBuffer 数据ws.binaryType = 'arraybuffer';ws.onmessage = function (ev) &#123; console.log(ev.data.byteLength);&#125; webSocket.send()实例对象的 send() 方法用于向服务器发送数据。 发送文本的例子。 1ws.send('your message'); 发送 Blob 对象的例子。 12var file = document.querySelector('input[type = "file"]').files[0];ws.send(file); 发送 ArrayBuffer 对象的例子。 12345678// Senging canvas ImageData as ArrayBuffervar img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) &#123; binary[i] = img.data[i];&#125;;ws.seng(binary.buffer); webSocket.bufferedAmout实例对象的 bufferedAmout 属性，表示还有多少字节的二级制数据没有发送出去。它可以用来判断发送是否结束。 12345678var data = new ArrayBuffer(100000);socket.send(data);if (socket.bufferedAmount === 0) &#123; // 发送完毕&#125; else &#123; // 发送没有结束&#125; webSocket.onerror实例对象的 onerror 属性，用于指定报错时的回调函数。 1234567socket.onerror = function (ev) &#123; // handle error event&#125;;socket.addEventListener('error', function (ev) &#123; // handle error enent&#125;);]]></content>
      <categories>
        <category>websocket</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript（五）]]></title>
    <url>%2F2018%2F12%2F21%2FJavaScript%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JavaScript 系列博客之（五）前言本篇介绍 JavaScript 中的对象。在第一篇博客中已经说到 JavaScript 是一种‘’对象模型‘’语言。所以可以这样说，对象是 JavaScript 语言的核心概念，也是最重要的数据类型。 概述生成方法在 JavaScript 中声称对象相当方便，直接定义一个空字典就 ok。想要添加属性或者方法的话可以在定义结束之后动态添加。注意：对象时无序的复合数据集合。 上面代码中，大括号就可以直接定义一个对象，被赋值给变量 a，所以 a 就指向一个对象。该对象为一个空对象，但是会有一些默认的方法，像 constructor 是构造方法，想要动态的添加属性和方法就是这个方法的功劳。 在这里添加了一个属性为name，那么 name 是键名（成员名称），字符串 musibii 是键值（成员的值）。键名与键值之间用冒号分隔。如果再添加一个属性，那么属性之间使用逗号分隔。 具体生成方法1234567891011121314151617181920212223242526272829303132333435363738394041424344// 1.单一对象var obj = &#123; // 属性 name: 'Zero', // 方法 teach: function () &#123; console.log("教学"); &#125;&#125;;obj.name | obj.teach()// 2.构造函数function Person(name) &#123; // 类似于python中的类一样来使用 // this代表Person构造函数实例化出的所有具体对象中的某一个 this.name = name; this.teach = function () &#123; console.log(this.name + "正在教学"); &#125;&#125;// ①通过构造函数实例化出具体对象// ②通过对象.语法调用属性与方法var p1 = new Person("张三"); p1.name // 张三, this指向p1对象var p2 = new Person("李四"); p2.teach // 李四正在教学, this指向p2对象// 3.ES6类语法class Student &#123; // 需要构造器(构造函数)来完成对象的声明与初始化 constructor (name) &#123; // 属性在构造器中声明并完成初始化 this.name = name; &#125; // 类中规定普通方法 study () &#123; console.log(this.name + "正在学习"); &#125; // 类方法 static fn() &#123; console.log("我是类方法") &#125;&#125;// 类中的普通方法由类的具体实例化对象来调用// 类中的类方法由类直接来调用(这类型的方法大多是功能性方法,不需要对象的存在) 键名对象的所有键名都是字符串（ES6又引入了 Symbol 值也可以作为键名：还没了解过），所以加不加引号都可以。如果键名是数值，会被自动转为字符串。如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 对象的每一个键名又称为‘’属性‘’，它的键值可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为方法，调用方法和函数一样。 特别的如果属性的值指向的还是一个对象，那么就行成了链式引用。对象的属性之间用逗号分隔，最后一个属性后面可以加逗号，也可以不加。 对象的引用如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有的引用。和 JavaScript 中的基本数据类型不一样，复合数据类型是传址传递。 a 和 b指向同一个对象，因此为其中任何一个变量添加属性，另一个变脸都可以读写该属性。如果取消某一个对象的引用，不会影响到其他变量。 这种引用只局限于对象，在之前的博客也提到，两个变量指向同一个原始类型（基本数据类型）的值，那么变量只是对值得拷贝（传值传递）。 属性的操作属性的读取读取对象的属性，有两种方法，一种是使用点运算符；另一种是使用方括号运算符。（在 python 中，字典只能通过方括号取值；对象只可以通过点运算符取值。不过可以通过自定义字典类改写 getattr 魔术方法改变。） 注意：如果使用方括号运算符，键名必须放在引号里面，否则会被当做变量处理。 123456789var foo = 'bar';var obj = &#123; foo: 1, bar: 2&#125;;obj.foo // 1obj[foo]// 2 上面代码中，引用对象obj 的 foo 属性时，如果使用点运算符，foo 就是字符串；如果使用方括号运算符，但是不使用引号，那么 foo 就是一个变量，指向字符串 bar。 方括号运算符内部还可以使用表达式： 12obj['hello' + 'world']obj[3 + 3] 数字键可以不加引号，因为会自动转为字符串。 12345var obj = &#123; 0.7: 'hello world'&#125;;obj['0.7'] // 'Hello World'obj[0.7] // 'Hello World' 上面代码对象的数字键0.7加不加引号都可以，因为会自动转为字符串。 123456var obj = &#123; 123: 'Hello musibii'&#125;;obj.123 // 报错obj[123] // 'Hello musibii' 如果对数值键名123使用点运算符，会报错，使用方括号运算符才是正确的方式。 属性的赋值点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。 JavaScript 允许属性的后绑定，也就是说可以在任意时刻新增属性，没必要在定义对象的时候就把属性全都定义好。 属性的查看查看一个对象的所有属性使用 Object.keys 方法。 123456var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj); // [key1, key2] 属性的删除delete 命令用于删除对象的属性，删除成功后返回 true。 1234567var obj = &#123; p: 1;&#125;delete obj.p; // trueobj.p // undefinedObject.keys(obj) // [] 上述代码中，delete 命令删除对象 obj 的 p 属性。删除后，再读取 p 属性就会返回 undefined，而且 Object.keys 方法的返回值也不再包括该属性。 注意：删除一个不存在的属性，delete 不会报错而是返回 true。因此不能根据 delete 命令的结果认为某个属性的存在。（那么到底哪种方式才可以证明某个属性的存在与否） 如果删除属性时返回 false那就说明该属性存在，但是不可以删除。 1234567var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 'musibii', configurable: false&#125;);obj.p // 'musibii'delete obj.p // false 上述代码中，通过 Object 的defineProperty方法给对象 obj创建了一个属性，属性的configurable（可配置） 的值为 false，这样的一个属性就是不可以删除的。 另外需要注意的是，delete 命令只能删除对象本身的属性，无法删除继承的属性。 可以看出虽然 delete 命令返回 true，但是删除的属性依然存在。但是如果通过 proto 删除的话就可以删除。 判断属性的存在in 运算符用于检出对象是否包含某个属性（注意，检查的是键名，不是键值）。如果包含就返回 true，否则就返回 false。它的左边是一个字符串，表示属性名，右边则是一个对象。 123var obj = &#123;p: 1&#125;;'p' in obj //true'toString' in obj // true 拿上面删除的 constructor 来说： in 运算符的一个问题是，它不能识别哪些属性时对象自身的，哪些属性是继承的。就像上面，对象 obj 本身并没有 toString 属性，但是 in 运算符会返回 true，因为这个属性是继承的。 这时可以通过对象的 hasOwnProperty 方法判断，是否为对象自身属性 1234var obj = &#123;&#125;;if ('toString' in obj) &#123; console.log(obj.hasOwnProperty('toString')); // fasle&#125; 属性遍历for…in 循环用来遍历一个对象的所有属性。 for…in 循环有两个注意点; 它遍历的是对象所有可遍历的属性，会跳过不可遍历的属性； 它不仅遍历对象自身的属性，还遍历继承的属性。 如果继承的属性是可遍历的，那么就会被 for…in 循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用 for…in 的时候，应该结合使用 hasOwnProperty 方法，在循环内部判断一下，某个属性是否为对象自身的属性。 1234567var person = &#123;name: '老张'&#125;;for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125; // name with 语句with 语句的格式如下： 123with (对象) &#123; 语句;&#125; 它的作用是操作同一个对象的多个属性时，提供一些书写的方便。 注意：如果 with 区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 12345678var obj = &#123;&#125;;with (obj) &#123; p1 = 4, p2 = 5&#125;obj.p1 // undefinedp1 // 4 上面代码中，对象 obj 并没有 p1属性，对 p1赋值等于创造了一个全局变量 p1.正确的写法应该是，先定义对象 obj 的属性 p1，然后在 with 区块内操作它。 这是因为 with 区块没有改变作用域，它的内部依然是当前作用域。这造成了with 语句的一个很大的弊病，就是绑定对象不明确。 123with (obj) &#123; console.log(x);&#125; 单纯从上面的代码块，根本无法判断 x 到底是全局变量，还是对象 obj 的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用 with 语句，可以考虑用一个临时变量代替 with。 123456with (obj1.obj2.obj3) &#123; console.log(p1 + p2);&#125;// 可以写为var temp = obj1.obj2.obj3;console.log(temp.p1 + temp.p2);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript（四）]]></title>
    <url>%2F2018%2F12%2F19%2FJavaScript%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JavaScript 系列博客之（四）前言本篇介绍 JavaScript 中的函数知识。 函数的三种声明方法function 命令可以类比为 python 中的 def 关键词。 function 命令声明的代码区块，就是一个函数。命令后面是函数名，函数名后面的圆括号里面是要传入的形参名。函数体放在大括号里面。 123function fn(name) &#123; console.log(name);&#125; 使用 function 命名了一个 fn 函数，以后可以通过调用 fn 来运行该函数。这叫做函数的声明（Function Declaration）。 函数表达式除了使用 function 命令声明函数外，可以采用变量赋值的写法。（匿名函数） 123var fn = function(name) &#123; console.log(name);&#125;; 这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称之为函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。 采用函数表达式声明函数时，function 命令后面不带有函数名。如果加上函数名，该函数名只能在函数体内访问，在函数体外部无效。 1234567var fn = function x(name) &#123; console.log(typeof x);&#125;;x// ReferenceError: x is not definedfn();// function 声明函数时，在函数表达式后加了函数名 x，这个 x 只可以在函数内部使用，指代函数表达式本身。这种写法有两个用处：一可以在函数体内部调用自身；二方便debug（debug 显示函数调用栈时，会显示函数名）。需要注意的是，函数表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。 Function 构造函数第三种声明函数的方法是通过构造函数，可以理解为 python 中的函数类，通过传入参数并且返回结果就可以创建一个函数。 构造函数接收三个参数，最后一个为 add函数的‘’函数体‘’，其他参数为add 函数的参数。可以为构造函数传递任意数量的参数，不过只有最后一个参数被当做函数体，如果只有一个参数，该参数就是函数体。 Function 构造函数也可以不用 new 命令，结果一样。这种声明函数的方式不直观，使用概率很少。 函数的调用和 python 一样，调用一个函数通过圆括号，圆括号中是要传入的实参。 函数体内部的 return 语句，表示返回。JavaScript 引擎遇到 return 时，就直接返回 return 后面表达式的值（和 python 一样），所以 return 后面的代码是无意义的，如果没有 return 那么就会返回 undefined（python 中返回 None）。 函数作用域作用域的定义作用域指的是变量存在的范围。在 ES5中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，任意位置可以访问到；另一种是函数作用域，也称之为局部作用域，变量只有在函数内部才能访问到。ES6新增了块级作用域，等价于局部作用域一样，就是新增了一种产生局部作用域的方式。通过大括号产生块级作用域。 在函数外部声明的变量就是全局变量，可以在任意位置读取。 在函数内部定义的变量，外部无法读取，只有在函数内部可以访问到。并且函数内部定义的同名变量，会在函数内覆盖全局变量。 注意：对于 var 命令来说，局部变量只可以在函数内部声明，在其他区块中声明，一律都是全局变量。ES6中声明变量的命令改为 let，在区块中声明变量产生块级作用域。 函数内部的变量提升与全局作用域一样，函数作用域也会产生‘’变量提升‘’现象。var 命令生命的变量，不管在什么位置，变量声明都会被提升到函数体的头部。 12345678910111213function foo(x) &#123; if (x &gt; 100) &#123; var tmp = x - 100; &#125;&#125;// 等同于function foo(x) &#123; var tmp; if (x &gt; 100) &#123; tmp = x - 100; &#125;&#125; 函数本身的作用域函数和其他值（数值、字符串、布尔值等）地位相同。凡是可以使用值得地方，就可以使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当做参数传入其他函数，或者作为函数的结果返回。函数是一个可以执行的值，此外没有特殊之处。 函数也有自己的作用域，函数的作用域称为局部作用域。与变量一样，就是其生命时所在的作用域，与其运行时所在的作用域无关（闭包、装饰器）。通俗地讲就是在定义函数的时候，作用域已经就确定好了，那么在访问变量的时候就开始从本作用域开始查找，而与函数的调用位置无关。 123456789var x = function () &#123; var a = 1; console.log(a);&#125;;function y() &#123; var a = 2; x();&#125;y(); // 1 函数 x 是在函数 f 的外部生命的，所以它的作用域绑定外层，内部变量 a 不会到函数 f 体内取值，所以输出1，而不是2。 总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。 函数参数调用函数时，有时候需要外部传入的实参，传入不同的实参会得到不同的结果，这种外部数据就叫参数。 参数的省略在 JavaScript 中函数参数不是必需的，就算传入的参数和形参的个数不相等也不会报错。调用时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值变为 undefined。需要注意的是，函数的 length 属性值与实际传入的参数个数无关，只反映函数预期传入的参数个数。 但是，JavaScript 中的参数都是位置参数，所以没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显示的传入 undefined。 传递方式函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（pass by value）。这意味着，在函数体内修改参数值，不会影响到函数外部（局部变量的修改不会影响到全局变量：对于基本数据类型）。 但是，如果函数参数是复合类型的值（数组、对象、其他函数），因为传值方式为地址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。 注意：如果函数内部修改的不是参数对象的某个属性，而是直接替换掉整个参数，这时不会影响到原始值。 12345678var obj = [1, 2, 3];function f(o) &#123; o = [2, 3, 4];&#125;f(obj);obj // [1, 2, 3] 上面代码，在函数 f 内部，参数对象 obj 被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（o）的值实际上是参数 obj 的地址，重新对o 赋值导致 o 指向另一个地址，保存在原地址上的数据不会被改变。 同名参数如果有同名的参数，则取最后出现的那个值。 12345function f(a, a) &#123; console.log(a);&#125;f(1, 2) // 2 上面代码中，函数 f 有两个参数，且参数名都是 a。取值的时候，以后面的 a 为准，即使后面的a 没有值或被省略，也是以其为准。 1234function f(a, a) &#123; console.log(a);&#125;f(1) // undefined 调用函数 f 时，没有提供第二个参数，a 的取值就变成了 undefined。这时，如果要获得第一个 a 的值，可以使用 arguments 对象（类比linux 中的arg）。 12345function f(a, a) &#123; console.log(arguments[0]);&#125;f(1) // 1 arguments 对象定义由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是 arguments 对象的由来。 arguments 对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，以此类推。注意：该对象只有在函数体内部才可以使用。 正常模式下，arguments 对象可以在运行时修改。 123456var f = function(a, b) &#123; arguments[0] = 3; arguments[1] = 3; return a + b;&#125;f(1, 1) // 5 上面代码中，调用 f 时传入的参数，在函数体内被修改了，那么结果也会修改。 严格模式下，arguments 对象是一个只读对象，修改它是无效的，但不会报错。 12345678var f = function(a, b) &#123; 'use strict'; // 开启严格模式 arguments[0] = 3; // 无效 arguments[1] = 2; // 无效 return a + b;&#125;f(1, 1) // 2 开启严格模式后，虽然修改参数不报错，但是是无效的。 通过 arguments 对象的 length 属性，可以判断函数调用时到底带几个参数。 12345function f() &#123; return arguments.length;&#125;f(1, 2, 3) // 3f(1) // 1 与数组的关系需要注意的是，虽然 arguments 很像数组，但它是一个对象。数组专有的方法（比如 slice 和 forEach），不能再 arguments 对象上直接使用。 如果要让 arguments 对象使用数组方法，真正的解决方法是将 arguments 转为真正的数组。下面是两种常用的转换方法：slice 方法和逐一填入新数组。 123456var args = Array.prototype.slice.call(arguments);// var args = [];for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; callee 属性arguments 对象带有一个 callee 属性，返回它所对应的原函数。 1234var f = function() &#123; console.log(arguments.callee === f); &#125;f(); // true 可以通过 arguments.callee，达到调用自身的目的。这个属性在严格模式里面是禁用的，不建议使用。 函数闭包闭包是所有编程语言的难点，在 python 中闭包的多应用于装饰器中。在 JavaScript 中闭包多用于创建作用域，或者解决变量污染的问题。 理解闭包，首先需要理解变量作用域。在 ES5中，JavaScript 只有两种作用域：全局作用于和函数作用域。函数内部可以直接读取全局变量。 123456var n = 999;function f1() &#123; console.log(n);&#125;f1(); // 999,n是全局变量，可以被访问到 但是函数外部无法读物函数内部声明的变量。 12345function f1() &#123; var n = 999;&#125;console.log(n);// Uncaught ReferenceError: n is not defined 因为变量作用域的关系，在外部需要访问到局部变量在正常情况下是做不到的，这就可以通过闭包来实现。下来来看一个经典例子：循环绑定事件产生的变量污染 12345678910111213141516171819&lt;div class="box"&gt; 0000001&lt;/div&gt;&lt;div class="box"&gt; 0000002&lt;/div&gt;&lt;div class="box"&gt; 0000003&lt;/div&gt;&lt;script&gt; var divs = document.querySelectorAll(".box"); // 存在污染的写法 for (var i =0; i &lt; divs.length; i++) &#123; divs.onclick = function () &#123; console.log('xxx', i) &#125; &#125; // 运行结果显示4&lt;/script&gt; 会产生变量污染的原因是作用域，因为 var 并不产生作用域，所以在 for循环中的变量就是全局变量，只要 for循环结束那么 i 的值就确定了，除非在极限情况下，你的手速比 cpu 还要快，那么可能会看到小于4的值。这样的问题可以通过函数的闭包来解决。产生新的作用域用来保存 i 的值。 12345678910111213141516for (var i = 0; i &lt; divs.length; i++) &#123; (function () &#123; var index = i; divs[index].onclick = function () &#123; console.log('xxx', index); &#125; &#125;)()&#125;// 另一种版本for (var i = 0; i &lt; divs.length; i++) &#123; function(i) &#123; divs[i].onclick = function () &#123; console.log('yyy', i) &#125; &#125;(i)&#125; 利用闭包原理产生新的作用域用来保存变量 i 的值，这样就解决了变量污染的问题，还有利用ES6的声明变量关键词 let，也会产生新的作用域（块级作用域）也可以解决变量污染的问题。 在 JavaScript 中，嵌套函数中的子函数中可以访问到外部函数中的局部变量，但是外部函数访问不到子函数中的局部变量，这是 JavaScript 中特有的‘’链式作用域‘’结构（python 也一样），子对象会一级一级的向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。可以简单地把闭包理解为‘’定义在一个函数内部的函数‘’，闭包最大的特点就是它可以‘’记住‘’诞生的环境，在本质上闭包就是将函数内部和函数外连接起来的一座桥梁。 必报的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生的环境一直存在。下面的例子： 1234567891011function createIncrementor(start) &#123; return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);inc(); // 5inc(); // 6inc(): // 7 上面代码中，start 是函数 createIncrementor 的内部变量。通过闭包，start 的状态被保存，每一次调用都是在上一次调用的基础上进行计算。从中可以看出，闭包 inc 使得函数 createIncrementor 的内部环境一直存在。所以闭包可以看做是函数内部作用域的一个接口。为什么会这样呢？原因就在于 inc 始终在内存中，而 inc 的存在依赖于 createIncrementor，因此也一直存在于内存中，不会再外层函数调用结束后 start 变量被垃圾回收机制回收。 闭包的另外一个用处是封装对象的私有属性和私有方法。（这部分还不太懂，还需要琢磨） 12345678910111213141516171819function Person(name) &#123; var _age; function setAge(n) &#123; _age = n; &#125; function getAge() &#123; return _age; &#125; return &#123; name: name, getAge: getAge, setAge: setAge &#125;;&#125;var p1 = Person('张三');p1.setAge(25);p1.getAge() // 25 上面代码中，函数 Person 的内部变量_age，通过闭包 getAge 和 setAge，变成了返回对象p1的私有变量。 注意：外城函数每次运行，都会产生一个新的闭包，而这个闭包又会保留外城函数的内部变量，所以内存消耗很大。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript（三）]]></title>
    <url>%2F2018%2F12%2F18%2FJavaScript%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JavaScript 系列博客（三）前言本篇博客介绍 js 中的运算符、条件语句、循环语句以及数组。 运算符 算术运算符 1234567891011121314151617181920212223// + | - | * | / | % | ++ | -- console.log(5 / 2); // 2.5 // 取整 console.log('%d', 5 / 2); // "2" var num = parseInt(5 / 2); // 2 console.log(num); // 取模(求余) console.log(5 % 2); // 1 // 任何一个自然数对 n 取余, 结果为 [0, n-1] // 自增|自减 ++|-- // ++就是自增1, --就是自减1 var num = 10 console.log(num++); // 10 console.log(++num); // 12 console.log(num); // 12 // ++在变量后(num++), 先将变量的值拿去使用,再自身自增1 // ++再变量前(++num), 先将变量自身自增1, 再将结果拿去使用 // 总结: 不管++在前在后,运算结束后,变量自身值一定自增1 // res = ++num &lt;==&gt; num++; res = num // res = num++ &lt;==&gt; res = num; ++num 赋值运算符 123456789// = | += | -= | *= | /= | %= var x = 10; // 将10的值赋值给变量x y = x; // 将变量x的值传递给变量y console.log(y); // 10 x += 10; // x = x + 10, 运算方式由右至左, 将x+10的结果重新复制给x console.log(y); // 10, y的值虽然来源于x, 但y值只由自身控制 // x /= 10 == x = x / 10 比较运算符 12345678// 比较运算符, 结果为Boolean类型 // == | === console.log("5" == 5); // true, 只做值比较 console.log("5" === 5); // false, 比较值及类型 // != | !== console.log("5" != 5); // false, 只做值比较 console.log("5" !== 5); // true, 比较值及类型 逻辑运算符 1234567891011121314// 总结&amp;&amp;: 全真为真, 有假则假 // 总结||: 全假则假, 有真则真 // 总结!: 真则假, 假则真 // 逻辑运算符的结果本质上为表达式值 // 表达式: 由数字,变量,运算符组成的合法式子 res = a &lt; b &amp;&amp; c; console.log(res); res = (a = 1 || b == c); console.log(res); // 针对 &amp;&amp; | || // 疑问: 逻辑运算符结果可能为逻辑运算符之前表达式的值,也可能是之后表达式的值 针对逻辑运算符，会出现短路现象。当运算符为&amp;&amp;时，如果第一个表达式的结果为假，那么第二个表达式就不会执行；同理，||当第一个表达式的结果为真时，第二个表达式就不会执行（python 在逻辑判断也会出现短路现象） 三目运算符（等同于 python 中的三元表达式） 123456789// 语法: 条件表达式 ? 表达式1 : 表达式2 var a = 10, b = 20; var res = a &lt; b ? a : b; // 取小值 console.log(res); res = a &lt; b ? b : a; // 取大值 console.log(res); // 类似于if...esle... a &lt; b ? console.log("表达式结果为true") : console.log("表达式结果为false") 三目表达式可以看做 if…else 的简写形式。 程序结构根据执行方式程序可以分为三大结构：顺序结构、分支结构、循环结构。其实只有一种结构就是顺序结构，像分支结构本质还是顺序执行的，只不过选择多了；而循环结构也是一样的道理。 条件语句if 结构if结构首先判断后面表达式的布尔值，然后决定是否执行后面的代码。布尔值只有两个，true 为真，false 为假。 12345// 语法if (表达式1) &#123; 语句; &#125;;// 或if (表达式2) &#123;语句&#125;; 上面是 if 结构的基本形式。需要注意的是，‘’布尔值‘’往往是由一个条件表达式产生的，必须放在圆括号中，表达对该表达式求值。如果表达式的结果为 true，就执行后面的代码语句；如果为 false，则跳过后面的语句。 if…else 结构跟 python 一样，if 后面也可以跟 else 代码块，表示不满足条件时，要执行的代码块。 12345if (表达式3) &#123; //表达式结构为真时，执行的代码&#125; else &#123; // 表达是结构为假时，执行的代码&#125; 如果需要对于一个表达式进行多次判断时，多个 if…else 语句可以连到一起。 123456789if (表达式4) &#123; &#125; else if &#123;表达式5&#125; &#123; &#125; else if &#123;表达式6&#125; &#123; &#125; else &#123; &#125; // 注意：else 代码块总是与离自己最近的那个 if 语句配对 switch 分支123456789// 语法switch (结果为整数|字符串的表达式) &#123; case 值1(值需要和表达式进行类型统一): 代码块; break; ... case 值n: 代码块; break; default: 代码块; &#125;// 需要注意的是，switch 语句后面的表达是，与 case 语句后面的表达是比较运行结果时，采用的是严格相等运算符(===)，而不是相等运算符(==)，这意味着比较时不会发生类型转换。// break作用是结束分支结构(结束所属switch语句)，可以省略。 default 分支default分支，出现在所有case之下，当所有case没有匹配上，走该分支,该分支也可以省略，代表没有未匹配到的动作。 循环语句循环语句用于重复执行某个操作，直到条件不满足跳出循环。 while 循环while 循环包括一个循环条件和一段代码块，只要条件为真，就会不断执行代码块。 123while (条件表达式) &#123; 语句;&#125; while语句的循环条件为一个条件表达式，必须放在圆括号中，表示需要先计算表达式的结果才能进行是否进行循环。代码块部分，如果只有一条语句，可以省略大括号。 12345var i = 0;while (i &lt; 100) &#123; console.log('i 为：' + i); i++;&#125; 这段代码会循环100次，直到i 等于100。 for 循环for 循环是循环结构的另一种形式，可以指定循环的起点、终点和终止条件。格式如下： 12345678910/* for (循环变量定义并初始化①; 循环变量条件表达式②; 循环变量增量③) &#123; 代码块④; &#125; 执行顺序 ① ②④③ ... ②④③ ②, ②④③个数就是循环次数 */ for (var i = 0; i &lt; 5; i++) &#123; console.log("我最棒, 我最帅, 我是天下第一!"); &#125; 上段代码圆括号里面有三个表达式： 表达式①（initialize）：确定循环变量的初始值，只在循环开始时执行一次。 表达式②（test）：每轮循环开始时，都需要执行判断，只有判断为真时，才会继续循环。 表达式③（increment）：每轮循环的最后一个操作，通常用来递增循环变量。 所有 for 循环，都可以用 while 循环实现。 for 循环里面的三个表达式可以省略其中任何一个，也可以全部省略。 123for ( ; ; ) &#123; console.log('Hello MUSIBII!');&#125; 这段代码省略了 for 表达式的三个部分，结果就导致了一个无限循环。 do…while 循环do…while 循环和 for 循环类似，唯一区别就是 do 循环不管条件满不满足都会执行一次循环，之后进行第二次循环才会进行判断条件。 12345678do 代码块while (条件表达式);// 或do &#123; 代码&#125; while (条件表达式); 不管条件是否为真，do…while 循环至少需要运行一次，这是和while 循环的本质区别。另外 while 语句后面的分号不要省略。 123456var x = 3;var y = 0;do &#123; console.log(y); y++;&#125; while(y &lt; x); break 和 continue 语句只要有循环就少不了 break 和 continue，这两个关键词都具有跳转作用，可以控制代码的执行顺序。 break 语句用于跳出循环体 1234567var i = 0;while(i &lt; 100) &#123; console.log('i 为：' +i); i++; if (i === 10) break;&#125; 当 i 等于10时，if 表达式判断为真，执行 break 跳出循环体 continue 语句用于立即终止本轮循环，进入下次循环。 123456var i = 0;while(i &lt; 100) &#123; if (i % 2 === 0) continue; console.log('i 为：' +i); i++;&#125; 这段代码只有 i 为奇数时，才会输出 i 的值。如果 i 为偶数，则直接进入下一轮循环。如果存在多重循环，不带参数的 break 语句和 continue 语句都只针对本层循环。 数组数组的定义数组（Array）是按照次序排列的一组值。每个值得索引从0开始，数组使用中括号表示。 1var array = ['a', 'b', 'c', 1, 2, 3]; 这样，array 就构成一个数组，两端的方括号是数组的标志。’a’ 是0号位置，3是5号位置。 除了在定义时赋值，数组也可以先定义后赋值。（通过构造函数（constructor）） 123var array = [];array[0] = 'hello';array[1] = 'world'; 任何类型的数据，都可以放入数组（类比 python 的列表）。 特别的，如果数组的元素还是数组，则形成了多维数组。 数组的本质本质上，数组是对象类型的一种，typeof 运算符会返回数组的类型为 object。 1typeof(['a', 'b', 'c']) // object 这表明，数组类型为对象。数组的特殊性体现在，它的键名是按次序排列的一组整数（从0开始）。 123var array = ['a', 'b', 'c'];Object.keys(array) // ['0', '1', '2'] 通过 Object 的 keys 方法可以返回指定数组的所有键名。 由于数组成员的键名是固定的，因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值取值，是因为非字符串的键名会被转为字符串。 1234var array = ['a', 'b', 'c'];array[0]; // 'a'array['0']; // 'a' 这点在赋值时也会成立（js 的数据类型转换需要注意），一个值总是先转成字符串，再进行赋值。 123var a = [];a[1.00] = 'c';a[1]; // 'c' 赋值时，先把1.00转为字符串1，赋值结束后可以通过数字键1取值。 length 属性数组的 length 属性返回数组的成员数量。 1array.length // 3 JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只用（2^32 - 1）个，也就是说 length 属性的最大值就是4294967295。 只要是数组就一定有 length 属性。该属性是一个动态的值（因为可以动态赋值）。数组的数字键不需要连续，length 属性的值总是比最大的那个整数键大1.另外，数组是一种动态的数据结构，可以随时增减数组成员。 注意：length 属性是可写的。如果认为的设置一个小于当前成员个数的值，该数组的成员会自动减少到 length 设置的值。 1234var array = ['a', 'b', 'c'];array.length; // 3array.length = 2;array // ['a', 'b'] 这表明当数组的 length 属性值设为2，那么整数键2就会被删除。这样清空一个数组就可以直接把 length 属性值设为0就 ok 了。 如果人为设置 length 值大于当前数组元素个数，那么数组的成员数量会增加到这个值，新增的位置都是空（undefined）。 1234var array = ['a'];a.length = 2;a[1]; // undedined 当 length 属性值设为大于数组个数时，读取新增的位置都会返回 undefined。如果设置的不合法，比如设置一个非整数的值时，JavaScript 会报错。 123456789var array = [];array.length = -1;// RangeError: Invalid array lengtharray.length = Math.pow(2, 32);// RangeError: Invalid array lengtharray.length = 'abc';// RangeError: Invalid array length 因为数组的本质是一种对象，所以可以为数组添加属性，但是这不会影响数组的 length 属性。 1234var array = ['a'];array['name'] = 'musibii';array.length; // 1 注意：如果数组添加的键名超过范围的数值，该键名会自动转化为字符串。 12345678var array = [];array[-1] = 'a';array[Math.pow(2, 32)] = 'b';array.length //0array[-1]; // 'a'array[4294967296]; // 'b' 上面为数组添加了两个不合法的数字键，并不会影响到 length 的值。这些数字键都变成了字符串键名。最后两行会取到值是因为会把数字转为字符串。 in 运算符检查某个键名是否存在于数组中，使用 in 运算符，这个适用于对象，自然也适用于数组。 1234var array = ['a', 'b', 'c', 1, 2, 3];2 in array; // true'2' in array; // true6 in array; // false 数组存在键名为2的键，由于键名都为字符串，所以数值2会自动转成字符串。 1234567var array = [];array[100] = 'a';array.length; // 101array[1]; // undefined1 in array; // false 数组 array 只有一个成员，虽然 length 为101，但是其他位置的键名都会返回 false。 for…in 循环和数组的遍历for…in 循环不仅可以遍历对象，也可以遍历数组。因为数组是对象。 12345var array = ['a', 'b', 'c'];for (var i in array) &#123; console.log(array[i]);&#125;// 'a', 'b', 'c' 换行打印 for…in 不仅会遍历数组所有的数字键，也会遍历非数字键。 1234567var array = ['a', 'b', 'c'];array.name = 'musibii';for (var i in array) &#123; console.log(array[i]);&#125;// 'a', 'b', 'c', 'musibii' 在遍历数组时，也会遍历非整数键name，所以不建议使用for…in 遍历数组。可以使用 for 循环或者 while 循环。（这样只会遍历出整数的键名） 数组的空位当数组的某个位置是空元素，即两个逗号之间没有任何值，那么称该数组存在空位。 123var array = ['a', '', 'c'];array.length; // 3array[1]; // undefined 这表名数组的空位不影响 length 属性的值。 并且空位是可以被读取的，只不过值为 undefined。 使用 delete 命令可以删除数组中的某个成员，这样会形成空位，和上面一样不会影响数组的 length 属性。 1234var array = ['a', 'b', 'c'];delete array[1];a[1]; //undefineda.length; // 3 使用 delete 删除了数组中的元素，不会影响数组的 length 属性值，这样如果使用 length 对一个数组进行遍历时需要谨慎（这好奇怪啊。。。。） 数组的某个位置是空位，与某个位置是 undefined，是不一样的。如果是空位，使用数组的 forEach 方法、for…in 结构以及 Object.keys 方法进行遍历时，空位会被跳过。 不得不说，真的奇怪。这个设计思想也太灵活了8。。。 空位表示数组没有这个元素，所以不会被遍历到，而 undefined 表示数组有这个元素，值为 undefined，这样遍历就不会跳过。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript（二）]]></title>
    <url>%2F2018%2F12%2F18%2FJavaScript%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JS常用类一、Number1、常用数字1234整数：10小数：3.14科学计数法：1e5 | 1e-5正负无穷：Infinity | -Infinity 2、常用进制1234二进制：0b1010八进制：012十进制：10十六进制：0xA 3、NaN1非数字类型，通过isNaN()进行判断 4、常用常量123最大值：MAX_VALUE(1.7976931348623157e+308)最小值：MIN_VALUE(5e-324)正负无穷：NEGATIVE_INFINITY | POSITIVE_INFINITY(Infinity | -Infinity) 5、常用实例方法1234toExponential(n) =&gt; 3.14.toExponential(1) =&gt; 1.3e+1 (先科学记数，再确定精度，n为小数精度)toFixed(n) =&gt; 3.14.toFixed(1) =&gt; 3.1 (先确定精度，再普通记数，n为小数精度)toPrecision(n) =&gt; 13.14.toPrecision(1|2) =&gt; 1e+1|13 (先确定精度，再记数，n为位数进度)toString() =&gt; v-hint：经典bug数字13.145二、时间1、创建并获取时间1var date = new Date(); 2、时间戳1date.getTime(); 3、获取时间12345678年：date.getFullYear()月：date.getMonth() + 1日：date.getDate()星期：date.getDay()小时：date.getHours()分钟：date.getMinutes()秒：date.getSeconds()毫秒：date.getMilliseconds() 4、常见格式时间123getUTCFullYear()getUTCDate()getUTCHours() 三、字符串1、常用字符串1'string' | "string" | 'my name is "zero"' | "I'm boy" | "I \"love\" you" 2、常用属性1length：字符串长度 3、常用方法123456789101112chartAt(n)：指定索引字符，同[n]concat(str)：将目标字符串拼接到指定字符串之后indexOf(str)：指定字符串第一次出现的位置lastIndexOf(str)：指定字符串最一次出现的位置replace(re, str)：将正则匹配到的字符串替换为指定字符串substr(n, m)：从索引n开始，截取m个字符长度(m省略代表截取到最后)substring(n, m)：从索引n开始，截取到索引m(m省略代表截取到最后)slice(n, m)：同substring(n, m)split(re)：以指定正则将字符串拆分为数组toUpperCase()：转换为大写toLowerCase()：转换为小写trim()：去除首尾空白字符 四、数组1、常见数组1[1, 2, 3] | ['1', '2', '3'] | [1, '2', true] 2、常用属性1length：数组元素个数 3、常用基础方法12345678concat(arr)：将目标数组拼接到指定数组之后indexOf(ele)：指定元素第一次出现的位置lastIndexOf(ele)：指定元素最一次出现的位置reverse()：反转数组includes(ele, n)：从索引n开始往后，元素ele是否在数组中，做全等匹配，索引从头开始n可以省略(in只做值匹配)fill(ele)：以指定元素填充整个数组slice(n, m)：从索引n开始，截取到索引m(m省略代表截取到最后)join(str)：以指定字符串连接成字符串 4、增删改方法12345678910push(ele)：从尾加unshift(ele)：从头加pop()：从尾删shift()：从头删splice(begin, length, ...eles)：完成增删改// begin开始索引// length长度// 新元素们(可以省略) 5、回调函数方法12345filter(function(value, index)&#123; return true | false&#125;)：过滤器every(function(value, index)&#123; return 条件表达式; &#125;)：全部满足条件some(function(value, index)&#123; return 条件表达式; &#125;)：部分满足条件reduce(function(prev,value,index)&#123; return prev * value; &#125;)：累积sort(function(o, n)&#123; return o &gt; n &#125;)：正逆向排序 五、Math1、常用常量123456E：返回算术常量 e，即自然对数的底数（约等于2.718）LN2：返回 2 的自然对数（约等于0.693）LN10：返回 10 的自然对数（约等于2.302）LOG2E：返回以 2 为底的 e 的对数（约等于 1.4426950408889634）LOG10E：返回以 10 为底的 e 的对数（约等于0.434）PI：返回圆周率（约等于3.14159） 2、常用方法12345678abs(x)：返回 x 的绝对值ceil(x)：向上取整floor(x)：向下取整max(...n)：求最大值min(...n)：求最小值pow(x,y)：返回 x 的 y 次幂random()：返回 0 ~ 1 之间的随机数round(x)：四舍五入 六、正则1、正则对象1234// 构造函数var re = new RegExp('^\\w', 'igm');// 字面量var re = /^\w/igm; 2、修饰符123i：不区分大小写g：全文匹配m：多行匹配 3、正则方法12test()：匹配目标字符串，结果为true|falseexec()：匹配目标字符串，结果为第一条结果所有信息的数组 4、字符串方法1234match(re)：匹配指定正则，结果为数组(可全文匹配)search(re)：匹配指定正则，结果为匹配的索引，反之-1replace(re, newStr)：匹配指定正则，替换匹配的结果(可全文匹配)split(re, n)：按正则进行拆分，n的值可以决定结果的数组长度(可选参数)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript（一）]]></title>
    <url>%2F2018%2F12%2F17%2FJavaScript%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JavaScript 系列博客（一）前言本系列博客为记录学习 JavaScript 的学习笔记，会从基础开始慢慢探索 js。今天的学习笔记主要为 js 引入、定义变量以及 JavaScript 中数据类型和数据类型之间的转换。 引入 JavaScript什么是JavaScript 语言？JavaScript 是一种轻量级的脚本语言。所谓的‘’脚本语言‘’，指的是它不具备开发操作系统的能力，而是只用来编写相关应用程序的‘’脚本‘’，使用场景最多的是浏览器中。 JavaScript 也是一种嵌入式语言。本身的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O相关的接口，都要靠宿主环境提供，所以 JavaScript 只适合嵌入更大型的应用程序环境，去调用宿主环境提供的接口。比如和浏览器的交互。 从语法角度看，JavaScript 语言是一种‘’对象模型‘’语言（Object Models）。各种宿主环境通过这个模型，描述自己的功能和操作接口，还支持其他编程范式（比如函数式编程）。 JavaScript 的核心语法非常精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（一系列的具体对象类型，比如 Array、Date 等）。除此之外，各种宿主环境提供额外的接口（即只能在该环境使用的接口），以便 JavaScript 调用。以浏览器为例，他提供个额外接口分为三大类。 浏览器控制类：操作浏览器 DOM 类：操作网页的各种元素 Web 类：实现互联网的各种功能 如果宿主环境是服务器，则会提供各种操作系统的接口，比如文件操作接口，网络通信接口等。 JavaScript 与 Java的关系其实我很早就知道 JavaScript 和 Java 了，开始也很纳闷它们之间的关系，这里详细介绍一下。 JavaScript 的基本语法和对象体系，是模仿 Java 设计的。但是JavaScript 没有采用 Java 的静态 类型。正是因为 JavaScript与 Java 有很大的相似性，所以这门语言从一开始的 LiveScript 改名为 JavaScript。基本上，JavaScript 这个名字的原意是‘’很像 Java的脚本语言‘’。 JavaScript 语言的函数是一种独立的数据类型，以及采用基于原型对象的继承链。这是它与 Java 语法最大的两点区别。JavaScript 语法比 Java 要自由的多。（约束少了，问题也会多起来）。 除此之外，Java 语言需要编译，而 JavaScript 语言则是运行时由解释器直接执行。 JavaScript 与 ECMAScript 的关系1996年8月，微软模仿 JavaScript 开发了一种相近的语言，取名为JScript（JavaScript 是 Netscape 的注册商标，微软不能用），首先内置于IE 3.0。Netscape 公司面临丧失浏览器脚本语言的主导权的局面。 1996年11月，Netscape 公司决定将 JavaScript 提交给国际标准化组织 ECMA（European Computer Manufacturers Association），希望 JavaScript 能够成为国际标准，以此抵抗微软。ECMA 的39号技术委员会（Technical Committee 39）负责制定和审核这个标准，成员由业内的大公司派出的工程师组成，目前共25个人。该委员会定期开会，所有的邮件讨论和会议记录，都是公开的。 1997年7月，ECMA 组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。这个版本就是 ECMAScript 1.0 版。之所以不叫 JavaScript，一方面是由于商标的关系，Java 是 Sun 公司的商标，根据一份授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 已经被 Netscape 公司注册为商标，另一方面也是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。 ECMAScript 只用来标准化 JavaScript 这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如 DOM 的标准就是由 W3C组织（World Wide Web Consortium）制定的。 ECMA-262 标准后来也被另一个国际标准化组织 ISO（International Organization for Standardization）批准，标准号是 ISO-16262。 在 HTML 中引入 js在之前学习 css 中有三种引入 css 的方式，那么也有三种引入 js 的方式。 行间式 1&lt;div id="ddd" onmouseover="this.style.color ='red'" onmouseleave="this.style.color = 'blue'"&gt;这是行间式 js 的 div&lt;/div&gt; 特点： 行间式代码块书写在一个个全局事件名属性中，没有 script 这样的一个全局属性； 在某一个标签的某一个事件属性值中，出现的 this 代表该标签； 该标签对象 this 可以访问该标签的任意全局属性。 内联式 123&lt;script&gt; ddd.style.backgroundColor = 'pink'&lt;/script&gt; 特点： 可以通过标签的 id（唯一标识），在 js 代码块中访问到该标签（js 选择器）； js 代码块中语法采用的是小驼峰命名法，属性的值都是用字符串形式进行复制； js 属于解释型语言，加载顺序会影响执行结构。 外联式 1234&lt;script src="js/01.js"&gt; // 被屏蔽掉的代码块 ddd.style.fontSize = '100px';&lt;/script&gt; 特点： 通过 script 标签的 src 数据连接外部 js 文件； 使用外联的 script（拥有 src 属性）标签，会屏蔽掉标签内部的 js 代码块； 在 js 的任意地方，均有 this对象，this 对象不指向任何标签时，指向的是 window 对象。 在 js 中定义变量四种定义变量的方式12345678910111213141516171819语法: 关键词 变量名 = 变量值num = 10; // 省略关键词, 定义的为全局变量, 在任何位置定义, 在任何位置都可以访问, 但不建议使用var num = 10; // var关键词, 无块级作用域, 定义在块级作用域中的变量, 外界也可以访问let num = 20; // let关键词, 有块级作用域, 定义在块级作用域中的变量, 外界无法访问const NUM = 30; // const关键词,有块级作用域, 定义在块级作用域中的变量, 外界无法访问, 且变量的值不能再被二次修改, 所以为常量/* 产生块级作用域的方式&#123; 直接书写&#125;if语句可以产生while语句可以产生for语句也可以产生*/// 函数可以产生局部作用域, 除了定义在局部作用域中的全局变量(没有关键字的变量声明), 外界可以访问, 其他定义方式, 外界都不可以访问// ES5 | ES6// 是ECMAScript两个语法版本, ES6是ES5之后的一个版本, 但是对ES5向下兼容, ES6中支持ES5语法 命名规范12345678// 命名规范// 变量命名规范// 可以由哪些组成: 字母, 数字, _, $, 中文(一般不考虑)// 可以以什么开头: 字母, _, $, 中文// 不能出现什么: 关键字, 保留字// 提倡什么书写规范: 小驼峰, 支持_连接语法好的 = "真好";console.log(好的); 数据类型值类型 number 类型 12345678var num = 10; // 类型, 值 console.log(typeof(num), num) // 判断方式 console.log(typeof num == 'number'); num = 3.14; console.log(typeof(num), num); string类型 1234var str = '单引号字符串'; console.log(typeof(str), str); str = "双引号字符串"; console.log(typeof(str), str); boolean 类型 1234var res = true; console.log(typeof(res), res); res = false; console.log(typeof(res), res); undefined 类型 123console.log(typeof(abc), abc); var abc = undefined; console.log(typeof(abc), abc); 引用类型 function 类型 12var fn = function (a, b) &#123; return a + b; &#125;; console.log(typeof(fn), fn); object 类型（类字典方式来使用） 123456var obj = &#123; name: 'egon', age: 78 &#125;; console.log(typeof(obj), obj); console.log(obj instanceof Object); 其他形式对象 null 类型 123var xyz = null; console.log(typeof(xyz), xyz); // object null console.log(xyz instanceof Object); // false =&gt; Null类型 具体的对象类型 Array 类型 123456var a = new Array(1, 2, 3, 4, 5); console.log(a, typeof a); // 判断方式 console.log(typeof a == 'object'); console.log(a instanceof Object); console.log(a instanceof Array); Date 类型 123456var a = new Date(); console.log(a, typeof a); // 判断方式 console.log(typeof a == 'object'); console.log(a instanceof Object); console.log(a instanceof Date); RegExp 类型 12345678910var a = new RegExp('a'); a = /[abc]/; console.log(a, typeof a); // 判断方式 console.log(typeof a == 'object'); console.log(a instanceof Object); console.log(a instanceof RegExp) // 使用正则 console.log('abc'.match(a)) 数据类型之间的转换 number 与 boolean 类型 123// boolean类型的true就是数字1, false就是数字0 console.log((true + true) * 10 * false) // number 中 0, NaN 可以直接当false来使用, 其他的都可以当true来使用 string,boolean 转换为 number 123456789101112131415161718192021var a = '10'; // =&gt; 10 a = '3.14'; // =&gt; 3.14 a = '3.14.15'; // =&gt; NaN var b = true; var n1 = Number(a); console.log(n1) var n2 = Number(b); console.log(n2) a = '3.14.15'; // 3.14 a = 'a3.14'; // NaN console.log(parseFloat(a)); a = '3.94.15'; // 3 console.log(parseInt(a)); // 体现弱语言类型 a = '10'; var res = +a; // number 10 console.log(typeof(res), res) number,string 转换为 boolean 123456789// 在分支或循环判断中, 系统会将数字与字符串类型自动转换为布尔类型 // 不在判断中, 如何转换 console.log(Boolean("")); console.log(Boolean(0)); console.log(Boolean(NaN)); console.log(Boolean(null)); console.log(Boolean("1")); console.log(Boolean(-100)); number,boolean 转换为 string 1234567891011121314151617181920console.log(String(true)); console.log(String(1)); var a = 123; console.log(a.toString()); console.log(123..toString()); console.log(3.14.toString()); var c = 123 + ""; console.log(typeof c, c); // 用例 var z1 = 2 + +"5"; // 7 z1 = 2 + "5"; // "25" // z1 = 2 ++"5"; // 语法错误 ++连在一起是 ++语法(了解) var z2 = "5" - 2; // 3 console.log(z1, z2); // 补充 // NaN与NaN不相等 总结一.JS三个组成部分 ES: ECMAScript语法 DOM: document对象模型 =&gt; 通过js代码与页面文档(出现在body中的所有可视化标签)进行交互 BOM: borwser对象模型 =&gt; 通过js代码与浏览器自带功能进行交互 二.引入方式 行间式 12出现在标签中的全局事件属性中this代表该标签, 可以访问全局属性, 再访问具体操作对象(eg: this.style.color = &quot;red&quot;) 内联式 123出现在script脚本标签中可以通过标签的id唯一标识,在js代码块中操作页面标签js采用的是小驼峰命名规范, 属于解释性语言(由上至下依次解释执行) 外联式 12通过script标签的src属性链接外部js文件, 链接后, script标签本身内部的js代码块将会被屏蔽在任何位置都可以使用this对象,当this对象不指向任意一个标签时,代表的是window对象 js具体出现的位置 12head标签的底部: 依赖性js库body标签的底部(body与html结束标签的之间): 功能性js脚本 三.变量的定义123456789101112131415161718四种定义变量的方式语法: 关键词 变量名 = 变量值num = 10; // 省略关键词, 定义的为全局变量, 在任何位置定义, 在任何位置都可以访问, 但不建议使用var num = 10; // var关键词, 无块级作用域, 定义在块级作用域中的变量, 外界也可以访问let num = 20; // let关键词, 有块级作用域, 定义在块级作用域中的变量, 外界无法访问const NUM = 30; // const关键词,有块级作用域, 定义在块级作用域中的变量, 外界无法访问, 且变量的值不能再被二次修改, 所以为常量/* 产生块级作用域的方式&#123; 直接书写&#125;if语句可以产生while语句可以产生for语句也可以产生*/// 函数可以产生局部作用域, 除了定义在局部作用域中的全局变量(没有关键字的变量声明), 外界可以访问, 其他定义方式, 外界都不可以访问 12// ES5 | ES6// 是ECMAScript两个语法版本, ES6是ES5之后的一个版本, 但是对ES5向下兼容, ES6中支持ES5语法 12345678// 命名规范// 变量命名规范// 可以由哪些组成: 字母, 数字, _, $, 中文(一般不考虑)// 可以以什么开头: 字母, _, $, 中文// 不能出现什么: 关键字, 保留字// 提倡什么书写规范: 小驼峰, 支持_连接语法好的 = "真好";console.log(好的); 四.三种弹出框12345678910// 普通弹出框// alert("你丫真帅!!!");// 输入框: 以字符串形式接收用户输入内容// var info = prompt("请输入内容:");// console.log(info)// 确认框: 根据用户选择确认或取消, 得到 true | false 两个布尔结果// var res = confirm("你是猪吗?");// console.log(res) 五.数据类型123456789101112// 值类型var a = 10; // Number 10var a = 'abc'; // String abcvar a = true; // Boolean truevar a = undefined // undefined undefined// 引用类型var a = function()&#123;&#125; // function f()&#123;&#125;var a = &#123;&#125; // Object &#123;&#125;var a = null // Null null// 其他Object具体体现Array | Date | RegExp 六.值类型的类型转换12345678910// 1.通过类型声明转换Number() | String() | Boolean()// 2.方法(函数)parseInt('10') | parseFloat('3.14')123..toString()// 3.隐式转换+'10' =&gt; 10'' + 10 =&gt; '10']]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端（九） 之表格的使用]]></title>
    <url>%2F2018%2F12%2F17%2F%E5%89%8D%E7%AB%AF%EF%BC%88%E4%B9%9D%EF%BC%89-%E4%B9%8B%E8%A1%A8%E6%A0%BC%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前端之表格的使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;表格&lt;/title&gt; &lt;style type="text/css"&gt; .table1 &#123; width: 500px; height: 500px; display: none; &#125; th, td &#123; padding: 20px; &#125; .table2 td &#123; /*border: 10px solid black;*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- table的display: table --&gt; &lt;!-- table显示规则注意点: 当设置的盒子高度不足够显示内容时, 盒子高度由内容撑开, 当设置的高度大于显示内容所需高度,采用设置的高度 --&gt; &lt;!-- border: 设置边框宽度 --&gt; &lt;!-- cellspacing: 单元格间的间距 --&gt; &lt;!-- cellpadding: 单元格的内边距 == th, td设置padding --&gt; &lt;table class="table1" border="1" cellspacing="0"&gt; &lt;!-- tr&gt;th&#123;标题&#125;*3 --&gt; &lt;tr&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;/tr&gt; &lt;!-- (tr&gt;td&#123;单元格&#125;*3)*3 --&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;!-- 边框的保留格式 =&gt; rules: rows | cols | groups | all --&gt; &lt;table class="table2" border="10" rules="all"&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td rowspan="2"&gt;单元格&lt;/td&gt; &lt;td rowspan="2" colspan="2"&gt;单元格&lt;/td&gt; &lt;!-- &lt;td&gt;单元格&lt;/td&gt; --&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!-- &lt;td&gt;单元格&lt;/td&gt; --&gt; &lt;!-- &lt;td&gt;单元格&lt;/td&gt; --&gt; &lt;!-- &lt;td&gt;单元格&lt;/td&gt; --&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td colspan="2"&gt;单元格&lt;/td&gt; &lt;!-- &lt;td&gt;单元格&lt;/td&gt; --&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; &lt;!-- &gt;&gt;&gt; display: table-cell =&gt; 可以嵌入任意类型标签, 可以快速实现多行文本垂直居中 --&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端（八）之形变]]></title>
    <url>%2F2018%2F12%2F17%2F%E5%89%8D%E7%AB%AF%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E5%BD%A2%E5%8F%98%2F</url>
    <content type="text"><![CDATA[前端之形变一.形变1234567891011121314/*1.形变参考点: 三轴交界点*/transform-origin: x轴坐标 y轴坐标;/*2.旋转 rotate deg*/transform: rotate(720deg);/*偏移 translate px*/transform: translateX(200px) translateY(200px);/*缩放 scale 无单位*/transform: scale(x轴比例, y轴比例)/*注: 可以多形变, 空格隔开书写在一条transform属性中, 顺序一般会影响形变结果*//*形变不改变盒子布局, 只拿形变做动画*/ 二.动画animation12345678910111213141516171819202122232425/*1.设置动画体*/@keyframes move &#123; /*起点省略采用的就是初始状态*/ 0% &#123;&#125; 33.3% &#123; margin-left: 800px; /*在每一个动画节点都需要明确所有做动画属性在该节点的属性值*/ margin-top: 50px; &#125; 66.6% &#123; margin-left: 500px; margin-top: 300px; &#125; /*终点需要设置*/ 100% &#123; margin-left: 200px; margin-top: 50px; &#125;&#125;/*2.设置动画属性*//*animation: 动画名 时间 运动次数(无限次:infinite) 运动曲线*/.box &#123; animation: move 2s 1 linear;&#125; 三.表格1234567891011121314151617181920212223242526272829303132333435363738&lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt;table的全局属性:border="1" 设置边框宽度cellspacing="10" 单元格间的间距cellpadding="10" 单元格的内边距rules="rows | cols | groups | all" 边框的保留格式td的全局属性rowspan='2' 合并两行单元格colspan='3' 合并三列单元格table的高度: 由内容和设置高度中的大值决定table-cell: 可以嵌套任意类型标签, 可以快速实现多行文本垂直居中 四.多行文本垂直居中1234&lt;div class="sup"&gt; &lt;p&gt;第一行文本&lt;/p&gt; &lt;div&gt;第二行文本&lt;/div&gt;&lt;/div&gt; 12345678.sup &#123; /*实现多行文本垂直居中 =&gt; 针对父级设置, 父级中的多个块级文本类子级标签垂直居中*/ display: table-cell; vertical-align: middle;&#125;/*注: 如果想调整sup的位置,可以给sup嵌套一个"位置层"*//*.box&gt;.sup&gt;p+div*/]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端（七）之动画与阴影]]></title>
    <url>%2F2018%2F12%2F14%2F%E5%89%8D%E7%AB%AF%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%E5%8A%A8%E7%94%BB%E4%B8%8E%E9%98%B4%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[动画及阴影一.拼接网页1234将区域整体划分起名 =&gt; 对其他区域布局不产生影响提出公共css =&gt; reset操作当有区域发送显示重叠(脱离文档流导致的), 需要通过z-index调整层级一定需要最外层,且最外层做自身布局时,不要做过多布局操作 二.过渡12345transition属性transition: 过渡时间(必须) 延迟时间(一般不设) 过渡属性(一般采用all默认值) 过渡曲线(贝赛尔曲线)(cubic-bezier())过渡属性具体设置给初始状态还是第二状态 根据具体需求 12345678910/*过渡的持续时间*/transition-duration: 2s;/*延迟时间*/transition-delay: 50ms;/*过渡属性*//*单一属性 | 属性1, ..., 属性n | all*/transition-property: all;/*过渡曲线*//*cubic-bezier() | ease | ease-in | ease-out | ease-in-out | linear*/transition-timing-function: cubic-bezier(0, 2.23, 0.99, -1.34); 1234/*结论:*//*1.尽量悬浮静止的盒子, 控制运动的盒子*//*2.不能确定区间范围的属性值, 不会产生动画效果*//*display 不能做动画 | opacity 可以做动画*/ 三.阴影12345/*x轴偏移量 y轴偏移量 虚化程度 阴影宽度 阴影颜色*/box-shadow: 0 0 10px 10px black;/*一个盒子可以设置多个阴影, 每一套阴影间用逗号隔开*/box-shadow: 0 -10px 10px -5px black, 0 10px 10px -5px black; 四.伪类实现边框12345678910111213141516171819202122232425/*自身需要定位*/.box &#123; position: relative;&#125;/*伪类通过定位来完成图层的布局*/.box:before &#123; content: ""; /*完成布局*/ position: absolute; top: 10px; left: 0; /*构建图层*/ width: 1px; height: 100px; background-color: black;&#125;.box:after &#123; content: ""; position: absolute; width: 100px; height: 1px; background-color: black; top: 0; left: 10px;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端（六）之盒模型显隐、定位与流式布局思想]]></title>
    <url>%2F2018%2F12%2F11%2F%E5%89%8D%E7%AB%AF%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%E7%9B%92%E6%A8%A1%E5%9E%8B%E6%98%BE%E9%9A%90%E3%80%81%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[前端之盒模型显隐、定位与流式布局思想盒模型的显隐123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;盒子的显隐&lt;/title&gt; &lt;style type="text/css"&gt; .box, .wrap &#123; width: 200px; height: 200px; background: red; &#125; .wrap &#123; background: orange; &#125; /*display: none; 通过控制盒子的显示方式来隐藏盒子*/ /*该隐藏方式在页面中不占位*/ .box &#123; display: none; &#125; /*opacity: 0; 通过控制盒子的透明度来隐藏盒子*/ /*该隐藏方式在页面中占位*/ .box &#123; /*opacity: 0*/ &#125; /*注: 一般显隐操作的盒子都是采用定位布局*/ /*悬浮父级显示子级*/ body:hover .box &#123; display: block; &#125; /*将盒子藏到屏幕外: 不能通过盒模型布局, 也不建议通过浮动布局, 可以采用定位布局*/ .box &#123; /*margin-top: -208px*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="wrap"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 定位相对定位1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;相对定位布局&lt;/title&gt; &lt;style type="text/css"&gt; /*定位布局的导入*/ /*需求: */ /*1.子级在父级的右下角显示*/ /*2.子级完成布局后,父级做content后,子级不需要重新布局*/ .sup &#123; width: 300px; height: 300px; background: pink; border: 10px solid black; &#125; .sub &#123; width: 50px; height: 50px; background: red; margin-left: auto; margin-top: 150px; &#125; /*能不能有一种定位, 让盒子可以通过上下左右四个方位均操作自身布局 =&gt; 定位布局*/ /*什么是定位布局: 可以通过上下左右四个方位完成自身布局的布局方式*/ .sup &#123; display: none; &#125; &lt;/style&gt; &lt;style type="text/css"&gt; /*相对定位布局*/ .box &#123; width: 200px; height: 200px; background: pink; &#125; .b2 &#123; background: orange &#125; .b1 &#123; /*1.设置定位属性，就会打开定位方位*/ position: relative; /*2.通过定位方位完成布局*/ top: 300px; left: 300px; /*bottom: 100px;*/ /*right: 100px;*/ /*margin-top: 200px;*/ /*结论*/ /*1.左右取左,上下取上(eg:left与right共存是,left生效)*/ /*2.left=-right, top=-bottom*/ /*3.参考系: 自身原有位置(不是某一个点,eg: right参考的就是原有位置的右边界)*/ /*4.自身布局后不会影响自身原有位置*/ /*5.不脱离文档流(脱离文档流: 不再撑开父级高度)*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box b1"&gt;1&lt;/div&gt; &lt;div class="box b2"&gt;&lt;/div&gt; &lt;div class="sup"&gt; &lt;div class="sub"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 绝对定位12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;绝对定位布局&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 200px; height: 300px; background: orange; &#125; .sup &#123; width: 200px; height: 200px; background: pink; /*position: absolute;*/ &#125; .sub &#123; width: 50px; height: 50px; background: red; /*1.开的定位*/ position: absolute; /*2.采用定位方位完成布局*/ right: 0; bottom: 0; &#125; body &#123; position: relative; &#125; /*注: 一般父级采用的是相对定位布局, 一般情况下,父级不需要脱离文档流*/ /*如果父级需要脱离文档流,用绝对定位父级完成布局,完全可以,不会影响子级相对于自身的布局,但是自身又要需要一个在文档流中的(不脱离文档流中的)定位参考父级 =&gt; 父相子绝*/ /*相对定位的应用场景大部分都是辅助于子级的绝对定位*/ .sup &#123; position: relative; &#125; .sub &#123; /*left: 0;*/ right: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 绝对定位布局一定存在父子关系 --&gt; &lt;!-- 导入定位布局时,父级设置宽高没?(设置了) 子级呢?(也设置了) =&gt; 父级的高度不再依赖于子级 =&gt; 子级脱离文档流 --&gt; &lt;!-- 参考系: 最近的定位父级 --&gt; &lt;div class="sup"&gt; &lt;div class="sub"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;div class="box"&gt;&lt;/div&gt; --&gt; &lt;!-- 1.top|bottom|left|right都可以完成自身布局, 上下取上,左右取左 2.父级必须自己设置宽高 3.完全离文档流 --&gt;&lt;/body&gt;&lt;/html&gt; 固定定位123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;固定定位&lt;/title&gt; &lt;style type="text/css"&gt; /*参考系: 页面窗口*/ /*1.top|bottom|left|right都可以完成自身布局, 上下取上,左右取左*/ /*2.相对于页面窗口是静止的*/ /*3.完全脱离文档流*/ .box &#123; width: 200px; height: 300px; background: orange; &#125; .box &#123; position: fixed; top: 200px; right: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;&lt;/body&gt;&lt;/html&gt; z-index 属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;z-index&lt;/title&gt; &lt;style type="text/css"&gt; .wrap &#123; width: 200px; height: 200px; background: pink; /*父级做相对定位处理,并不是自己需要用定位完成布局,最主要的原因是辅助于子级完成绝对定位布局*/ position: relative; &#125; .box &#123; width: 75px; height: 75px; font: normal 30px/75px "STSong"; text-align: center; background: cyan; /*绝对定位需要大家脱离文档流,相互不会影响布局,每个都是独立相对于父级进行布局的个体*/ position: absolute; /*top: 0;*/ /*bottom: 0;*/ /*left: 0;*/ &#125; .b1 &#123; left: 0; top: 0; background: red; &#125; .b2 &#123; right: 0; top: 0; background: yellow; &#125; .b3 &#123; /*虽然子级脱离了文档流,但是父子关系以及存在,子级获取100%,得到的还是父级对应的值*/ left: calc((100% - 75px) / 2); top: calc((100% - 75px) / 2);; background: green; /*z-index改变显示层级, 显示层级的值为正整数, 值越大,显示层级越高*/ z-index: 1; &#125; .b4 &#123; left: 0; bottom: 0; background: blue; /*z-index: 88889;*/ &#125; .b5 &#123; right: 0; bottom: 0; background: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;div class="box b1"&gt;1&lt;/div&gt; &lt;div class="box b2"&gt;2&lt;/div&gt; &lt;div class="box b3"&gt;3&lt;/div&gt; &lt;div class="box b4"&gt;4&lt;/div&gt; &lt;div class="box b5"&gt;5&lt;/div&gt; &lt;/div&gt;`&lt;/body&gt;&lt;/html&gt; 流式布局思想12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;流式布局思想&lt;/title&gt; &lt;style type="text/css"&gt; html, body &#123; margin: 0; width: 100%; /*辅助body内部的子级有height流式布局的基础*/ height: 100%; &#125; /*流式布局思想: 尽可能不去使用固定属性值*/ /*通过父级来获取相应的属性值*/ .b1 &#123; width: 100%; height: 100%; background: red; &#125; .b2 &#123; /*view-width view-height*/ width: 80vw; height: 80vh; background: orange; /*流式布局限制条件: 流式布局下宽度最大只能放大到800px,最小只能缩小到600px*/ max-width: 800px; min-width: 600px; &#125; html &#123; font-size: 200px; &#125; body &#123; font-size: 100px; &#125; span &#123; /*设置自身字体时 em = ?px 父级字体的大小*/ font-size: 2em; display: block; /*宽高em在自身设置字体大小后,值又会更改为相应大小*/ /*eg: body: 100px =&gt; 设置自身字体时em=100px, */ /*自身设置字体大小为2em,自身字体大小为200px =&gt; width=2em的em=200px*/ /*结果自身宽度是400pk*/ /*自身非设置字体时使用em单位,em值取自身字体大小*/ width: 2em; /*rem = html字体的大小*/ height: 2rem; background: red; &#125; &lt;/style&gt; &lt;style type="text/css"&gt; .sup &#123; width: 200px; height: 200px; padding: 50px; background: red; &#125; .sub &#123; /*父级的content是提供给子级盒子利用的*/ margin: 0 5px; border: 5px solid black; padding: 5px; /*auto &lt;= 100%*/ width: auto; /*width: 100%;*/ height: 50px; background: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;div class="b1"&gt;&lt;/div&gt; --&gt; &lt;!-- &lt;div class="b2"&gt;&lt;/div&gt; --&gt; &lt;!-- &lt;span&gt;好的&lt;/span&gt; --&gt; &lt;div class="sup"&gt; &lt;div class="sub"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; hover 父子悬浮1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .sup &#123; width: 120px; height: 40px; background: pink; position: relative; &#125; .sub &#123; width: 120px; height: 100px; background: black; position: absolute; left: 0; top: 40px; display: none; &#125; .sup:hover .sub &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="sup"&gt; &lt;div class="sub"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 总结一.浮动布局的总结121.同一结构下, 如果采用浮动布局,所有的同级别兄弟标签都要采用浮动布局2.浮动布局的盒子宽度在没有设定时会自适应内容宽度 二.盒子的显隐12345display: none;在页面中不占位, 采用定位布局后, 显示隐藏都不会影响其他标签布局, 不需要用动画处理时opacity: 0;在页面中占位, 采用定位布局后, 显示隐藏都不会影响其他标签布局, 需要采用动画处理时 三.定位布局1什么是定位布局: 可以通过上下左右四个方位完成自身布局的布局方式 相对定位 123456参考系: 自身原有位置position: relative; =&gt; 打开了四个定位方位1.top|bottom|left|right都可以完成自身布局, 上下取上,左右取左2.left = -right | top = -bottom3.布局后不影响自身原有位置4.不脱离文档流 绝对定位 12345参考系: 最近的定位父级position: absolute; =&gt; 打开了四个定位方位1.top|bottom|left|right都可以完成自身布局, 上下取上,左右取左2.父级必须自己设置宽高3.完全离文档流 固定定位 12345参考系: 页面窗口position: fixed; =&gt; 打开了四个定位方位1.top|bottom|left|right都可以完成自身布局, 上下取上,左右取左2.相对于页面窗口是静止的3.完全脱离文档流 z-index 1修改显示层级(在发生重叠时使用), 值取正整数, 值不需要排序随意规定, 值大的显示层级高 四.流式布局思想1231. 百分比2. vw | vh =&gt; max-width(height) | min-width(height)3. em | rem]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端（五）之浮动]]></title>
    <url>%2F2018%2F12%2F10%2F%E5%89%8D%E7%AB%AF%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[前端之浮动布局、清浮动display 总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;display 总结&lt;/title&gt; &lt;style type="text/css"&gt; /*1. 同行显示，就相当于纯文本，当一行显示不下，那么显示不下的（字）就会自动换行，和纯文本的区别就是有标签整体的概念，标签与标签间有一个空格的隔断*/ /*2. 支持部分 css 样式，不支持宽高 | 不支持行高，行高会映射到父级 block 标签 | 不支持 margin 上下*/ /*3. content 由文本内容撑开*/ /*4. inline 标签只嵌套 inline 标签*/ abc &#123; display: inline; background-color: orange; width: 200px; height: 200px; /*line-height: 300px;*/ margin-top: 30px; margin-bottom: 30px; &#125; &lt;/style&gt; &lt;style type="text/css"&gt; /*1. 同行显示，就相当于纯文本，标签会作为一个整体换行显示*/ /*2. 支持所有 css 样式，*/ /*3. content 默认由文本（图片）内容撑开，也可以自定义宽高，当自定义宽高后一定会采用自定义宽高（显示区域不足，内容会在标签内部换行显示，可能超出显示区域）*/ /*4. inline-block 标签不建议嵌套任意标签*/ .d2 &#123; background: pink; &#125; def &#123; display: inline-block; background: blue; width: 200px; height: 200px; &#125; &lt;/style&gt; &lt;style type="text/css"&gt; /*1. 异行显示，不管自身区域多大都会独占一行*/ /*2. 支持所有css 样式，*/ /*3. width默认继承父级，height由内容（文本、图片、子标签）撑开，当设置自定义宽高后一定采用自定义宽高*/ /*4. block 标签可以嵌套任意标签*/ .d3 &#123; background: brown; &#125; opq &#123; display: block; background: cyan; width: 20px; height: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="d2"&gt; &lt;abc&gt; 自定义标签&lt;/abc&gt; &lt;abc&gt; 自定义标签&lt;/abc&gt; &lt;abc&gt; 自定义标签&lt;/abc&gt; &lt;/div&gt; &lt;div class="d2"&gt; &lt;def&gt;自定义标签&lt;/def&gt; &lt;def&gt;自定义标签&lt;/def&gt; &lt;def&gt;自定义标签&lt;/def&gt; &lt;/div&gt; &lt;div class="d3"&gt; &lt;opq&gt;自定义标签&lt;/opq&gt; &lt;opq&gt;自定义标签&lt;/opq&gt; &lt;opq&gt;自定义标签&lt;/opq&gt; &lt;/div&gt; &lt;!-- inline-block 不建议作为结构|布局层理由 --&gt; &lt;style type="text/css"&gt; xyz &#123; display: inline-block; width: 200px; height: 200px; background: yellow; &#125; xyz &#123; /*文本垂直方向控制属性*/ vertical-align: top; &#125; .x2 &#123; line-height: 200px; &#125; &lt;/style&gt; &lt;div class="d4"&gt; &lt;xyz class="x1"&gt;一段文本&lt;/xyz&gt; &lt;xyz class="x2"&gt;两段文本&lt;/xyz&gt; &lt;xyz class="x3"&gt;三段文本三段文本三段文本三段文本三段文本三段文本三段文本三段文本三段文本三段文本三段文本三段文本三段文本&lt;/xyz&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; overflow在处理超出内容中的应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;overflow&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 50px; height: 100px; &#125; .d1 &#123; background: red; &#125; .d2 &#123; background: orange; &#125; .d2 &#123; /*margin-top: -50px;*/ &#125; &lt;/style&gt; &lt;style type="text/css"&gt; .b1 &#123; background: yellow; /*overflow:处理内容超出盒子显示区域*/ /* auto：自适应，内容超出，滚动显示超出部分，不超出则正常显示*/ /*scroll：一直采用滚动方式显示*/ /*overflow: scroll;*/ /*hidden：隐藏超出盒子显示范围的内容*/ overflow: hidden; &#125; /*注：根据文本的具体超出范围，横向纵向均可能出现滚动条*/ .b2 &#123; background: cyan; overflow: scroll; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 文本层要高于背景层 --&gt; &lt;div class="d1"&gt;我是文本我是&lt;/div&gt; &lt;div class="d2"&gt;我是文本我是&lt;/div&gt; &lt;!-- 问题：内容（文本、图片、子标签）会超出盒子的显示区域 --&gt; &lt;div class="b1"&gt;我是文本我是我是文本我是我是文本我是我是文本我是我是文本我是&lt;/div&gt; &lt;div class="b2"&gt;sdfsafafasdfafasdfsdfsafafasdfafasdfsdfsafafasdfafasdfsdfsafafasdfafasdfsdfsafafasdfafasdf&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 浮动浮动布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;浮动布局&lt;/title&gt; &lt;style type="text/css"&gt; .temp &#123; width: 200px; height: 200px; background: orange; /*Box自身水平方向的位置由margin左或右决定(具体已经参照BFC方位)，属于同一个BFC的两个相邻Box的margin会发生叠加。*/ margin-right: 100px; float: right; &#125; /*&lt;!-- float：浮动布局，改变 bfc 的参照方位，就可以改变盒子的排列方式 --&gt;*/ /*&lt;!-- 为什么要使用：块级盒子就会同行显示 --&gt;*/ /*float: left | right*/ .box &#123; width: 100px; height: 100px; background: orange; font: 900 40px/100px 'STSong'; text-align: center; &#125; .box:nth-child(2n) &#123; background: red; &#125; .box &#123; float: left; &#125; /*注：浮动布局的横向显示范围由父级width 决定，当一行显示不下时会自动换行，排列方式（起点）还是遵循 BFC 参照方位 =&gt; 固定了父级width 也就固定了浮动布局的行数*/ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="temp"&gt;&lt;/div&gt; &lt;div class="wraper"&gt; &lt;div class="box"&gt;1&lt;/div&gt; &lt;div class="box"&gt;2&lt;/div&gt; &lt;div class="box"&gt;3&lt;/div&gt; &lt;div class="box"&gt;4&lt;/div&gt; &lt;div class="box"&gt;5&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 清浮动1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;清浮动&lt;/title&gt; &lt;style type="text/css"&gt; .outter &#123; /*height: 200px;*/ background: orange; &#125; /*清浮动：让父级（有浮动子级）获得一个合适的高度*/ /*子标签设置浮动 =&gt; 导致子标签不完全脱离文档流*/ /*脱离文档流：产生了新的 BFC，（不再关联父级宽高）*/ /*浮动的子级，默认不会获取父级宽度，也不会撑开父级高度*/ /*不完全：父级在做清浮动操作后，可以重新被子级撑开高度*/ /*当父级没有下兄弟标签可以不做清浮动，但清浮动操作应该在每一次发生浮动后均需要处理*/ .inner &#123; width: 200px; height: 200px; background: red; float: left; border-radius: 50%; &#125; /*清浮动操作*/ .outter:after &#123; content: ''; display: block; clear: both; &#125; .box &#123; width: 200px; height: 200px; background: cyan; &#125; &lt;/style&gt; &lt;style type="text/css"&gt; /*盒子先加载 before，在加载自身（文本、图片、子标签），最后加载after*/ .div:before &#123; content: '123'; &#125; .div:after &#123; content: '456'; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 清浮动：清除浮动导致的布局问题 --&gt; &lt;div class="outter"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="div"&gt;原文本&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 清浮动方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;清浮动方式&lt;/title&gt; &lt;style type="text/css"&gt; .sub, .box &#123; width: 200px; height: 200px; background: orange; &#125; .box &#123; background: red; &#125; .sub &#123; float: left; &#125; /*1. 设置死高度*/ .sup &#123; /*height: 200px;*/ &#125; /*2. overflow*/ .sup &#123; background: cyan; overflow: hidden; &#125; /*3. 兄弟标签清浮动*/ .box &#123; /*clear: left;*/ clear: both; &#125; /*4. 伪类清浮动*/ .sup &#123; content: ''; display: block; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 清浮动：使父级获取一个合适高度 --&gt; &lt;!-- 通常情况下在子级浮动，父级不会被撑开高度在该问题发生之后做清浮动操作 --&gt; &lt;!-- 在发生浮动之前，可以通过设置父级的高度来避免浮动问题。--&gt; &lt;div class="sup"&gt; &lt;div class="sub"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;style type="text/css"&gt; .bb &#123; width: 100px; /*手动设置了死高度，才会产生超出高度的内容为无用内容*/ /*height: 50px;*/ background: pink; overflow: hidden; &#125; &lt;/style&gt; &lt;div class="bb"&gt;hao&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 总结一 display 总结1234567891011121314151617/* inline */ /*1. 同行显示，就相当于纯文本，当一行显示不下，那么显示不下的（字）就会自动换行，和纯文本的区别就是有标签整体的概念，标签与标签间有一个空格的隔断*/ /*2. 支持部分 css 样式，不支持宽高 | 不支持行高，行高会映射到父级 block 标签 | 不支持 margin 上下*/ /*3. content 由文本内容撑开*/ /*4. inline 标签只嵌套 inline 标签*//* inline-block */ /*1. 同行显示，就相当于纯文本，标签会作为一个整体换行显示*/ /*2. 支持所有 css 样式，*/ /*3. content 默认由文本（图片）内容撑开，也可以自定义宽高，当自定义宽高后一定会采用自定义宽高（显示区域不足，内容会在标签内部换行显示，可能超出显示区域）*/ /*4. inline-block 标签不建议嵌套任意标签*//* block */ /*1. 异行显示，不管自身区域多大都会独占一行*/ /*2. 支持所有css 样式，*/ /*3. width默认继承父级，height由内容（文本、图片、子标签）撑开，当设置自定义宽高后一定采用自定义宽高*/ /*4. block 标签可以嵌套任意标签*/ 二 overflow 知识123456789/* overflow：处理内容超出盒子显示区域 */overflow: auto | scroll | hidden /*overflow:处理内容超出盒子显示区域*/ /* auto：自适应，内容超出，滚动显示超出部分，不超出则正常显示*/ /*scroll：一直采用滚动方式显示*/ /*overflow: scroll;*/ /*hidden：隐藏超出盒子显示范围的内容*/ /*注：根据文本的具体超出范围，横向纵向均可能出现滚动条*/ 三 浮动布局12/*float：浮动布局，改变 bfc 的参照方位，就可以改变盒子的排列方式 *//*为什么要使用：块级盒子就会同行显示 */ 123float: left | right; 左 | 右 浮动/*left: BFC 参照方向从左向右*//*right: BFC 参照方向从右向左*/ 1/*浮动的区域由父级的 width 决定*/ 四 清浮动123浮动问题：子级浮动了，不再撑开父级的高度，那么父级如果拥有兄弟标签可能就会出现布局重叠清浮动：解决上面的问题，通过使父级获取一个合适的高度，这样子级就不会和父级的兄弟布局发生重叠清浮动的本质是：left | right | both 12345678910111213/* 清浮动的四种方式*/1. 设置腹肌的死高度2. 通过兄弟设置 clear: both3. 设置父级 overflow 属性为 hidden .sup &#123; overflow: hidden; &#125;4. 通过父级: after 伪类 .sup &#123; content: ''; display: block; clear: both; &#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端（四）]]></title>
    <url>%2F2018%2F12%2F07%2F%E5%89%8D%E7%AB%AF%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前端之常用标签的使用、边界圆角、精灵图以及盒模型的布局前言上篇博客介绍了组合选择器，包括四种，分别是群组选择器、后代（子代）选择器、兄弟（相邻选择器）及交集选择器；a 标签的四大伪类选择器，a:link、a:hover、a:active、a:visited，其中 hover 和 active 也可以用于其他标签，索引选择器包括三种 123456&lt;!-- 先位置后类型 --&gt;div:nth-child(1) &lt;!-- 先类型后位置 --&gt;div:nth-of-type(1)&lt;!-- 取反，先找到有 abc 和 div 类的标签，然后取反--&gt;.div:not([abc]) 最后介绍了最最重要的盒模型，盒模型由四部分组成由内到外分别是：content+padding+border+margin，其中 content+padding+border 参与盒子显示，margin 参与盒子布局。 常用标签的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;常用标签的使用&lt;/title&gt; &lt;!-- SEO --&gt; &lt;!-- &lt;meta name="keywords" content="8-12个以英文逗号隔开的单词或词语"&gt; --&gt; &lt;!-- &lt;meta name="description" content="80字以内的一段话，与网站内容相关"&gt; --&gt; &lt;!-- 移动适配 --&gt; &lt;!-- &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; --&gt; &lt;link rel="icon" type="image/x-icon" href="http://www.baidu.com/favicon.ico"&gt; &lt;style type="text/css"&gt; .img &#123; /*根据需求,是指定高还是指定宽,设置一个,另一个会等比缩放*/ /*width: 200px;*/ height: 100px; &#125; /*四个伪类*/ /*reset操作*/ a &#123; color: #333; text-decoration: none; &#125; /*ul的reset操作*/ ul &#123; margin: 0; padding: 0; list-style: none; /*margin-left: 40px;*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 1.设置锚点: 锚点名page_top --&gt; &lt;a href="" name="page_top"&gt;&lt;/a&gt; &lt;img class="img" src="./img/timg.jpg" alt=""&gt; &lt;a href="00_复习预习.html"&gt;前往00页面&lt;/a&gt; &lt;!-- 前往本页面中个某个位置: Top =&gt; 锚点 --&gt; &lt;!-- 1.设置锚点 2.设置前往锚点的a转跳 --&gt; &lt;ul&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;/ul&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;!-- 通配标签页可以设置锚点 --&gt; &lt;!-- &lt;a href="" name="t_123"&gt;&lt;/a&gt; --&gt; &lt;div id="t_123"&gt;123&lt;/div&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;!-- 2.设置前往锚点的a转跳: #锚点名 --&gt; &lt;a href="#page_top"&gt;Top&lt;/a&gt; &lt;a href="#t_123"&gt;123&lt;/a&gt; &lt;a href="00_复习预习.html#md"&gt;前往锚点&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 边界圆角123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;边界圆角&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 200px; height: 200px; background-color: orange; &#125; .box &#123; /*边界圆角*/ /*百分比控制*/ /*border-radius: 50%;*/ /*实际像素控制*/ /*border-radius: 20px;*/ /*横纵分离 横 / 纵*/ /*border-radius: 20px / 50%;*/ /*左上为第一个角, 顺时针赋值, 无值找对角*/ /*左上横30px 右上横100px 右下横=左上横 左下横=右上横, 四角纵向全是50%*/ /*border-radius: 30px 100px / 50%;*/ /*单独设置时, 横向 纵向*/ /*border-top-left-radius: 50% 100%; border-top-right-radius: 50% 100%;*/ border-radius: 50% 50% 0 0 / 100% 100% 0 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 背景样式12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;背景样式&lt;/title&gt; &lt;style type="text/css"&gt; .box, .wrap &#123; width: 200px; height: 200px; background-color: orange; &#125; .wrap &#123; /*图片过大会显示不全*/ background-image: url('img/timg.jpg'); /*规定背景图片显示尺寸*/ background-size: 200px 200px; &#125; .box &#123; /*图片过小会平铺*/ background-image: url('img/123.png'); /*平铺:repeat-x | repeat-y | repeat | no-repeat*/ background-repeat: no-repeat; /*位置(定位): 可以写具体数值,也可以写位置单词*/ /*background-position: 10px center;*/ /*background-position: right bottom;*/ /*background-position: center center;*/ /*设置一个值时,控制的是x轴,y轴取center*/ /*设置;两个值时,第一个值控制x,第二个值控制y*/ background-position: 10px 40px; /*整体设置*/ background: url('img/123.png') red no-repeat 50px 50px; &#125; /*注: 实际开发中,资源图片大小一定要与显示区域等大*/ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="img/123.png" alt=""&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="wrap"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 精灵图12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;精灵图&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 500px; height: 100px; /*height: 300px;*/ border: 5px solid black; &#125; .box &#123; background-image: url('img/bg.png'); background-position: 0 -150px; &#125; .box:hover &#123; cursor: pointer; background-position: 0 -250px; &#125; /*1.显示区域一定要与精灵图目标小图大小一致*/ /*2.通过背景图片定位方式将目标小图移至显示位置*/ &lt;/style&gt; &lt;style type="text/css"&gt; .lt1 &#123; width: 155px; height: 48px; background: url('img/bg.png') no-repeat 0 0; &#125; .lt1:hover &#123; cursor: pointer; background: url('img/bg.png') no-repeat 0 -48px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 精灵图: 各种小图拼接起来的一张大图 --&gt; &lt;!-- 为什么使用精灵图: 减少请求次数, 降低性能的消耗, 二次加载图片资源时极为迅速(不在需要发送请求) --&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="lt1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 盒模型布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;盒模型布局细节&lt;/title&gt; &lt;style type="text/css"&gt; .sup &#123; width: 500px; height: 100px; background: orange; &#125; .sub &#123; width: 50px; height: 50px; background-color: red; &#125; /*sub在sup中 水平居中*/ .sub &#123; /*margin-left: auto; margin-right: auto;*/ margin: 0 auto; &#125; /*垂直居中*/ .sub &#123; margin-top: 24px; &#125; /*margin坑: 父子联动*/ /*.box &#123; width: 1px; height: 1px; &#125;*/ /*解决一: 设置border-top*/ .sup &#123; /*border-top: 1px solid transparent; height: 99px;*/ &#125; /*解决二: 设置padding-top*/ .sup &#123; padding-top: 1px; height: 99px; &#125; /*margin坑: 上兄弟margin-bottom与下兄弟margin-top重合, 取大值*/ /*解决方案: 只设置一个,建议设置下兄弟margin-top*/ /*margin布局: 下盒子的垂直起始位置决定于同结构中上盒子的margin结束位置;水平起始位置就是父级content最左侧*/ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="sup"&gt; &lt;!-- &lt;div class="box"&gt;&lt;/div&gt; --&gt; &lt;div class="sub"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端（三）]]></title>
    <url>%2F2018%2F12%2F06%2F%E5%89%8D%E7%AB%AF%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前端之 CSS 选择器高级与盒模型前言先回顾昨日的内容，昨天讲了 w3c 的整个架构，由结构层&gt;布局层&gt;内容层三部分组成，了解了 CSS 的三种引入方式，行间式最简单直接；内联式解耦合，可读性强；外联式适合团队高效开发，耦合性低，复用性强，了解了三种选择器，并且 id 选择器&gt;类选择器&gt;标签选择器&gt;通配选择器，还有通过多类名选择器来操作标签。还有常用的长度单位包括 px、cm、mm、em、vw、in，颜色属性有 rgb、rgba 等，还有操作文本样式的属性调整字体大小，字体风格，文本对齐，缩进，字间距，词间距等，其中 font 是综合性描述：font: 风格 大小/行高 字族（风格可以省略），比如font: 100 normal 60px/200px ‘STSong’;最后讲的就是 display，这是一个重点难点，display 目前只介绍了三个属性值：inline：不支持宽高，宽高由文本内容撑开，只能嵌套 inline 标签同行显示；block：像 p 标签，h 标签的 display 属性就是 block，支持所有的 css 样式，默认有宽高（自定义后取自定义值），能嵌套所有标签，异行显示；inline-block：支持所有css 样式，默认没有宽高（由内容撑开（可以自定义宽高））不建议嵌套任意标签，同行显示。 选择器高级组合选择器群组选择器群组选择器可以同时控制多个选择器，语法：逗号分隔，控制多个1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset='utf-8'&gt; &lt;title&gt;群组选择器&lt;/title&gt; &lt;style type='text/css'&gt; .d1,div,#a &#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='d1'&gt;001&lt;/div&gt; &lt;div&gt;002&lt;/div&gt; &lt;div id='d3'&gt;003&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 一次性控制多个选择器 选择器之间以,隔开，每一个选择器位均可以为任意合法选择器或选择器组合 子代(后代)选择器12345678子代选择器用&gt;连接body &gt; div &#123; color: red;&#125;后代选择器用空格连接.sup .sub &#123; color: red;&#125; 一次性控制一个选择器(逻辑最后的那个选择器)，前置位的选择器为修饰性选择器 每一个选择器位均可以为任意合法选择器或选择器组合 子代选择器必须为一级父子嵌套关系，后代选择器可以为一级及多级父子嵌套关系 相邻(兄弟)选择器12345678相邻选择器用+连接.d1 + .d2 &#123; color: red;&#125;兄弟选择器用~连接.d1 ~ .d3 &#123; color: red;&#125; 一次性控制一个选择器(逻辑最后的那个选择器)，前置位的选择器为修饰性选择器 每一个选择器位均可以为任意合法选择器或选择器组合 相邻选择器必须为直接相邻关系，兄弟选择器可以为直接相邻或间接相邻关系 交集选择器123456789&lt;div class="d" id="dd"&gt;&lt;/div&gt;div.d#dd &#123; color: red;&#125;&lt;div class="d1 d2 d3"&gt;&lt;/div&gt;.d1.d2.d3 &#123; color: red;&#125; 组合选择器优先级 组合选择器优先级与权值相关，权值为权重和 权重对应关系 选择器 权重 通配 1 标签 10 类、属性 100 id 1000 !important 10000 选择器权值比较，只关心权重和，不更新选择器位置 不同级别的选择器间不具备可比性：1个类选择器优先级高于n个标签选择器的任意组合 属性选择器 [attr]：匹配拥有attr属性的标签 [attr=val]：匹配拥有attr属性，属性值为val的标签 [attr^=val]：匹配拥有attr属性，属性值以val开头的标签 [attr$=val]：匹配拥有attr属性，属性值以val结尾的标签 [attr*=val]：匹配拥有attr属性，属性值包含val的标签 v_hint：属性选择器权重等价于类v_test：掌握所有选择器，并熟知选择器优先级伪类选择器1、a标签四大伪类 :link：未访问状态 :hover：悬浮状态 :active：活跃状态 :visited：已访问状态 2、内容伪类 :before：内容之前 :after：内容之后 123:before, :after &#123; content: "ctn";&#125; 3、索引伪类 :nth-child(n)：位置优先，再匹配类型 :nth-of-type(n)：类型优先，再匹配位置 v_hint：值可以为位置数，也可以为2n、3n…，代表2的倍数，3的倍数，且位置数从1开始4、取反伪类 :not(selector)：对selector进行取反 ##盒模型 ###盒模型概念 广义盒模型：文档中所有功能性及内容性标签，及文档中所有显示性标签 侠义盒模型：文档中以块级形式存在的标签（块级标签拥有盒模型100%特性且最常用） 盒模型组成：margin + border + padding + content v_hint：content = width x height###盒模型成员介绍 1、content 通过设置width与height来规定content 块级标签可以设置自身宽高，默认宽为父级宽(width=auto)、高为0，高度可以由内容决定 内联标签不可以设置自身宽高，默认宽高均为0，宽高一定由内容决定 2、border border(边框)由border-width(宽度)、border-color(颜色)、border-style(风格)三部分组成 border成员：border-left、border-right、border-top、border-bottom border-width成员：border-left-width、border-right-width、border-top-width、border-bottom-width border-color成员：border-left-color、border-right-color、border-top-color、border-bottom-color border-style成员：border-left-style、border-right-style、border-top-style、border-bottom-style 风格 解释 solid 实线 dashed 虚线 dotted 点状线 double 双实线 groove 槽状线 ridge 脊线 inset 内嵌效果线 outset 外凸效果线 v_hint：border满足整体设置语法，eg：border: 1px solid red;3、padding padding成员：padding-left、padding-right、padding-top、padding-bottom padding整体设置 值得个数 方位 1 上下左右 2 上下 \ 左右 3 上 \ 左右 \ 下 4 上 \ 右 \ 下 \ 左 4、margin margin成员：margin-left、margin-right、margin-top、margin-bottom margin整体设置 赋值个数 方位 1 上下左右 2 上下 \ 左右 3 上 \ 左右 \ 下 4 上 \ 右 \ 下 \ 左 ###边界圆角 border-radius border-radius成员 成员 解释 border-top-left-radius 左上 方位 border-top-right-radius 右上 方位 border-bottom-left-radius 左下 方位 border-bottom-right-radius 右下 方位 单方位设置 赋值个数(值类型：长度 \ 百分比) 解释 1 横纵 2 横 \ 纵 按角整体设置 赋值个数(值类型：长度 \ 百分比) 解释 1 左上 右上 左下 右下 2 左上 右下 \ 右上 左下 3 左上 \ 右上 左下 \ 右下 4 左上 \ 右上 \ 右下 \ 左下 分向整体设置 格式 解释 1 / 1 横向 \ 纵向 ###其他相关属性 max|min-width|height overflow 值 描述 visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 display 值 描述 inline 内联 block 块级 inline-block 内联块]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端（二）之 CSS]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%89%8D%E7%AB%AF%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B-CSS%2F</url>
    <content type="text"><![CDATA[前端之 CSS前言昨天学习了标记式语言，也就是无逻辑语言。了解了网页的骨架是什么构成的，了解了常用标签，两个指令以及转义字符；其中标签可以分为两大类： 一类是根据标签内容可以分类单双标签，单标签指的是不需要字内容，标签就可以代表所有功能；双标签：主内容可以包含文本，也可以包含子标签（具有作用域）； 另一类是根据标签显示的效果可以分为行块标签，块标签会换行显示；行标签会同行显示。 今天学习 CSS，被称之为网页的化妆师。 什么是 CSSCSS 全称为级联样式表（Cascading Style Sheet），主要负责页面的风格设计，样式、美观。通常以.css 后缀结尾。 标记语言 和 html 一样是非编程语言，不具备语言的程序逻辑。 css 为前端页面的样式，由选择器、作用域与样式块组成。 选择器：由标签、类、id 单独或组合出现； 作用域：一组大括号包含的区域； 样式块：满足 css 连接语法的众多样式。 css 发展史代表版本 12345① 1990年，Tim Berners-Lee和Robert Cailliau共同发明了Web。1994年，Web真正走出实验室。② 1994年哈坤·利提出了CSS的最初建议。而当时伯特·波斯（Bert Bos）正在设计一个名为Argo的浏览器，于是他们决定一起设计CSS。③ 哈坤于1994年在芝加哥的一次会议上第一次提出了CSS的建议，1995年的www网络会议上CSS又一次被提出，博斯演示了Argo浏览器支持CSS的例子，哈肯也展示了支持CSS的Arena浏览器。④ 1997年初，W3C组织负责CSS的工作组开始讨论第一版中没有涉及到的问题。其讨论结果组成了1998年5月出版的CSS规范第二版。⑤ CSS3是CSS（层叠样式表）技术的升级版本，于1999年开始制订，2001年5月23日W3C完成了CSS3的工作草案，主要包括盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等模块。 CSS 书写语法css 由三部分组成：选择器、作用域与样式块。 12345678910选择器 &#123; 样式1: 值1; 样式2: 值2;&#125;h3 &#123; width: 100px; height: 100px; background-color: yellowgreen&#125; CSS 的三种引入方式第一种引入方式：行间式特点： 书写在标签的 style全局属性中； 样式格式为=》key：value（单位）； 以分号隔开多个样式； 最后的分号可以省略 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;css 三种引入第一种引入&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 默认有宽 高为0 背景颜色默认为透明 --&gt; &lt;p style="width: 200px; height: 200px; background-color: green"&gt;css 第一种引入行间式&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 第二种引入方式：内联式特点： 样式书写在 head 标签内的 style 属性内； 样式格式为 =&gt; 选择器：p|作用域 {}|样式块； 以分号隔开多个样式； 最后的分号可以省略 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset='utf-8' /&gt; &lt;title&gt;css 三种引入第二种引入&lt;/title&gt; &lt;!-- 内联式 --&gt; &lt;style type='text/css'&gt; p &#123; width: 150px; height: 150px; background-color: red &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; css 第二种引入内联式引入 &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 第三种引入方式：外联式特点： 书写在外部的 css文件中，不需要书写任何标签； 其他同上 1234567/*css 文件书写 css 语法*//*外部 css 文件 00.css*/h3 &#123; width: 100px; height: 100px; background-color: yellowgreen&#125; 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset='utf-8'/&gt; &lt;title&gt;第三种引入外联式引入&lt;/title&gt; &lt;link rel='stylesheet' href='./00.css'&gt; &lt;h3&gt; 第三种引入外联式引入 &lt;/h3&gt;&lt;/head&gt; &lt;/html&gt; CSS 三种引入方式的优先级三种可以同时存在并协同完整布局，三种引入方式之间没有优先级之说，哪种引入方式在逻辑下方（后解释的）谁就起作用（样式覆盖）。并且行间式一定是逻辑最下方的。 当三种引入方式同时存在且操作同一对象的同一属性时，才会出现冲突，最终起作用的就是优先级高的。 12345/*o4.css*/div &#123; height: 200px; color: brown;&#125; 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;三种引入的优先级&lt;/title&gt; &lt;!-- 三种可以同时存在，协同完整布局 --&gt; &lt;!-- 三种之间没有优先级之说 谁在逻辑下方（后解释的）谁就起作用（样式覆盖） --&gt; &lt;!-- 行间式一定是逻辑最下方的 --&gt; &lt;!-- 内联 --&gt; &lt;style type="text/css"&gt; div &#123; width: 200px; color: pink; /*height: 200px;*/ &#125; &lt;/style&gt; &lt;!-- 外联 --&gt; &lt;link rel="stylesheet" href="./04.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 优先级：大家同时存在且操作统一对象同一属性，才会出现冲突，最终起作用的就是优先级高的 --&gt; &lt;!-- 行间 --&gt; &lt;div style="background-color: cyan; color: orange"&gt;你是个好人&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 基础选择器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;基础选择器&lt;/title&gt; &lt;style type="text/css"&gt; /* div =&gt; 标签名 =》 标签选择器：开发过程中尽可能少的运用，运用范围为最内层的显示层 */ /* dd =&gt; class 名 =》 类选择器：布局的主力军 */ /* d =&gt; id名 =》 id 选择器：一定唯一的 */ /* * =&gt; 通配选择器 =》控制 html,body,body 下所有用于显示内容的标签（head 不参与显示）*/ * &#123; border: 1px solid black; &#125; /* 三种选择器有优先级*/ div &#123; width: 200px; height: 200px; background-color: red; &#125; /* 类选择器： .类名&#123;&#125; */ .dd &#123; background-color: orange; &#125; /* id 选择器： #id名 &#123;&#125;*/ #d &#123; background-color: green; &#125; /* 优先级：id 选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配选择器*/ /* 作用范围越精确，优先级越高*/ &lt;/style&gt; &lt;style type="text/css"&gt; .div &#123; width: 100px; height: 100px; background-color: orange &#125; /* 多类名：类名与类名之间不能拥有任何符号隔断 */ .red.div&#123; &#125; .div.red &#123; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- ***** --&gt; &lt;!-- 选择器：css 选择 html 标签的一个工具 =》将 html 与 css 建立起联系，那么 css 就可以控制 html样式 --&gt; &lt;!-- 选择器就是给 html 标签起名字 --&gt; &lt;div&gt;&lt;/div&gt; &lt;div class="dd"&gt;&lt;/div&gt; &lt;div class="dd" id="d"&gt;&lt;/div&gt; &lt;div class="div red"&gt;&lt;/div&gt; &lt;div class="div"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 长度单位与颜色123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;长度单位与颜色&lt;/title&gt; &lt;style type="text/css"&gt; .div &#123; /*px mm cm in em vw vh*/ width: 200px; height: 200px; /*颜色单词 | rgb() 0~255 | rgba | #六个十六进制数*/ background-color: rgba(255,0,255,0.5); /* #abc == #AABBCC*/ background-color: #00FFFF &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 文本样式操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;文本样式操作&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 200px; height: 200px; background-color: orange &#125; /*字体样式*/ .box &#123; width: 400px; /*字族*/ /* STSong 作为首选字体，微软雅黑作为备用字体*/ font-family: 'STSong','微软雅黑'; &#125; .box.uu &#123; /* 字体大小*/ font-size: 40px; /*字重*/ font-weight: 100; /*风格*/ /*none清除系统字体风格*/ /*font-style: none;*/ font-style: italic; /*行高：某一段文本在自身行高中可以垂直居中显示=》文本垂直居中*/ line-height: 200px; /*字体整体设置*/ /*字重 风格 大小/行高 字族 （风格可以省略）*/ font: 100 normal 60px/200px 'STSong'; /*&#125; i &#123; Normal 清除系统字体风格 font-style: normal; &#125;*/ &lt;/style&gt; &lt;style type="text/css"&gt; .wrap &#123; width: 200px; height: 200px; background-color: yellow; &#125; .w1 &#123; /*换行方式*/ word-break: break-all; &#125; .w2 &#123; width: 400px; /*水平居中：left|center|right*/ /*text-align: center;*/ /*字划线 中下上划线*/ text-decoration: line-through; text-decoration: underline; text-decoration: overline; /*字间距*/ letter-spacing: 5px; /*词间距*/ word-spacing: 5px; /*缩进*/ /*1em 相当于一个字的宽度*/ text-indent: 2em; &#125; a &#123; /*取消划线*/ text-decoration: none &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box uu"&gt;[普通文本]&lt;/div&gt; &lt;i&gt;i的文本&lt;/i&gt; &lt;div class="wrap"&gt; 一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五&lt;/div&gt; &lt;hr&gt; &lt;div class="wrap w1"&gt; 一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二三四五一二&lt;/div&gt; &lt;hr&gt; &lt;div class="wrap w2"&gt;hello world hello world&lt;/div&gt; &lt;a href="sfjsflj"&gt;aaa&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; display1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;display&lt;/title&gt; &lt;style&gt; .box &#123; width: 80px; height: 40px; background-color: orange &#125; .box &#123; /*block: 块级标签，独占一行，支持所有 css 样式*/ /*display: block;*/ /*inline：内联（行级）标签，同行显示，不支持宽高*/ /*display: inline;*/ /*inline-block：内联块标签，同行显示，支持所有 css 样式*/ display: inline-block; /*标签的嵌套规则*/ /*block 可以嵌套所有显示类型标签，div|h1~h6|p，*/ /*注：hn 与 p 属于文本类型标签，所以一般只嵌套inline 标签*/ /* inline 标签只能嵌套 inline 标签，span|i|b|sub|sup|ins| /*inline-block 可以嵌套其他类型标签，但不建议嵌套任意类型标签 img|input*/ &#125; .b1 &#123; height: 100px; &#125; .b2 &#123; height: 80px; &#125; .b3 &#123; height: 120px; &#125; .box &#123; /*文本基线对齐*/ vertical-align: baseline; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box b1"&gt;123&lt;/div&gt; &lt;div class="box b2"&gt;456&lt;/div&gt; &lt;div class="box b3"&gt;789&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端（一）之 HTML]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%89%8D%E7%AB%AF%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B-HTML%2F</url>
    <content type="text"><![CDATA[前端之 HTML前言python 基础、网络编程、并发编程与数据库要开始告一段落了，从现在开始进入前端的学习。前端的东西多且杂，需要好好地练习。 什么是前端前端即网站前台部分，运行在 PC 端，移动端等浏览器上展现给用户浏览的网页。随着互联网技术的发展，HTML5、CSS3，前端框架的应用，跨平台响应式网页设计能够适应各种屏幕分辨率，完美的动效设计，给用户带来极高的用户体验。 前端技术一般分为前端设计和前端开发，前端设计一般可以理解为网站的视觉设计，前端开发则是网站的前台代码实现，包括基本的 HTML 和 CSS 以及 JavaScript。 广义前端：所有用户可以直接看见并交互的界面； 狭义前端：浏览器上运行的用户交互界面。 什么是 HTMLHTML 是一种超文本标记语言（Hyper Text Markup Language），主要负责完成页面的结构设计，一般以.html或者.htm 后缀结尾。 超文本指页面内可以包含图片、链接甚至音乐、程序等非文字元素。 标记语言 标记语言为非编程语言，不具备编程语言具备的程序逻辑。 html 为前端页面的主题，由标签、指令与转义字符（实体）等组成 标签：被尖括号包裹，由字母开头包含合法字符的，可以被浏览器解析的标记。eg：系统标签、自定义标签。 指令：被尖括号包裹，由 !开头的标记。eg：&lt;!doctype html&gt; 转义字符：被&amp;与;包裹的特殊字母组合或#开头的十进制数。eg：\&#60;\&#62;\&nbsp; 文档类型 12345678&lt;!-- 标签语法规范 --&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd"&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;!DOCTYPE html&gt; 第一个页面基础模板123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset='utf-8'/&gt; &lt;title&gt;第一个页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 模板解读 DOCTYPE：指定文档类型，规定 html 标签语法； html：文档根标签，标注着文档（页面）的开始与结束； head：文档头标签，可以引用脚本文件、指定样式表、书写代码逻辑块、提供元信息； body：文档主体标签，包含文档所有文本与超文本内容； title：文档 tag 标题标签，设置文档 tag 的标题内容。 其他核心模板标签1. meta（元标签）12345678字符编码&lt;meta charset='utf-8'&gt;&lt;meta http-equiv='content-type' content='text/html;charset=utf-8'/&gt;SEO&lt;meta name='keywords' content='8-12个以英文逗号隔开的单词或词语'&gt;&lt;meta name='description' content='80字以内的一段话，与网站内容相关'&gt;移动适配&lt;meta name='viewport' content='width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no'/&gt; 2. link（链接标签）12345外联样式表&lt;link rel='stylesheet' type='text/css' href='style.css'/&gt;文档 tag 图标&lt;link rel='shortcut icon' type='image/x-icon' href='http://www.baidu.con/favicon.ico'/&gt; 3. style（样式标签）12内联样式表&lt;style&gt;&lt;/style&gt; 4. sctipt（脚本标签）1&lt;script type='text/javascript'&gt;&lt;/script&gt; html 常用标签12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;基本标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 无意义标签 --&gt; &lt;!-- div：最常用标签，没有之一（搭建页面架构） --&gt; &lt;div&gt;&lt;/div&gt; &lt;!-- span：文本最常用标签 -（构建文本架构，可以直接包裹文本，也可以包裹其他文本类（内联类型标签）--&gt; &lt;span&gt;&lt;/span&gt; &lt;!-- span 作为文本架构，删除样式的文本再由具体的文本类标签 del 嵌套 --&gt; &lt;span&gt;$1000&lt;del&gt;$2300&lt;/del&gt;&lt;/span&gt; &lt;!-- 标题标签：h1~h6 --&gt; &lt;!-- 一般一个页面会出现一次，作为该页面的总标题出现 --&gt; &lt;h1&gt;一级标题&lt;/h1&gt; &lt;h2&gt;二级标题&lt;/h2&gt; 普通文本 &lt;h6&gt;六级标题&lt;/h6&gt; &lt;!-- 段落标签 --&gt; &lt;p&gt;段落段落段落段落段落&lt;/p&gt; &lt;!-- 原生标签 --&gt; &lt;pre&gt; 呵 呵 &lt;/pre&gt; &lt;!-- 分割线 --&gt; &lt;hr&gt;&lt;/hr&gt; &lt;!-- 换行 --&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;!-- 文本类标签 --&gt; &lt;!-- 斜体 --&gt; &lt;i&gt;斜体&lt;/i&gt; &lt;!-- 斜体强调 --&gt; &lt;em&gt;斜体强调&lt;/em&gt; &lt;!-- 加粗 --&gt; &lt;b&gt;加粗&lt;/b&gt; &lt;!-- 加粗强调 --&gt; &lt;strong&gt;加粗强调&lt;/strong&gt; &lt;!-- 由 ruby 和 rt 两个标签配合使用 --&gt; &lt;ruby&gt; 拼音&lt;rt&gt;pinyin&lt;/rt&gt; &lt;/ruby&gt; &lt;!-- 插入文本 --&gt; &lt;ins&gt;&lt;/ins&gt; &lt;!-- 上角标 --&gt; &lt;span&gt;文本&lt;sup&gt;上角标&lt;/sup&gt;&lt;/span&gt; &lt;!-- 链接标签 --&gt; &lt;!-- href 标签的全局属性，超链接，规定协议--&gt; &lt;!-- 不规定的话：会在当前文件路径做路径拼接 --&gt; &lt;a href="https://www.baidu.com" target="_self"&gt;通往百度&lt;/a&gt; &lt;!-- 图片标签 --&gt; &lt;!-- src 图片源地址可以加载网络|本地|动态图片 alt：图片资源加载时文本提示 title：鼠标悬浮产生的文本提示（任意标签都可以具有该全局属性）--&gt; &lt;img src="" alt="" title="小柯基"&gt; &lt;!-- 表格 --&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;单元格&lt;/th&gt; &lt;th&gt;单元格&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;!-- 表单 --&gt; &lt;form &gt; &lt;input type="text"&gt; &lt;input type="text"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 标签的分类1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;标签的分类&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 系统标签 | 自定义标签: 系统没有的满足标签语法的所有标签 --&gt; &lt;zero title="XXX" style="color: red"&gt;zero&lt;/zero&gt; &lt;!-- 行块标签(display) --&gt; &lt;!-- 块: 换行显示 --&gt; &lt;p&gt;测试1&lt;/p&gt; &lt;p&gt;测试2&lt;/p&gt; &lt;!-- 行:同行显示 --&gt; &lt;span&gt;测试3&lt;/span&gt; &lt;span&gt;测试4&lt;/span&gt; &lt;!-- 单结构 | 组合结构 --&gt; &lt;div&gt;单结构&lt;/div&gt; &lt;!-- 被form包裹的input内容可以提交给后台,单独使用的input内容只能在前台(js)使用 --&gt; &lt;form action=""&gt; &lt;input type="text"&gt; &lt;/form&gt; &lt;input type="text"&gt; &lt;!-- 单双标签 --&gt; &lt;!-- 双: 首尾分离 --&gt; &lt;!-- 主内容:可以包含文本,也可以包含子标签 (具有作用域) --&gt; &lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt; &lt;!-- 单: 首尾连体 --&gt; &lt;!-- 主功能: 不需要子内容,标签就可以代表所有的功能语义 --&gt; &lt;hr /&gt; &lt;br /&gt; &lt;!-- input的内容 --&gt; &lt;input type="text" value="abc" placeholder="请输入"&gt;&lt;/body&gt;&lt;/html&gt; HTML 特殊符号转义]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux命令之ls]]></title>
    <url>%2F2018%2F11%2F29%2FLinux%E5%91%BD%E4%BB%A4%E4%B9%8Bls%2F</url>
    <content type="text"><![CDATA[前言不知道从什么时候开始，对Linux系统一直很着迷，就单纯觉得使用 Linux 系统（特别是命令行）是一件很酷的事情，所以很早就开始学习一些 linux 知识了，推荐鸟哥的 linux 私房菜，哈哈，不用我推荐这本书已经是鼎鼎大名了（所以这个系列博客主要参考鸟哥的 linux 并且我会在 linux18.04上面测试）。所以现在想从最基础的命令开始，系统的了解 linux 系统，所以这也会是个系列博客，尽量做到每天写一个 linux 命令，这也是件自我激励的事情，开始我的 linux 之旅吧！！！ ls]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例]]></title>
    <url>%2F2018%2F11%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[前言本篇博客归类于设计模式，单例模式算是我了解的不多的设计模式之一，在某些应用场景下为了节省资源，常常使用单例模式来编写代码。 单例模式（Singleton Pattert）是一种常用的软件设计模式，该模式的主要目的是确保在某一个类中能且只能产生一个实例。当在某些场景下希望某个类只能产生一个实例时，就可以使用单例模式了。 python 中的单例模式单例模式也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 实现单例模式的思路是：一个类能返回对象一个引用（永远是同一个）和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。 单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建实例方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例惟一的原则。解决这个问题的办法是为指示是否已经实例化的变量提供一个互斥锁（虽然这样会降低效率）。 在面向对象编程中，学习了使用某一个类来创建多个不同的对象，那么如何使得该类只能产生一个对象呢？ 在Python 中，可以使用多种方法来实现单例模式： 使用模块 使用魔术方法__new__ 使用装饰器 使用元类 使用模块python 中的模块就是天然的单例模式，因为模块只会在第一次导入的时候加载，会生成一个 .pyc文件，第二次导入时，就会直接加载 .pyc文件，而不会再次执行模块代码。因此，可以把相关的代码和数据定义在一个模块中，就可以获得一个单例对象了。然后要用的话导入就可以，我可以保证这样做的话肯定只有一个单例对象。代码就不演示了。 使用特殊方法__new__在使用类实例化一个对象时，其实python 解释器做了两步操作: 调用 object 的__new__方法创建一个空对象； 调用类本身的__init__方法进行初始化（这都是通过元类的__call__来间接调用的） 那么是不是可以在调用__new__的时候做一些判断来使得只能创建一个单例对象呢？ 12345678class Singleinstance: _instance = None def __new__(cls, *arg, **kwargs): if not cls._instance: cls._instance = super(Singleinstance, cls).__new__(cls, *args, **kwargs) return cls._instanceclass MyClass(Singleinstance): a = 1 在上面的代码中，将类的__new__方法和一个类的属性关联起来，如果 cls._instance 为 None 则创建一个对象，否则的话直接返回cls._instance。 使用装饰器装饰器可以动态的修改一个类或者函数的功能。所以可以使用装饰器来装饰某各类，使其只能生成一个实例： 1234567891011121314from functools import wrapsdef singleinstance(cls): instances = &#123;&#125; @wraps(cls) def getinstance(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return getinstance@singleinstanceclass MyClass: a = 1 在上面，定义了一个装饰器 singleinstance，它返回了一个内部函数getinstance，该函数会判断某个类是否在字典 instance 中，如果不存在，则会将 cls 作为 key，cls(*args, **kwargs)作为 value存到 instances 中，否则，直接返回 instances[cls]。该装饰器可以装饰所有只需要产生一个实例的类上。 使用 metaclass元类 metaclass 可以通过自定义__new__方法和__init__方法来控制类的创建过程，它主要做三件事： 拦截类的创建 修改类的定义 返回修改后的类 使用元类实现单例的代码如下： 12345678910111213141516171819202122class MyMetaClass(type): # def __init__(self): # pass instance = None def __call__(cls, *args, **kwargs): # 判断对象有没有创建过 if not MyMetaClass.instance: # 创建空对象 MyMetaClass.instance = object.__new__(cls) print(cls.__name__) print(cls.__dict__) print("创建新的播放器对象!") # 初始化对象 MyMetaClass.instance.__init__(*args,**kwargs) print(type(MyMetaClass.instance)) # 返回对象 return MyMetaClass.instanceclass CDPlayer(metaclass=MyMetaClass): pass]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[元类]]></title>
    <url>%2F2018%2F11%2F28%2F%E5%85%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[前言本篇博客学习 python 中一种高级概念，元类。在《说文》中这样描述元：元，始也（ps：这也太简短了）。三个字，最后一个字还是语气词。。很形象的说明了元的意思，最开始的意思，在道教中元的意思是：开始的，最初。第一。为首的。主要，根本，整体的意思。那么很显然，元类是最开始的类的意思。我们都知道在 python 中一切皆为对象，而对象都继承与 object 类，那么元类与 object 的关系是什么呢？ 可以看出元类也是继承自 object 类的。 那么元类和类的关系是什么呢？ 简单来讲就是：类生成对象，元类生成自己本身同时实例化其他所有的类。 元类类作为对象之前已经说过 python 中一切皆对象，那么类同样也是对象，而且类是元类的对象。当使用关键词class定义一个类时，在代码执行阶段就会创建一个 空的object，并使用元类的__init__方法来出初始化一个类。这个对象（类）本身可以创建对象，因为它是一个类。 123# 在内存中创建一个 Foo 对象class ObjectCreator(object): pass 但是同样的它也是一个对象，一个元类的实例对象。 所以从对象层面将和它自己实例出来的对象没有什么不同，因此： 可以将类赋值给一个变量 可以复制它 可以为类添加其他的属性 可以将其作为参数来传递 例如： 12345678910111213141516171819&gt;&gt;&gt; print(ObjectCreator) # you can print a class because it's an object&lt;class '__main__.ObjectCreator'&gt;&gt;&gt;&gt; def echo(o):... print(o)...&gt;&gt;&gt; echo(ObjectCreator) # you can pass a class as a parameter&lt;class '__main__.ObjectCreator'&gt;&gt;&gt;&gt; print(hasattr(ObjectCreator, 'new_attribute'))False&gt;&gt;&gt; ObjectCreator.new_attribute = 'foo' # you can add attributes to a class&gt;&gt;&gt; print(hasattr(ObjectCreator, 'new_attribute'))True&gt;&gt;&gt; print(ObjectCreator.new_attribute)foo&gt;&gt;&gt; ObjectCreatorMirror = ObjectCreator # you can assign a class to a variable&gt;&gt;&gt; print(ObjectCreatorMirror.new_attribute)foo&gt;&gt;&gt; print(ObjectCreatorMirror())&lt;__main__.ObjectCreator object at 0x8997b4c&gt; 动态创建类由于类也是对象，因此可以像任何对象一样动态创建它们。 在python中，type 除了可以查看对象的类型，还有一个很强大的功能，type 可以动态的创建类。type 可以将类的描述作为参数并返回一个类。 使用 class关键词时，python 会自动的创建此对象，就像实例化一个对象时，调用的是类中的__init__方法，创建对象时同样的调用了元类中的__init__方法： 该函数有四个参数，第一个参数为 cls表示这是一个由类调用的初始化函数，python 在检测语法的时候发现 class则会把 class 后面的类名当做参数传给 what，bases 表示继承的父类是谁，是个元祖类型（因为会有多继承），dict 是个字典类型，是类的名称空间，可以通过__dict__查看，使用 type来创建一个类： 123what = 'Music'bases = (object,)dict = &#123;'music_name': '南山忆'&#125; 这和我们使用 class关键词定义一个类没有什么不同： 之前在学习类的时候，我们知道创建一个对象是调用了类中__init__方法，同理在创建类的时候是调用了元类中也就是 type 中的__init__方法，所以我们可以通过改写 type 中的元类来自定义创建类，比如加些判断或者其他的属性： 可惜想象是美好的，这招根本行不通，那么有没有别的办法呢？当然有啦，哈哈哈哈哈 在学习类的三大特性的时候，从父类继承的属性可以改写（多态的思想），那么改写不了元类是因为元类很特殊，那我继承自元类的类肯定可以改写吧。这个到后面再讲，突然发现什么是元类还没讲清楚。。。 什么是元类我把元类称之为 类的类。元类是创建类的‘’东西‘’，我们定义类来创建对象，类也是对象，所以定义了一个元类用来创建对象。type是 Python 用来创建所有类的元类（不包括 object 类）。其实这和用 str创建字符串对象，int创建整数对象一致的。type只是创建类对象的类。 一切，all thing都是 Python 中的一个对象。这包括整数、字符串、函数和类。所有这些都是对象，所有这些都是从一个类创建的。因此，元类是创建类对象的东西。 __metaclass__属性除了使用 type 动态创建类以外，要控制类的创建行为，可以使用 metaclass，这也是自定义元类的方法。 metaclass 的意思就是元类：当我们定义了类以后，就可以根据这个类创建出实例，所以先定义类，然后创建实例。但是如果想创建出类呢？那就必须根据 metaclass 创建出类，所以：先定义元类（不自定义时，默认用 type），然后创建类。（大部分情况使用不到 metaclass，除非想自定义元类）。 默认情况下，类是使用 type 构造的。类主体在一个新的名称空间中执行，类名在本地绑定到类型的结果（名称，基，名称空间）。 可以通过类定义行中传递元类关键字参数来定制类的创建过程，或者从包含此类参数的现有类继承。 实例化对象的完整过程12class Foo(Bar): pass 当解释器执行这行代码时，执行以下操作： Foo 有__metaclass__属性吗？如果有的话，python 会通过 __metaclass__在内存中创建一个名称为 Foo 的类对象。如果 Python 没有找到__metaclass__，它会继续在 Bar 中寻找__metaclass__属性，并尝试做和前面同样的操作。如果 Python 在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。如果还找不到__metaclass__，python 就会用内置的 type 来创建这个类对象。 那么在自定义类是，可以在__metaclass__中放置什么代码呢？ 可以放用来创建一个类的东西，type 或者 type的子类都可以放。 以上面的代码为例，我们实例化一个对象obj=Foo()，会先执行 Foo 类中的__new__方法，没有则使用父类的__new__方法，创建一个空对象并返回，然后执行__init__方法（自己有就用自己的，没有就用父类的，这里分两种情况，如果是创建一个类的对象，那就是使用父类的，因为自己没有；如果是创建类，自己有就是用自己的，否则就是用父类的），为创建的对象进行初始化。 obj()会执行 Foo 类的__call__方法，没有则用父类的。现在已经知道。类同样也是对象，是元类的对象，即实例化一个对象（类）时，调用其父类（元类）的__call__方法。 元类处理过程：定义一个类时，使用声明或者默认的元类对该类进行创建，对元类求 type 运算，得到父元类（该类声明元类的父元类），调用父元类的__call__方法，在父元类的__call__方法中，调用该类声明的元类的__new__来创建一个空对象（该方法需要返回一个类对象实例），然后再调用该元类的__init__方法初始化该类对象，最终返回一个类。 对象时类创建，创建对象时类的__init__方法自动执行，对象()则会执行类的__call__方法； 类是由 type 创建的，class 定义的时候 type 的__init__方法自动执行，类()则会执行type 的__call__方法（类的__new__，类的__init__方法） 元类的__new__方法和__init__影响的是创建类的对象行为（不是创建类），父元类的__call__控制对子元类的__new__，__init__的调用，就是说控制类对象的创建和初始化。父元类的__new__和__init__由更上层的元类控制，一般来说，原始 type 是最初的父元类，其__new__和__init__是最具有普遍意义的，即应该是分配内存、初始化相关信息等。元类的__call__方法影响的是创建类的实例对象的行为，所以这时候自定义__call__就可以控制创建类对象的实例对象的行为了。比如单例模式的创建。 __new__和__init__影响的是创建对象的行为，当这些函数在元类中时，影响创建的是类；同理，当这两个函数在普通类中时，影响的是创建普通的对象实例行为。 __call__影响()调用行为，__call__是在创建类的时候调用，即：定义类时就是创建类，此时会调用元类的__call__，如果元类有继承，子元类定义时执行的是父元类的__call__。如果是普通类实例化，调用的是普通类的__call__。（昨晚上卡在这里了，其实实例化一个普通的对象时，都是调用其父类的__call__方法，除了元类，普通类中不会有__call__方法。） 自定义元类元类的主要目的是在创建类时自动更改类，比如想要将创建的所有类都变成首字母大写的： 12345678910111213141516class MymetaClass(type): def __call__(cls, *args, **kwargs): if type(args[0]) != str: raise TypeError('参数必须为字符串类型') obj = object.__new__(cls) obj.__init__(*args, **kwargs) return objclass Foo(metaclass=MymetaClass): def __init__(self, name): self.name = nameres = Foo(123) 这就是自定义元类的好处，可以在__call__来对传入的参数进行一些判断来做一些自定义操作。 通过函数12345678910111213141516171819202122232425262728293031323334# the metaclass will automatically get passed the same argument# that you usually pass to `type`def upper_attr(future_class_name, future_class_parents, future_class_attr): """ Return a class object, with the list of its attribute turned into uppercase. """ # pick up any attribute that doesn't start with '__' and uppercase it uppercase_attr = &#123;&#125; for name, val in future_class_attr.items(): if not name.startswith('__'): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val # let `type` do the class creation return type(future_class_name, future_class_parents, uppercase_attr)__metaclass__ = upper_attr # this will affect all classes in the moduleclass Foo(): # global __metaclass__ won't work with "object" though # but we can define __metaclass__ here instead to affect only this class # and this will work with "object" children bar = 'bip'print(hasattr(Foo, 'bar'))# Out: Falseprint(hasattr(Foo, 'BAR'))# Out: Truef = Foo()print(f.BAR)# Out: 'bip' 通过元类123456789101112131415161718192021222324# remember that `type` is actually a class like `str` and `int`# so you can inherit from itclass UpperAttrMetaclass(type): # __new__ is the method called before __init__ # it's the method that creates the object and returns it # while __init__ just initializes the object passed as parameter # you rarely use __new__, except when you want to control how the object # is created. # here the created object is the class, and we want to customize it # so we override __new__ # you can do some stuff in __init__ too if you wish # some advanced use involves overriding __call__ as well, but we won't # see this def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): uppercase_attr = &#123;&#125; for name, val in future_class_attr.items(): if not name.startswith('__'): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return type(future_class_name, future_class_parents, uppercase_attr) 使用元类的__new__方法因为 type 的__new__不会被覆盖，所以可以使用： 12345678910111213141516class UpperAttrMetaclass(type): def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): uppercase_attr = &#123;&#125; for name, val in future_class_attr.items(): if not name.startswith('__'): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val # reuse the type.__new__ method # this is basic OOP, nothing magic in there return type.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr) 使用 super 的__new__方法123456789101112class UpperAttrMetaclass(type): def __new__(cls, clsname, bases, dct): uppercase_attr = &#123;&#125; for name, val in dct.items(): if not name.startswith('__'): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, uppercase_attr) 使用元类的代码复杂性背后的原因不是因为元类，而是因为你通常使用元类来依赖于内省，操纵继承，变量__dict__等等来做扭曲的东西。实际上，元类特别适用于制作黑魔法，因此也很复杂。但他们本身很简单： 拦截类的创建 自定义类 返回修改后的类 为什么要使用元类而不是函数？既然__metaclass__可以接收任何调用，那么为什么要使用一个类，因为类显然比函数要复杂。 有几个原因： 目的很明确，你知道使用元类会发生什么； 可以使用 OOP。metaclass 可以从元类继承，覆盖父方法，元类甚至可以使用元类； 如果你指定了元类，但没有使用元类函数，则类的子类将其元类的实例； 可以更好地构建代码； 可以和__new__，__init__，__call__搭配使用，来使得创建一个类或者一个类实例变得更有创造性。 元类创建类，调用元类中的 new 和 init 方法，类创建类对象，调用元类中的 call 方法，call 里面会调用类对象的 new（通常为 object 的 new，产生一个空对象），然后调用类的 init 实例化]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库（八）]]></title>
    <url>%2F2018%2F11%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言本篇博客内容为索引，索引是为了提高数据库的查询效率。 索引什么是索引？索引就相当于书的目录，是 mysql 中一种专门的数据结构，称为 key，索引的本质原理就是通过不断地缩小查询范围，来降低 io 次数从而提升查询性能。强调：一旦为表创建了索引，以后的查询都会先查索引，再根据索引定位的结果去找数据。 为什么要用索引？对于一个应用来说，对数据库的读写比例基本上是10：1，即读多写少。而且对于写来说极少出现性能问题，大多数性能问题都是慢查询提到加速查，这时候就必须用到索引。 索引的影响 在表中有大量数据的前提下，创建索引速度会很慢； 在索引创建完毕后，对表的查询性能会大幅度提升，但是写性能会降低。 磁盘 IO 与预读磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms 以下；旋转延迟就是磁盘转速花费的时间，比如一个磁盘7200转，表示每分钟能转7200次，也就是一秒钟能转120次，旋转延迟就是1/120/2=4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间来说可以忽略不计。那么访问一次磁盘的时间，即一次磁盘 IO 的时间约等于5+4.17=9ms 左右，看起来还挺短的，但是对于现在的计算机来说，一秒钟可以执行5亿条指令，执行一次 IO 的时间可以执行约450万条指令，数据库动辄十万百万乃至千万级别数据，每次9毫秒的时间，很显然会造成大量的等待时间。下图是计算机硬件延迟的对比图： 考虑到磁盘 IO 是非常高昂的操作，计算机操作系统做了一些优化，当一次 IO 时，不光把当前地址的数据，而是把相邻的数据也都读取到内存缓冲区，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次 IO 读取的数据称之为一页（page）。具体一页有多大数据跟操作系统有关，一般为4k 或8k，也就是我们读取一页内的数据时候才发生了一次 IO。 索引的数据结构对于索引来说，它的目的就是降低查找数据时产生的磁盘 IO 数量级，最好是常数数量级。索引使用的是 B+树（B+树是通过二叉查找树，再由平衡二叉树，B 树演化而来）。 如上图，是一颗 B+数，浅蓝色的块称之为一个磁块，可以看到每个人磁块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘快1包含数据项17和35，包含指针 P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不过存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。 B+树查找过程如果所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次 IO，在内存中用二分法查找确定29在17和35之间，锁定磁盘块1的 P2指针，内存时间因为非常短（相比磁盘 IO）可以忽略不计，通过磁盘块1的 P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第三次 IO，同时内存中做二分查找找到29，结束查询，总计三次 IO。真实情况是，3层的 B+数可以表示上百万的数据，如果上百万的数据查找只需要三次 IO，性能提升将是巨大的，如果没有索引，每个数据项都要发生一次 IO，那么总共需要百万次的 IO，显然成本非常非常高。 B+数性质 索引字段要尽量的小：IO 次数取决于 B+树的高度 h，假设当前数据表的数据为 N，每次磁盘块的数据项的数量是 m，则有 h=log(m+1)N，当数据量 N 一定的情况下，m 越大，h 越小；而 m=磁盘块的大小/数据项的大小，磁盘块的大小也是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如 int 占4字节，要比 bigint 8字节少一半。这也是为什么 B+树要求把真实的数据放在叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。 索引的最左匹配特性：当B+树的数据项是复合的数据结构，比如(name,age,sex)的时候，B+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，B+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，B+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，B+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。 聚集索引与辅助索引在数据库中，B+树的高度一般都在2~4层，这也就是说查找某一个键值的行记录时最多只需要2到4次IO，这倒不错。因为当前一般的机械硬盘每秒至少可以做100次IO，2~4次的IO意味着查询时间只需要0.02~0.04秒。 数据库中的B+树索引可以分为聚集索引（clustered index）和辅助索引（secondary index）， 聚集索引与辅助索引相同的是：不管是聚集索引还是辅助索引，其内部都是B+树的形式，即高度是平衡的，叶子结点存放着所有的数据。 聚集索引与辅助索引不同的是：叶子节点存放的是否是一条完整的记录。 聚集索引1234567InnoDB存储引擎表示索引组织表，即表中数据按照主键顺序存放。而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。 如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。 如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。在这种情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值得查询。 聚集索引优点 它对主键的排序查找和范围查找速度非常快，叶子节点的数据就是用户所要查询的数据。如用户需要查找一张表，查询最后的10位用户信息，由于 B+树索引是双向链表，所以用户可以快速找到最后一个数据页，并取出10条记录。 范围查询，即如果要查找某一范围内的数据，通过叶子节点的上层节点就可以得到页的范围，之后直接读取数据页即可。 辅助索引表中除了聚集索引外其他索引都是辅助索引，也称为非聚集索引，与聚集索引的区别是：辅助索引的叶子节点不包含行记录的全部数据。 叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含一个书签。该书签用来告诉 InnoDB 存储引擎去哪里可以找到与索引相对应的行数据。 由于 InnoDB 存储引擎是索引组织表，因此 InnoDB 存储引擎的辅助索引的书签就是相应行数据的聚集索引键。如下图： 辅助索引的存在并不影响数据再聚集索引中的组织，因此每张表中可以有多个辅助索引，但只能有一个聚集索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶子级别的指针获得指向主键索引的主键，然后通过主键索引来找到一个完整的行记录。 举例来说，如果在一棵高度为3的辅助索引树种查找数据，那需要对这个辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行三次查找，最终找到一个完整的行数据所在的页，因此一共需要6次 IO 访问才能得到最终的一个数据页。 MySQL 索引管理索引的功能 索引的功能就是加速查找 mysql 中的 primary key、unique，联合唯一都是索引，这些索引除了加速查找以外，还有约束的功能。 MySQL 常用索引 普通索引：index 加速查找 唯一索引： 主键索引 primary key：加速查找+约束（不能为空，不能重复） 唯一索引 unique：加速查找+约束（不能重复） 联合索引： primary key(id,name)：联合主键索引 unique(id,name)：联合唯一索引 index(id,name)：联合普通索引 创建/删除索引 创建表时 12345mysql&gt; create table 表名( 字段名1 数据类型 [完整性约束条件...], 字段名2 数据类型 [完整性约束条件...], [unique | fulltext | spatial] index | key [索引名] (字段名[(长度)] [asc | desc])); 在已存在的表上创建索引 12mysql&gt; create [unique | fulltext | spatial ] index 索引名 on 表名 (字段名[(长度)] [asc | desc]); Alter table在已存在的表上创建索引 12mysql&gt; alter table 表名 add [unique | fulltext | spatial ] index 索引名(字段名[(长度)] [asc | desc]); 删除索引 1mysql&gt; drop index 索引名 on 表名; 总结123456789101. 一定是为搜索条件的字段创建索引，比如select * from s1 where id = 333;就需要为id加上索引2. 在表中已经有大量数据的情况下，建索引会很慢，且占用硬盘空间，建完后查询速度加快比如create index idx on s1(id);会扫描表中所有的数据，然后以id为数据项，创建索引结构，存放于硬盘的表中。建完以后，再查询就会很快了。3. 需要注意的是：innodb表的索引会存放于s1.ibd文件中，而myisam表的索引则会有单独的索引文件table1.MYIMySAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在innodb中，表数据文件本身就是按照B+Tree（BTree即Balance True）组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此innodb表数据文件本身就是主索引。因为inndob的数据文件要按照主键聚集，所以innodb要求表必须要有主键（Myisam可以没有），如果没有显式定义，则mysql系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则mysql会自动为innodb表生成一个隐含字段作为主键，这字段的长度为6个字节，类型为长整型. 正确使用索引并不是说创建了索引就一定会加快查询速度，若想利用索引达到预期的提高查询速度的效果，我们在添加索引时，必须考虑以下问题： 范围问题，或者说条件不明确，条件中出现这些符号：&gt;、&gt;=、&lt;、&lt;=、!=、between and、like 尽量选择区分度高的列作为索引，区分度的公式是 count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录越少，唯一键的区分度是1，而一些状态、性别字段可能在数据量特别大的地方就是0，一般需要 join 的字段要求都是0.1以上，即平均1次扫描10条记录 =和 in 可以乱序，比如 a=1 and c=3建立(a,b,c)索引可以任意顺序，mysql 的查询优化器会优化成索引可以识别的形式 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’) and/or 1234567891011121314151617181920211、and与or的逻辑 条件1 and 条件2:所有条件都成立才算成立，但凡要有一个条件不成立则最终结果不成立 条件1 or 条件2:只要有一个条件成立则最终结果就成立2、and的工作原理 条件： a = 10 and b = &apos;xxx&apos; and c &gt; 3 and d =4 索引： 制作联合索引(d,a,b,c) 工作原理: 对于连续多个and：mysql会按照联合索引，从左到右的顺序找一个区分度高的索引字段(这样便可以快速锁定很小的范围)，加速查询，即按照d—&gt;a-&gt;b-&gt;c的顺序3、or的工作原理 条件： a = 10 or b = &apos;xxx&apos; or c &gt; 3 or d =4 索引： 制作联合索引(d,a,b,c) 工作原理: 对于连续多个or：mysql会按照条件的顺序，从左到右依次判断，即a-&gt;b-&gt;c-&gt;d在左边条件成立但是索引字段的区分度低的情况下(name 与 gender 均属于这种情况)，会依次往右找到一个区分度高的索引字段，加速查询 最左前缀匹配原则，非常重要的原则，对于组合索引mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配(指的是范围大了，有索引速度也慢)，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 其他情况 123456789- 避免使用select *- count(1)或count(列) 代替 count(*)- 创建表时尽量时 char 代替 varchar- 表的字段顺序固定长度的字段优先- 组合索引代替多个单列索引（经常使用多个条件查询时）- 尽量使用短索引- 使用连接（JOIN）来代替子查询(Sub-Queries)- 连表时注意条件类型需一致- 索引散列值（重复少）不适合建索引，例：性别不适合]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库（七）]]></title>
    <url>%2F2018%2F11%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言本篇博客学习内容为视图、触发器、事务、存储过程、函数、数据备份及流程控制。 视图什么是视图？视图是由一张表或多张表的查询结果构成的一张虚拟表，建立一张视图后会在数据库中保留一个以 frm 后缀结尾的文件，只保留了数据结果，所有的数据都来自 sql 语句。 为什么使用视图？在进行多表查询的时候，sql 语句会非常非常长，比如 1select t1.student_id from (select student_id,num from score where course_id = (select cid from course where cname = &apos;物理&apos;)) as t1 join(select student_id,num from score where course_id = (select cid from course where cname = &apos;生物&apos;)) as t2 on t1.student_id = t2.student_id where t1.num &gt; t2.num; 看是不是很长，这还只是三表查询，如果遇到更加复杂的表结构肯定会更长，不过那样的话对表的维护困难也加大了。如果每次都编写需要得到相同数据的 sql 语句会是一件很麻烦的事，可以把经常需要查询的 sql 语句转变为视图就可以避免重复写 sql 语句的问题。 视图除了可以减少 sql 语句的编写次数，还可以使用不同的视图来展示不同数据的访问，那么给某些用户设置权限不就可以了吗？注意，设置的权限要么只能看某张表的全部数据，要么只能看某张表中的某个 column 的数据，也就是列数据，列数据只是保存了字段名，比如说我要查看我的当月工资，是需要查看一行数据的，这样权限就帮不了忙了。（当然可以加 where 条件，在这里是介绍视图） 使用方法创建视图1mysql&gt; create [or replace] view 视图名 [(column_list)] as select_statement; 加上 or replace 时如果已经存在相同视图则替换原有视图，column_list 指定哪些字段要出现在视图中。注意：由于是一张虚拟表，视图中的数据实际来源于其他表，所以在视图中的数据不会出现在硬盘上，也就是只会保存一份数据结构。 使用视图视图是一张虚拟表，所以使用方式与普通表没有区别。 查看视图 查看数据结构 1mysql&gt; desc view_name; 查看创建语句 1mysql&gt; show create view view_name; 修改视图1mysql&gt; alter view_name select_statement; 删除视图1mysql&gt; drop view view_name; 具体使用案例一：简化多表 sql 语句123456789101112131415161718# 准备数据mysql&gt; create database db02 charset utf8;mysql&gt; use db02;mysql&gt; create table student( s_id int(3), name varchar(20), math float, chinese float);mysql&gt; insert into student values(1,&apos;tom&apos;,80,70),(2,&apos;jack&apos;,80,80),(3,&apos;rose&apos;,60,75);mysql&gt; create table stu_info( s_id int(3), class varchar(50), addr varchar(100));mysql&gt; insert into stu_info values(1,&apos;二班&apos;,&apos;安徽&apos;)，(2，&apos;二班&apos;,&apos;湖南&apos;),(3,&apos;三班&apos;,&apos;黑龙江&apos;)；# 创建视图包含编号、学生姓名、班级mysql&gt; create view stu_v (编号,姓名,班级) as select student.s_id,student.name,stu_info.class from student,stu_info where student.s_id = stu_info.s_id;# 查看视图中的数据mysql&gt; select * from stu_v; 案例二：隔离数据1234567891011121314# 创建工资表mysql&gt; create table salarys( id int primary key, name char(10), salary double, dept char(10));mysql&gt; insert into salarys values (1,&apos;刘强东&apos;,800000,&apos;市场&apos;), (2,&apos;马云&apos;,899990,&apos;市场&apos;), (3,&apos;李彦宏&apos;,989090,&apos;市场&apos;), (4,&apos;马化腾&apos;,88889999,&apos;财务&apos;);# 创建市场部视图mysql&gt; create view dept_sc as select * from salarys where dept = &apos;市场&apos;;mysql&gt; select * from dept_sc; 注意：对视图数据的 insert update delete 会同步到原表中，但由于视图可能是部分字段，很多时候会失败。 总结：mysql 可以分担程序中的部分逻辑，但这样一来后续的维护会变得更麻烦。如果需要改表结构，那意味着视图也需要相应的修改，没有直接在程序中修改 sql 来的方便。 触发器什么是触发器？触发器是一段与表有关的 mysql 程序，当这个表在某个时间点发生了某种事件时，将会自动执行相应的触发器程序。 何时使用触发器当我们想要在一个表记录被更新时做一些操作时就可以说使用触发器，但是完全可以在 python 中来完成这个事情。 创建触发器语法1234mysql&gt; create trigger t_name t_time t_event on table_name for each rowbeginstmts...end 支持的时间点（t_time）：事件发生之前和之后 before|after 支持的事件（t_event）：update、insert、delete 在触发器中可以访问到将被修改的那一行数据，根据事件不同能访问的也不同，update 可用 old 访问旧数据，new访问新数据，insert 可用 new 访问新数据，delete 可用 old 访问旧数据。 可以将 new 和 old 看做一个对象，其中封装了修改的数据的所有字段。 使用触发器案例有 cmd 表和错误日志表，需求：在 cmd 执行失败时自动将信息存储到错误日志表中。 123456789101112131415161718192021222324252627282930313233343536# 准备数据mysql&gt; create table cmd( id int primary key auto_increment, user char(32), priv char(10), cmd char(64), sub_time datetime, # 提交时间 success enum(&apos;yes&apos;,&apos;no&apos;)); # 0代表执行失败# 错误日志表mysql&gt; create table errlog( id int primary key auto_increment, err_cmd char(64), err_time datetime);# 创建触发器mysql&gt; delimiter //mysql&gt; create trigger trigger1 after insert on cmd for each rowbeginif new.success = &apos;no&apos; then insert into errlog values(null,new.cmd,new.sub_time);end if;end //delimiter;# 往表 cmd 中插入记录，触发触发器，根据 if 条件决定是否需要插入错误日志mysql&gt; insert into cmd( user, priv, cmd, sub_time, success) values (&apos;thales&apos;,&apos;0755&apos;,&apos;ls-l /etc&apos;,now(),&apos;yes&apos;), (&apos;thales&apos;,&apos;0755&apos;,&apos;cat /etc/password&apos;,now(),&apos;no&apos;), (&apos;thales&apos;,&apos;0755&apos;,&apos;user ass xxx&apos;,now(),&apos;no&apos;), (&apos;thales&apos;,&apos;0755&apos;,&apos;ps aux&apos;,now(),&apos;yes&apos;);# 查看错误日志表中的记录是否有自动插入mysql&gt; select * from errlog; delimiter用于修改默认的行结束符，由于在触发器中有多条 sql 语句需要使用分号来结束，但是触发器是一个整体，所以需要先更换默认的结束符（这里修改的只是客户端的结束符，服务端还是以分号结束），在触发器编写完后再讲结束符设置回分号 注意：外键不能触发事件，主表删除了某个主键，从表也会相应的删除数据，但是并不会执行触发器，并且触发器中不能使用事务，相同时间点的相同事件的触发器，不能同时存在。 删除触发器语法123mysql&gt; drop trigger trigger_name;# 删除上面创建的触发器mysql&gt; drop trigger trigger1; 事务什么是事务？mysql 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也需要删除和该人员相关的信息，如信箱、文章等，这样，这些数据库操作就构成一个事务。事务是逻辑上的一组操作，要么都成功，要么都失败。 在 mysql 中只有使用了 InnoDB 数据库引擎的数据库或表才支持事务； 事务处理可以用来维护数据库的完整性，保证成批的 sql 语句要么都执行，要么都不执行； 事务用来管理 insert、update、delete语句 事务的四个特性一般来说，事务必须满足四个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样； 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性的完成预定的工作； 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（Read committed）、可重复读（Repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 在 mysql 命令行的默认设置下，事务都是自动提交的，即执行 sql 语句后就会马上执行 commit 操作。因此要显式的开启一个事务必须使用命令 begin 或 start transaction，或者执行命令 set autocommit=0，用来禁止使用当前会话的自动提交。 事务控制语句 begin 或 start transaction：显式的开启一个事务； commit：也可以使用 commit work，不过二者是等价的。commit 会提交事务，并使已对数据库进行的所有修改成为永久性的； rollback：也可以使用 rollback work，二者也是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； savepoint identifier：savepoint 允许在事务中创建一个保存点，一个事务中可以有多个 savepoint； release savepoint identifier：删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； rollback to identifier：把事务回滚到标记点； set transaction：用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有 read uncommitted、read committed、repeatable read和 serializable。 mysql 事务处理的两种方式 BEGIN，ROLLBACK，COMMIT 来实现 BEGIN：开始一个事务 ROLLBACK：事务回滚 COMMIT：事务确认 直接使用 set 来改变 mysql 的自动提交模式 SET AUTOCOMMIT=0：禁止自动提交 SET AUTOCOMMIT=1：开启自动提交 事务的用户隔离级别数据库使用者可以控制数据库工作在哪个级别下，就可以防止不同的隔离性问题。 read uncommitted：不做任何隔离，可能脏读、幻读； read committed：可以防止脏读，不能防止不可重复读和幻读； repeatable read：可以防止脏读，不可重复读，不能防止幻读； serializable：数据库运行在串行化实现，所有问题都没有，就是性能低。 修改隔离级别查询当前级别1mysql&gt; select @@tx_isolation; 修改级别1mysql&gt; set global transaction isolation level Repeatable read; 使用事务start transaction：开启事务，在这条语句之后的 sql 将处在同一事务，不会立即修改数据库 commit：提交事务，让这个事务中的 sql 立即执行数据的操作 rollback：回滚事务，取消这个事务，这个事务不会对数据库中的数据产生任何影响。 案例：转账过程中发生异常12345678910111213141516171819202122232425# 准备数据mysql&gt; create table account( id int primary key auto_increment, name varchar(20), money double);insert into account values(1,&apos;赵大儿子&apos;,1000);insert into account values(2,&apos;刘大牛&apos;,1000);insert into account values(3,&apos;猪头三&apos;,1000);insert into account values(4,&apos;王进&apos;,1000);insert into account values(5,&apos;黄卉&apos;,1000);# 赵大儿子刘大牛佳转账1000块# 未使用事务update account set money = money - 1000 where id = 1;update account set moneys = money - 1000 where id = 1; # money打错了导致执行失败# 在python中使用事务处理sql = &apos;update account set money = money - 1000 where id = 1;&apos;sql2 = &apos;update account set moneys = money + 1000 where id = 2;&apos; # money打错了导致执行失败try: cursor.execute(sql) cursor.execute(sql2) conn.commit()except: conn.rollback() 注意：事务的回滚的前提是能捕捉到异常，否则无法决定何时回滚，python 中很简单就可以实现，另外 mysql 中需要使用存储过程才可以捕获异常。 存储过程什么是存储过程？存储过程是一组任意的 sql 语句集合，存储在 mysql 中，调用存储过程时将会执行其包含的所有 sql 语句，与 python 中的函数类似。 为什么使用存储过程？回顾触发器与视图其实都是为了简化应用程序中 sql 语句的书写，但是还是需要编写，而存储过程中可以包含任何的 sql 语句，包括视图、事务、控制流程等，这样一来，用用程序可以从 sql 语句中完全解放出来，mysql 可以替代应用程序完成数据相关的逻辑处理。 三种开发方式对比 应用程序仅负责业务逻辑编写，所有与数据相关的逻辑都交给 mysql 来完成，通过存储过程（推荐使用） 优点：应用程序与数据处理完全解耦合，一对复杂的 sql 被封装成了一个简单的存储过程，考虑到网络环境因素，效率高，应用程序开发者不需要编写 sql 语句，开发效率高。 缺点：python 语法与 mysql 语法区别巨大，学习成本高，并且各种数据库的语法大不相同，所以移植性非常差，应用程序开发者与 DBA 的跨部门沟通成本高，造成整体效率低。 应用程序不仅编写业务逻辑，还需要编写所有的 sql 语句 优点：扩展性高，对于应用程序开发者而言，扩展性和维护性相较于第一种都有所提高。 缺点：执行效率低，由于需要将对象的操作转化为 sql 语句，且需要通过网络发送大量的 sql 语句。 创建存储过程语法1234mysql&gt; create procedure pro_name(p_type p_name data_type)beginsql 语句......流程控制end p_type：参数类型 in：表示输入参数 out：表示输出参数 inout：表示既能输入又能输出 p_name：参数名称 data_type：参数类型 mysql 支持的所有数据类型 案例：使用存储过程完成对 student 表的查询12345678910111213delimiter //create procedure p1(in m int,in n int,out res int)begin select *from student where chinese &gt; m and chinese &lt; n; #select *from student where chineseXXX &gt; m and chinese &lt; n; 修改错误的列名以测试执行失败 set res = 100;end//delimiter ;set @res = 0;#调用存储过程call p1(70,80,@res);#查看执行结果select @res; 注意：存储过程的 out 类参数必须是一个变量，用来装输出数据的，不可是一个值 python 中调用存储过程123456789101112131415161718import pymysql#建立连接conn = pymysql.connect( host="127.0.0.1", user="root", password="admin", database="db02")# 获取游标cursor = conn.cursor(pymysql.cursors.DictCursor)# 调用用存储过程cursor.callproc("p1",(70,80,0)) #p1为存储过程名 会自动为为每个值设置变量,名称为 @_p1_0,@_p1_1,@_p1_2# 提取执行结果是否有结果取决于存储过程中的sql语句print(cursor.fetchall())# 获取执行状态cursor.execute("select @_p1_2")print(cursor.fetchone()) 此处 pymysql 会自动将参数都设置一个变量所以可以直接传入一个值，当然值如果作为输出参数的话，传入什么都可以。 删除存储过程1drop procedure 过程名; 修改存储过程的意义不大，不如删除重写。 查看存储过程1234# 当前库所有存储过程名称mysql&gt; select &apos;name&apos; from mysql.proc where db = &apos;db02&apos; and &apos;type&apos; = &apos;procedure&apos;;# 查看创建语句mysql&gt; show create procedure p1; 存储过程中的事务应用存储过程中支持任何的 sql 语句也包括事务。 案例：模拟转账中发送异常，进行回滚操作12345678910111213141516171819202122232425262728293031323334delimiter //create PROCEDURE p5( OUT p_return_code tinyint)BEGIN DECLARE exit handler for sqlexception BEGIN -- ERROR set p_return_code = 1; rollback; END; # exit 也可以换成continue 表示发送异常时继续执行 DECLARE exit handler for sqlwarning BEGIN -- WARNING set p_return_code = 2; rollback; END; START TRANSACTION; update account set money = money - 1000 where id = 1; update account set moneys = money - 1000 where id = 1; # moneys字段导致异常 COMMIT; -- SUCCESS set p_return_code = 0; #0代表执行成功END //delimiter ;#在mysql中调用存储过程set @res=123;call p5(@res);select @res; 总结：抛开沟通成本、学习成本，存储过程无疑是效率最高的处理方式。 函数内置函数在SQL 语句中，表达式可用于一些诸如SELECT语句的ORDER BY 或 DELETE或 UPDATE语句的 WHERE 子句或 SET语句之类的地方。使用文本值、column值、NULL值、函数、 操作符来书 写 表达式。 本章叙述了可用于书写MySQL表达式的函数和操作符。 这些内置函数大大提高了我们的开发效率 字符相关函数 数学相关函数 日期相关函数 其他函数 自定义函数语法123mysql&gt; create function f_name(paramters)return dataTypereturn value; 说明：paramters 只能是 in 输入参数、参数名、类型必须有返回值，不能加 begin 和 end，returns 后面是返回值的类型，这里不加分号，return 后面是要返回的值。 案例：将两数相加1234mysql&gt; create function addfuntion(a int,b int)returns int return a + b;# 执行函数mysql&gt; select addfuntion(1,1); 注意：函数只能返回一个值，函数一般不涉及数据的增删查改，就是一个通用的功能，调用自定义的函数与调用系统的一直，不需要 call 使用 select 可获得返回值，函数中不能使用 sql 语句，就像在 java 中不能识别 sql 语句一样（没学过java。。。） 数据备份使用 mysqldump 程序进行备份1mysqldump -u -p db_name [table_name,,,] &gt; fileName.sql 注意：这是命令行命令 可以选则要备份那些表，如果不指定代表全部备份 12345678910# 示例# 单库备份mysqldump -uroot -p123 db1 &gt; db1.sqlmysqldump -uroot -p123 db1 table table2 &gt; db1-table1-table2.sql# 多库备份mysqldump -uroot -p123 --databases db1 db2 mysql db3 &gt; db1_db2_mysql_db3.sql# 备份所有mysqldump -uroot -p123 --all-databases &gt; all.sql 使用 mysql 进行恢复 退出数据库后 1mysql -u -p &lt; filenam.sql 不用退出数据库 创建空数据库 选择数据库 然后使用 source filename 来进行还原 12mysql&gt; use db1;mysql&gt; source /root/db1.sql 数据库迁移12# 务必保证在相同版本之间迁移mysqldump -h 源ip -uroot -p123 --databases db1 | mysql -h 目标ip -uroot -p456 流程控制if 语句if 条件 then 语句;end if;第二种 if else if 条件 then 语句1;else if 条件 then 语句2;else 语句3;end if; 案例：编写过程实现 输入一个整数 type 范围1-2 输出 type=1 or type=other;12345678910mysql&gt; create procedure showType(in type int,out result char(20))beginif type = 1 then set result = &quot;type = 1&quot;;elseif type = 2 then set result = &quot;type = 2&quot;;else set result = &quot;type = other&quot;;end if;end case 语句与 switch 一样，进行选择执行 12345678mysql&gt; create procedure caseTest(in type int)beginCASE type when 1 then select &quot;type = 1&quot;;when 2 then select &quot;type = 2&quot;;else select &quot;type = other&quot;;end case;end 定义变量12mysql&gt; declare 变量名 类型 default 值;mysql&gt; declare i int default 0; while 循环12345678# 循环输出10次 hello mysqlmysql&gt; create procedure showHello()begindeclare i int default 0;while i &lt; 10 doselect &apos;hello mysql&apos;;end while;end loop 循环没有条件，需要自己定义结束语句 12345678910# 输出10次 hello mysqlmysql&gt; create procedure showLoop()begindeclare i int default 0;aloop:loopselect &apos;hello loop&apos;;set i &gt; 9 then leave aloop;end if;end loop aloop;end repeat 循环1234567891011121314151617181920212223# 类似do while# 输出10次hello repeatmysql&gt; create procedure showRepeat()begindeclare i int default 0;repeatselect &quot;hello repeat&quot;;set i = i + 1;until i &gt; 9end repeat;end# 输出0-100之间的奇数mysql&gt; create procedure showjishu()begindeclare i int default 0;aloop: loopset i = i + 1;if i &gt;= 101 then leave aloop; end if;if i % 2 = 0 then iterate aloop; end if;select i;end loop aloop;end]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库（六）]]></title>
    <url>%2F2018%2F11%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言本篇博客学习 mysql 的用户管理和使用 python 操作 mysql 的一个模块 pymysql。 mysql 用户管理因为数据安全对于互联网公司来说是最重要的，不可能随便分配 root 账户，应该按照不同开发岗位分配不同的账户和权限。 用户管理相关表12mysql&gt; use mysql;mysql&gt; show tables; 用户对数据库的权限顺序mysql 将与用户相关的数据放在 mysql库中， 1user-&gt;db-&gt;tables_priv-&gt;columns_priv 如果用户拥有对所有库的访问权，则存储在 user 中； 如果用户拥有对部分库的使用权，则存储在 db 中； 如果用户拥有对部分表的使用权，则存储在 tables_priv 中； 如果用户拥有对表中某些字段的使用权，则存储在 columns_priv 中。 用户授权设置创建新账户1mysql&gt; create user 用户名@ip identified by &apos;密码&apos;; 1mysql&gt; create user musibii@127.0.0.1 identified by &apos;123&apos;; 创建成功后会在 user 表中查看到： 1mysql&gt; select * from user\G; 这样创建的账户是没有任何权限的，可以看出关于权限字段的值全为 N，接下来需要给 musibii 账号分配权限了。 授予用户最高权限1mysql&gt; grant all on *.* to musibii@127.0.0.1 identified by &apos;123&apos;; 如果 musibii 账号不存在，那么会在授予权限的时候自动创建账号。 现在查看一下 musibii 账号的权限关系： 授予授予权限现在除了 grant_priv 权限其他权限都有了，这个权限是授权权限。通过 root 账户授予： 1mysql&gt; grant all on *.* to musibii@127.0.0.1 identified by &apos;123&apos; with grant option; 现在可以说这个账号就是一个 root 账户，但是只能在本机登陆。 授予在任何地方登陆权限1mysql&gt; grant all on *.* to musibii@&apos;%&apos; identified by &apos;123&apos;; 现在 host 字段对应的值变为了%，意味着可以在任何主机登陆该数据库了。 设置只能访问某个库1mysql&gt; grant all on day46 to eureka@&apos;%&apos; identified by &apos;123&apos;; 这样设置的用户权限信息存储在 db 中，但是不知道为什么在 db 中没有账户信息。。。 设置能能访问某个库中的某个表1mysql&gt; grant all on day46.emp to thales@&apos;%&apos; identified by &apos;123&apos;; 设置只能增删查改权限1mysql&gt; grant select(name) on day46.emp to thales@&apos;%&apos; identified by &apos;123&apos;; 这样 thales 用户就只能对 emp 表中的 name 字段进行查询操作了。 用户收权设置收回某个账号的所有权限1mysql&gt; revoke all privileges [column] on db.table from user@&apos;host&apos;; 1mysql&gt; revoke all privileges on *.* from musibii@&apos;127.0.0.1&apos;; 查询 user 表中的权限信息，发现除了授权权限其他权限都没有了： 不过在修改权限之后需要刷新权限表： 1mysql&gt; flush privileges; 注意：如何授予权限就应该如何收回权限，因为不同的权限存储在不同的表中 删除用户1mysql&gt; drop user 用户名@主机; 当你在云服务器部署了 mysql 环境时，你的程序无法直接连击服务器，需要授予在任意一台电脑登陆的权限 1mysql&gt; grant all on *.* to 用户名@&apos;%&apos; identified by 密码 with grant option; pymysqlpymysql 连接数据库123456789import pymysqlconn = pymysql.connect( host='127.0.0.1', port=3306, user='root', password='123', database='day46', charset='utf8') 操作数据库cursor 游标对象，负责执行 sql 语句，获取返回的数据 12345678910cursor = conn.cursor()sql = 'select *from emp'res = cursor.execute(sql) # 返回值是本次查询的记录条数# 获取一条记录print(cursor.fetchone())# 接着获取print(cursor.fetchone())# 提取所有结果print(cursor.fetchall()) 1print(fetchamany(3)) 运行结果 ((3, ‘关羽’, ‘男’, ‘市场’, ‘员工’, 4000.0), (4, ‘孙权’, ‘男’, ‘行政’, ‘总监’, 6000.0), (5, ‘周瑜’, ‘男’, ‘行政’, ‘员工’, 5000.0)) 参数是指定获取的数据条数。 控制游标位置12cursor.scroll(1,mode='relative) # 游标从当前位置往后移动一条记录cursor.scroll(1,mode='absolute') # 游标从开始位置往后移动一条记录 获取结果使用字典表示指定使用字典类型的游标，默认是元祖类型 1cursor = conn.cursor(pymysql.cursor.DictCursor) 在 python 使用代码执行了增删查改后只是在内存中修改了值，想要修改数据库中的值需要提交操作 1conn.commit() 这样修改的值才会改变。 #sql 注入 1234567891011121314151617181920212223import pymysqlconn = pymysql.connect( host='127.0.0.1', port=3306, user='root', password='password', database='day46', charset='utf8')cursor = conn.cursor(pymysql.cursors.DictCursor)name = input('用户名')pwd = input('密码')sql = 'select * from user where name = "%s" and pwd = "%s"' % (name, password)res = cursor.execute(sql)if res: print('登陆成功')else: print('登陆失败') 注入写法 避免方式： 再输入时加上正则判断，不允许输入与 sql 相关的关键词。这种方式无法避免代理服务器发起的攻击； 2.在服务端，执行 sql 前进行判断。 pymysql 中已经做了处理，只要将参数的拼接交给 mysql 来完成就能够避免攻击。 代码实现123456name = input('用户名')pwd = input('密码')sql = 'select * from user where name = %s and password = %s'res = cursor.execute(sql, (name,pwd)) # 这样执行 sql 语句就可以避免攻击。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库（五）]]></title>
    <url>%2F2018%2F11%2F23%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言经过几天数据库的学习，总感觉自己只是会敲写增删查改语句而已，对数据库的内部执行情况并不了解，以及执行顺序，查询原理等，所以想对 MySQL 内部的一些原理加深一下了解。 MySQL 语句执行顺序MySQL 语句一共分为11不，如下图所示，最先执行的永远是 FROM，最后执行的是 LIMIT 操作。其中每一个操作都会产生一张虚拟的表（虚拟表想要在下次查询使用需要取别名），这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一张虚拟表才会作为结果返回。如果没有在语句中指定某一个子句，那么会跳过相应的步骤。 来分析以下具体查询的每一个阶段 from：对 from 左边的表和右边的表计算笛卡尔积。产生虚拟表 VT1； on：对虚拟表 VT1进行 on 筛选，只有符合\&lt;join-condition>的行才会被记录在虚拟表 VT2中； join：如果指定了 OUTER JOIN（比如 left join、right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表 VT2中，产生虚拟表 VT3，rug from 子句中包含两个以上的表的话，那么就会对上一个 join 连接产生的结果 VT3和下一个表重复执行步骤1~3这三个步骤，一直处理完所有的表为止； where：对虚拟表 VT3进行 where 条件过滤。只有符合\&lt;where-condition>的记录才会被插入到虚拟表 VT4中； group by：根据 group by 子句中的列，对 VT4中的记录进行分组操作，产生 VT5； cube|rollup：对虚拟表 VT5进行 cube 或 rollup 操作，产生虚拟表 VT6； having：对虚拟表 VT6应用 having 过滤，只有符合\&lt;having-condition>的记录才会被插入到虚拟表 VT7中； select：执行 select 操作，选择指定的列，插入到虚拟表 VT8中； distinct：对 VT8中的记录进行去重，产生虚拟表 VT9； order by：对虚拟表 VT9中的记录按照\&lt;order-by-list>进行排序操作，产生虚拟表 VT10； limit：取出指定行的记录，产生虚拟表 VT11，并将结果返回。 MySQL 语句执行过程下面是 MySQL 的基本架构示意图,从中可以很清楚的看到 SQL 语句在 MySQL 的各个功能模块中的执行过程. 大体来说, MySQL 可以分为 Server 层和存储引擎两部分.Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数字和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MylSAM、Memory等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL5.5.5版本开始成为了默认存储引擎。也就是说，你在执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，可以通过指定存储引擎的类型来选择其他的引擎，比如在 create table 语句中使用 engine=memeory，来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同。从上图中可以看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行期的部分。 连接器第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。这时候命令是这么写的： 1mysql -h$ip -P$port -u$user -p 输完命令后，就需要在交互对话中输入密码。连接命令中的 mysql 是客户端工具，用来根服务端建立连接。在完成经典的 TCP 握手后，连接器就开始认证身份，这个时候用的就是你输入的用户名和密码。 如果用户名或密码不对，会返回’Access denied for user’的错误，然后客户端程序结束。 如果用户名密码认证通过，连接器会到权限表里面查看用户拥有的权限。之后，这个链接里面的权限判断逻辑，都依赖于此时读到的权限。这意味着修改权限不会立马有效，需要重新连接服务器才会生效。 连接完成后，如果没有后续的动作，这个链接就处于空闲状态，你可以在 show processlist 命令中看到它。如下所示，其中的 Command 列显示为Query，表示现在系统里面有一个查询链接。 客户端如果太长时间不活跃，连接器就会自动断开连接。这个时间由参数 wiait_timeout 控制，默认为8小时。如果连接断开，客户端再次发送请求时，会收到错误提醒：Lost connection to MySQL server during query。这时候如果要继续连接，就需要重连，然后执行查询。数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询重建一个。建立连接的过程通常是比较复杂的，所以在使用中尽量减少建立连接的动作，也就是尽量使用长连接。但是全部使用长连接后，会发现 MySQL 占用内存涨的特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开才会释放，所以如果大量的长连接积累的话，会导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。怎么解决这个问题呢？有两种方案。 定期断开长连接。使用一段时间，或者程序里面判断执行过占用内存的大查询后，断开连接，之后要查询再连接。 如果使用的是5.7及以后的版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接回复到刚刚创建完时的状态。 查询缓存连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。MySQL 拿到一个查询请求后，会先到查询内存查看，之前是否执行过这条语句。之前执行过的语句及其结果可能会以 key-value 的形式存储在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会直接返回给客户端。如果之前没有执行过这条语句，就会执行后面的执行阶段。执行完成后，执行结果会存入查询缓存。这样的优点是，如果查询缓存命中，不需要执行后面的复杂操作，就可以直接返回结果，效率会极大地提高。但是大多数情况不建议使用查询缓存，因为查询缓存往往利大于弊。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能费劲存储的缓存，还没使用就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非所有的业务是一张静态表，很长时间更新一次。比如一个系统配置表，那这张表上的查询才适合使用查询缓存。好在 MySQL 提供了按需使用的方式。可以将参数query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显示指定，像下面这个语句一样： 1mysql&gt; select SQL_CACHE * from T where ID=10; 不过在最新的8.0版本这功能被删了。 分析器如果没有命中查询缓存，就要开始真正的执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。分析器首先会做‘’词法分析‘’，你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL需要识别出里面的字符串分别是什么，代表什么。MySQL 从你输入的‘’select‘’这个关键词识别出来，这是一个查询语句。它也要把字符串‘’T‘’识别成‘’表名T‘’，把字符串‘’ID‘’识别成‘’列 ID‘’。做完了这些识别以后，就要做‘’语法分析‘’。根据此法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果你的语句不对，就会收到‘’You have an error in your SQL syntax‘’的错误提醒。一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接‘’use near‘’的内容。 优化器经过了分析器，MySQL 就知道要做什么了。在开始执行之前，还要经过优化器的处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如下面这个语句，是执行两个表的 join： 1mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20; 既可以先从表 t1中取出 c=10 记录的ID 值，在根据 ID 值关联到表 t2，再判断 t2里面 d 的值是否等于20。 也可以先从表 t2里面取出 d=20记录的 ID 值，在根据 ID 值关联到 t1，再判断 t1里面 c 的值是否等于10。 这两种执行方案的逻辑结果是一样的，但是效率会有不同，而优化器的作用就是决定选择使用哪个方案。 优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。 执行器MySQL 通过分析器知道了要做什么，通过了优化器知道怎么做，于是就进入了执行器阶段，开始执行语句。开始执行的时候，需要先判断用户对表 T 是否拥有查询权限，如果没有，就会返回没有权限的错误。 12mysql&gt; select * from T where ID=10;ERROR 1142 (42000): SELECT command denied to user &apos;b&apos;@&apos;localhost&apos; for table &apos;T&apos; 如果有权限，就打开表继续执行。打开表的时候，执行器会根据表的引擎定义，去使用该引擎提供的接口。比如表 T 中，ID 字段么有索引，那么执行期的执行流程是这样的： 调用 InnoDB 引擎接口取该表的第一行，判断 ID 值是否为10，如果不是则跳过，如果是则将这行存在结果集中； 调用引擎接口取‘’下一行‘’，重复相同的判断逻辑，直到取到这个表的最后一行。 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 至此，该语句执行结束。 对于有索引的表，执行的逻辑差不多。第一次调用的是‘’取满足条件的第一行‘’这个接口，之后循环取‘’满足条件的下一行‘’这个接口，这些接口都是引擎中已经定义好的。 你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。 在某些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟rows_examined 并不是完全相同的。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库（四）]]></title>
    <url>%2F2018%2F11%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言昨天学习了表与表之间的关系、多表关联、复制表、单表查询的知识，今天学习的内容是单表查询与关键词的执行顺序、正则表达式以及最重要的多表查询。 数据库增删改增1insert [into] 表名[(可选字段名)] values(一组值1),(一组值2),...; into 可以省略，表名后的字段可选，如果写了后面的 values 中的值必须与表名后的字段意义对应，如果没写后面的 values 中的值必须与表的所有字段一一对应，values后面可以给出多组值并用逗号隔开。 删1delete from 表名[where 条件]; 如果条件不写的话是删除所有记录，不过这样删除表的效率很低，因为是一行行删除数据，自增的 id不会归零。使用truncate 是重建表，先记录表结构然后删除整个表再重新建表出来，自增的 id 会归零。 改1update 表名 set 字段名 = 值,[,字段2 = 值2],[where 条件]; 可以一次性修改多个字段的值，值之间需要用逗号隔开；如果不写条件的话就是修改所有记录。 单表查询不带关键字的查询1select (*|字段名|四则运算|聚合函数) from 表名 [where 条件]; 准备数据 1234567891011mysql&gt; create table stu(id int primary key auto_increment, name char(10), math int, english int);mysql&gt; insert into stu values(null,&apos;赵云&apos;,90,30);mysql&gt; insert into stu values(null,&apos;小乔&apos;,90,60);mysql&gt; insert into stu values(null,&apos;小乔&apos;,90.60);mysql&gt; insert into stu values(null,&apos;大乔&apos;,10,70);mysql&gt; insert into stu values(null,&apos;李清照&apos;,100,100);mysql&gt; insert into stu values(null,&apos;铁拐李&apos;,20,55);mysql&gt; insert into stu values(null,&apos;小李子&apos;,20,55); * 表示查询所有字段 1mysql&gt; select * from stu; 字段名 可以手动指定要查询的字段 1mysql&gt; select engish from stu; 字段的值可以进行加减乘除 统计总分 1mysql&gt; select math+ english from stu; 如果觉得 math+english 名字太长也可以取别名 1mysql&gt; select math+english [as] 总分 from stu; as可以省略 给英语成绩加分 1mysql&gt; select english+10 from stu; 聚合函数 用于统计 什么是聚合函数，将多个数据进行计算，并得到一个结果，称为聚合 聚合函数： 注意不能再 where 后面使用聚合函数，因为 where 相当于打开文件然后读取文件中的数据，而使用聚合函数很显然需要多个值来聚合，那么没有读取完数据就使用不了聚合函数，所以这时候应该使用 on，所以聚合函数不能写在 where 后面,where会最先执行，它的作用是读取数据并过滤 sum 1mysql&gt; select sum(salary) from emp; count 1mysql&gt; select count(*) from emp group by dept; avg 1mysql&gt; select avg(salary) from emp; max/min 12mysql&gt; select max(salary) from emp;mysql&gt; select min(salary) from emp; 结合使用： 1mysql&gt; select dept,count(name) from emp group by dept; where 是可选的 关键字的执行顺序from用于打开文件 distinct去除重复数据，所有数据全都重复才算重复 1mysql&gt; select distinct * from stu; where对读取的数据进行过滤 where 后面跟的条件比较多： between and1mysql&gt; select * from stu where english between 70 and 80; in1mysql&gt; select * from stu where math in (89,90,91); like1mysql&gt; select * from stu where name like &apos;李%&apos;; and1mysql&gt; select * from stu where math &gt; 80 and english &gt; 80; 1mysql&gt; select * from stu where math &gt; 60 and english &lt; 60; group by对数据进行分组，为了进行统计。group by 后面可以有多个分组依据，会按照顺序执行 准备数据 1234567891011121314151617mysql&gt; create table emp( id int, name char(10), sex char, dept char(10), job char(10), salary double);mysql&gt; insert into emp values( (1,&apos;刘备&apos;,&apos;男&apos;,&apos;市场&apos;,&apos;总监&apos;,5800), (2,&apos;张飞&apos;,&apos;男&apos;,&apos;市场&apos;,&apos;员工&apos;,3000), (3,&apos;关羽&apos;,&apos;男&apos;,&apos;市场&apos;,&apos;员工&apos;,4000), (4,&apos;孙权&apos;,&apos;男&apos;,&apos;行政&apos;,&apos;总监&apos;,6000), (5,&apos;周瑜&apos;,&apos;男&apos;,&apos;行政&apos;,&apos;员工&apos;,5000), (6,&apos;小乔&apos;,&apos;女&apos;,&apos;行政&apos;,&apos;员工&apos;,4000), (7,&apos;曹操&apos;,&apos;男&apos;,&apos;财务&apos;,&apos;总监&apos;,10000), (8,&apos;司马懿&apos;,&apos;男&apos;,&apos;财务&apos;,&apos;员工&apos;,6000) ); 查看所有部门1mysql&gt; select dept from emp group by dept; 分组后，组里的详细记录就被隐藏起来了，不能直接查看，dept 分组就变成三条记录，每个组中会包含隐藏的记录，没办法显示，如果一定想显示的话，可以使用 group_concat(字段名)，可以将多个值拼接为一个值： 1mysql&gt; select dept,group_concat(name) from emp group by dept; 注意：只有出现在 group by 后面的字段，才可以通过 select 显示出来，其他的都被隐藏了。在 mysql5.6分组后会默认显示每组的第一条记录，5.7不显示，因为5.7中sql_mode中就是ONLY_FULL_GROUP_BY 查看每个部分有多少人1mysql&gt; select dept,count(name) from emp group by dept; 计算每个部门的平均薪资1mysql&gt; select dept,avg(salary) from emp group by dept; 取别名 1mysql&gt; select dept,avg(salary) 平均工资 from emp group by dept; 计算每个岗位的平均工资1mysql&gt; select job,avg(salary) from emp group by job; 计算每个部门每个岗位的平均工资1mysql&gt; select dept,job,avg(salary) from emp group by dept,job; 查询平均工资大于5000的部门1mysql&gt; select dept from emp where avg(salary) &gt; 5000; 这样写是不行的，因为 where 相当于一条条从文件中读取数据，而数据没有读取完是不能做平均值计算的，这时候就需要用 having 了。 having对分组后的数据进行过滤，作用与 where 相同，用于过滤。不通电在于，where 是从文件读取数据时的过滤条件，这导致了 where中不能使用聚合函数。 计算工资平均值大于5000的部门1mysql&gt; select dept,avg(salary) from emp group by dept having avg(salary) &gt; 5000; 总结：select 语法是有执行顺序的，按照从左到右的顺序执行，所以 where 会在执行完成之前用不了聚合函数 查询岗位平均薪资高于6000的岗位名称和平均薪资1mysql&gt; select job,avg(salary) from emp group by job having avg(salary) &gt; 6000; 查询部门人数少于3的部门名称人员名称和人员个数1mysql&gt; select dept,group_concat(name),count(*) from emp group by dept having count(name) &lt; 3; order by对结果排序 asc 表示升序，是默认的 desc 表示降序 by 后面可以有多个排序 按照工资排序1mysql&gt; select * from emp order by salary; 按照工资降序排序1mysql&gt; select * from emp order by salary desc; 按照工资升序 id 降序排序1mysql&gt; select * from emp order by salary,id desc; 按照工资升序 id 升序排序1mysql&gt; select * from emp order by salary,id; limit指定获取数据条数 使用方法： ​ limit a,b;表示从 a 开始不包括 a，获取 b 个数据。 1mysql&gt; select * from emp limit a,b; 1mysql&gt; select * from emp limit 2,2; 分页查询计算页数起始位置的算法 每页显示a条，现在是第 b 页，求起始位置 1(b - 1) * a 字符串拼接 完整的select语句123456mysql&gt; select [distinct] 查询字段1、查询字段2…… from 表名 [where 查询之前的过滤条件 group by 分组依据 having 分组之后的过滤条件 order by 排序字段 limit]; 显示条数 注意在书写时，必须按照这个顺序来写 正则表达式匹配^ 匹配字段名称以’张’开头的数据1mysql&gt; select * from emp where name regexp &apos;^张&apos;; $ 匹配字段名称以’飞’结尾的数据1mysql&gt; select * from emp where name regexp &apos;飞$&apos;; . 匹配字段名称第二位后包含’飞’的数据，‘’.‘’表示任意字符1mysql&gt; select * from emp where name regexp &apos;.飞&apos;; [abci] 匹配字段名称中含有指定集合内容的人员1mysql&gt; select * from emp where name regexp &apos;[张飞关羽刘备]&apos;; [^alex] 匹配不符合集合中条件的内容，^表示取反 注意1：^只有在[]内才是取反的意思，在别的地方都是表示从开始处匹配 注意2：简单理解 name regexp ‘[^alex]’ 等价于 name!=’alex’ ‘a|x’ 匹配条件中的任意值1mysql&gt; select * from emp where name regexp &apos;张飞|关羽&apos;; 查询以 张开头以飞结尾的数据1mysql&gt; select * from emp where name regexp &apos;^张.*飞$&apos;; MySQL 中使用 regexp 操作符来进行正则表达式匹配。 模式^ 匹配输入字符串的开始位置 $ 匹配输入字符串的结束位置 . 匹配任何字符 […] 字符集合。匹配所包含的任意一个字符。例如，’[abc]’ 可以匹配 ‘plain’ 中的 ‘a’ [^…] 负值字符集合。匹配未包含的任意字符。例如，’[^abc]’ 可以匹配 ‘plain’ 中的 ‘p’ p1|p2|p3 匹配 p1 或 p2 或 p3.例如，’z|food’ 能匹配 ‘z’ 或 ‘food’。’(z|f)ood’ 则匹配 ‘zood’ 或 ‘food’ 多表查询笛卡尔积查询1mysql&gt; select * from 表1,...表n; 查询结果是将坐标中的每条记录与右表中的每条记录都关联以遍，假如 a 表有 m 条记录，b 表有 n 条记录，则笛卡尔积结果为 m*n。 数据准备 1234mysql&gt; create table empl (id int,name char(10),sex char,dept_id int); insert empl values(1,&quot;大黄&quot;,&quot;m&quot;,1); insert empl values(2,&quot;老王&quot;,&quot;m&quot;,2); insert empl values(3,&quot;老李&quot;,&quot;w&quot;,30); 1234mysql&gt; create table deptl (id int,name char(10)); insert deptl values(1,&apos;市场&apos;); insert deptl values(2,&apos;财务&apos;); insert deptl values(3,&apos;行政&apos;); 1mysql&gt; select * from empl,deptl; 因为笛卡尔积查询会产生很多错误数据，所以需要经过筛选出正确的关联关系。 1mysql&gt; select * from empl,deptl where empl.dept_id = deptl.id; 内连接查询就是笛卡尔积查询 1mysql&gt; select * from empl [inner] join deptl; 加上筛选条件 1mysql&gt; select * from empl [inner] join deptl where empl.dept_id = deptl.id; 左外连接查询1mysql&gt; select * from empl left join deptl on empl.dept_id = deptl.id; 左表数据全部显示，右表只显示匹配上的数据。 on 关键词和 where 关键词都是用于条件过滤，没有本质区别。在单表中 where 的作用是筛选过滤条件；在多表中 where 连接多表，满足条件就连接，不满足就不连接。于是为了区分单表还是多表换用了 on 关键词。只要是连接多表的条件就使用 on。 右外连接查询1mysql&gt; select * from empl right join deptl on empl.dept_id = deptl.id; 右表数据全部显示，左表只显示匹配上的数据。 内连接和外连接的理解：内指的是匹配上的数据，外指的是没匹配上的数据。 全外连接显示1mysql&gt; select * from empl full join deptl on empl.dept_id = deptl.id; # mysql 不支持 合并查询结果(全外连接)123mysql&gt; select * from empl left join deptl on empl.dept_id = deptl.id union select * from empl right join deptl on empl.dept_id = deptl.id; union 会去除重复数据，且只能合并字段数量相同的表；如果不想去除重复数据，使用 union all 123mysql&gt; select * from empl left join deptl on empl.dept_id = deptl.id union all select * from empl right join deptl on empl.dept_id = deptl.id; 三表查询数据准备 12mysql&gt; create table stul(id int primary key auto_increment,name char(10));mysql&gt; create table teal(id int primary key auto_increment,name char(10)); 创建中间表 1234567mysql&gt; create table tsr(id int primary key auto_increment, t_id int,s_id int, foreign key(s_id) references stul(id), foreign key(t_id) references teal(id));mysql&gt; insert into stul values(null,&apos;张三&apos;),(null,&apos;李四&apos;);mysql&gt; insert into teal values(null,&apos;musibii&apos;),(null,&apos;thales&apos;);mysql&gt; insert into tsr values(null,1,1),(null,1,2)(null,2,2); 查询 musibii 教过那些学生12mysql&gt; select * from stul join teal join tsr on stul.id = tsr.s_id and teal.id = tsr.t_id where teal.name = &apos;musibii&apos;; 多表查询总结： 把所有表连接起来 加上连接条件 如果有别的过滤条件，加上 where 子查询 当一个查询的结果是另一个查询的条件是，这个查询称之为子查询（内层查询）。 什么时候使用子查询？ 当一次查询无法得到想要的结果时，需要多次查询。这样可以分多步查询减少查询的复杂度。 数据准备 12345678910mysql&gt; create table emps(id int,name char(10),sex char,age int,dept_id int, job char(10),salary double);mysql&gt; insert into emps values (1,&apos;刘备&apos;,&apos;男&apos;,26,1,&apos;总监&apos;,5800), (2,&apos;张飞&apos;,&apos;男&apos;,24,1,&apos;员工&apos;,3000), (3,&apos;关羽&apos;,&apos;男&apos;,30,1,&apos;员工&apos;,4000), (4,&apos;孙权&apos;,&apos;男&apos;,25,2,&apos;总监&apos;,6000), (5,&apos;周瑜&apos;,&apos;男&apos;,22,2,&apos;员工&apos;,5000), (6,&apos;小乔&apos;,&apos;女&apos;,31,2,&apos;员工&apos;,4000), (7,&apos;曹操&apos;,&apos;男&apos;,40,3,&apos;总监&apos;,10000), (8,&apos;司马懿&apos;,&apos;男&apos;,46,3,&apos;员工&apos;,6000); 12mysql&gt; create table depts(id int primary key,name char(10));mysql&gt; insert into depts values(1,&apos;市场&apos;),(2,&apos;行政&apos;),(3,&apos;财务&apos;); 查询市场部人员1mysql&gt; select * from emps where dept_id = (select id from depts where name = &apos;市场&apos;); 子查询思路： 将一个复杂的问题 拆分为多个简单的问题 把一个复杂的查询 拆分为多个简单的查询 就比如查询部门人员： 查询部门 id 拿着 id 去员工表查询 1mysql&gt; select emps.name from emps join dept on dept.id = emps.dept_id where depts.name = &apos;财务&apos;; 查询平均年龄大于26的部门名称1mysql&gt; select * from depts where id in (select dept_id from emps group by dept_id having avg(age) &gt; 26); 12mysql&gt; select depts.name from depts join emps on emps.dept_id = depts.id group by depts.name having avg(age) &gt; 26; exists 关键词查询exists 后跟子查询，子查询有结果时为 True，没有结果是为 False，为 True 时外层执行，为 False 时外层不执行 1mysql&gt; select * from emps where exists(select * from emps where salary &gt; 1000); 综合练习查询每个部门工资最高的员工信息12345mysql&gt; select * from emps join # 使用子查询得到每个部门的 id 以及部门的最高工资，形成一个虚拟表把原始表和虚拟表连接在一起 (select dept_id,max(salary) as m from emps group by dept_id) as t1 # 如果这个人的部门编号等于虚拟表中的部门编号，并且这个人的工资等于虚拟表中的最高工资，就是要找的数据 on emps.dept_id = t1.dept_id and emps.salary = t1.m;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>day46</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库（三）]]></title>
    <url>%2F2018%2F11%2F21%2F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言本篇博客主要内容为表之间的关系、多表关联、复制表；查询如单表查询、多表关联查询 表之间关系为什么要分表？假如现在有两种数据，一种是部门数据一种是员工数据，如果两中数据放在同一张表中则会造成： 数据重复 结构混乱 扩展维护性差 需要分表 所以需要把表中会造成混乱的数据分出来，分成两张表。 1mysql&gt; create table dept(id int primary key auto_increment,name char(20),job char(20)); 1mysql&gt; create table emp(id int primary key auto_increment,name char(20),gender char,age int,salary float,d_id int); 什么时候需要分表？ 当出现大量重复数据时，当一条记录中的数据不属于同一类时需要分表。 分表之后产生的问题，员工表可以存储一个不存在的部门编号，这样的数据是不完整的无效数据，必须找到一种方法可以在物理层面建立关联关系。 以上建表语句可以建立逻辑上的关联关系，这有建表的人才明白其中的关系，而 mysql 并不知道关系，所以需要通过外键来进行约束，说明这两张表的关联关系。 ##外键的使用 1mysql&gt; create table 表名(字段名 类型(长度),foreign key(外键的字段名) references 要关联表名(主键名)); 使用外键时必须分清主从关系，也就是要分清先键那张表，因为在使用外键关联表时，需要知道对方表的表名，所以要关联的表应该是主表，应该先建主表，这样才能关联起来。 外键的第一个约束先键主表，再建从表 1mysql&gt; create table dept(id int primary key auto_increment,name char(20),job char(20)); 1mysql&gt; create table emp(id int primary key auto_increment,name char(20),d_id int,foreign key(d_id) references dept(id)); 外键的第二个约束数据先插入主表，再插入从表数据 1mysql&gt; insert into dept values(1,&apos;hr&apos;,&apos;招聘&apos;); 1mysql&gt; insert into emp values(1,&apos;张无忌&apos;,1); 外键的第三个约束删除数据时先删从表，再删主表 1mysql&gt; delete from emp where name = &apos;张无忌&apos;; 1mysql&gt; delete from dept where id = 1; 外键的第四个约束从表更新外键时必须保证外键是存在的。 外键的第五个约束更新主表的 id 时，要么先删除从表关联的数据，或者把关联数据关联到其他的主表 id。 有了这几种约束后，可以保证数据的完整性。相应的受到外键约束，主表的删除和更新操作受到限制，很多情况下，删除主表某个数据需要至少两条sql 语句，会很麻烦。 外键的第六个约束删除主表时，要先删除从表。 级联操作删除级联当主表删除时，从表相关联的记录同步删除 1mysql&gt; create table emp(id int primary key auto_increment,name char(20),d_id int,foreign key(d_id) references dept(id) on delete cascade); 更新级联当主表 id 时，从表相关联的记录通步更新 1mysql&gt; create table emp(id int primary key auto_increment,name char(20),d_id int,foreign key(d_id) references dept(id) on update cascade); 级联方向只能是主表级联从表，可以在操作主表时自动操作从表。（单箱操作，主表变化是级联操作从表，从表的变化不会影响主表） 一对一关系一对一的关系只需要加一个外键来关联即可，但是需要给外键加上唯一约束。有主从关系的都需要先建主表。 1mysql&gt; create customer(c_id int primary key auto_increment,name char(20),phonenum char(11),addr char(20)); 1mysql&gt; create student(s_id int primary key auto_increment,name char(20),class char(11),number char(20),housenum char(20),c_id int unique,foreign key(c_id) references customer(c_id)); 一对一的另一种使用场景，当一个表的字段太多，而常用的字段不多时，可以采取垂直分表的方式来提高效率，比如个人信息有身份证、性别、年龄、地址等，可以拆分为基础信息和细节信息；也有另一种提升效率的方式，水平分表，当一个表中的数据记录太多时，效率会降低，可以采取水平分表，字段完全相同。 多对多关系假如有两张表，一张表存的是老师，另一张表存的是学生。因为一个老师可以教多个学生，一个学生也可以有多个老师，所以这是双向多对一的关系，也就是多对多的关系。那么应该怎么存储数据呢？ 可以通过增加一个中间表来存储两张表的关系，然后其他两张表分别用一个字段作为外键来关联中间表。（只要是多对多关系都是靠中间表来存储两张表之间的关系）除了中间表，另外两张都是主表，具体先建哪种主表没有先后顺序。多对多关系至少需要三张表。 1mysql&gt; create table stu(id int primary key auto_increment,name char(20)); 1mysql&gt; create table tea(id int primary key auto_increment,name char(20)); 1mysql&gt; create table tsr(id int primary key auto_increment，t_id int,s_id int,foreign key(t_id) references tea(id),foreign key(s_id) references stu(id)); 因为老师和学生都是主表，关系表是从表，所以需要先插入老师和学生的数据，接着插入中间表的数据。 多对多关系表中因为已经有了 id 为主键，所以可以重复存入相同的学生和老师关系数据，可以通过联合主键改变。 多对一关系1mysql&gt; create table dept(id int primary key auto_increment,name char(20),job char(20)); 1mysql&gt; create table emp(id int primary key auto_increment,name char(20),d_id int,foreign key(d_id) references dept(id)); 复制表1mysql&gt; create table 新表名 select * from 被复制的表名; 注意不会复制主键和约束条件，数据结构都可以复制。 1mysql&gt; create table 新表名 select * from 源表名 where 1 = 2; 当where 后面条件不成立时，只会复制表结构。 蠕虫复制自我复制。 1mysql&gt; insert into 表名 select * from 表名; 如果有主键 1mysql&gt; insert into 表名(其他字段) select 其他字段 from 表名; 在日常开发中，如果对性能要求很高，不应该使用外键 效率降低 耦合 关系多起来会造成管理麻烦 这时候关系只是逻辑关系很有可能产生错误数据。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库（二）]]></title>
    <url>%2F2018%2F11%2F20%2F%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[前言本篇博客学习数据库的详细建表语句，数据库数据类型以及约束条件。 详细建表语句在介绍建表语句之前需要了解一下存储引擎。 存储引擎MySQL 支持的存储引擎有以下几种： 以后我们使用的就只有 InnoDB 引擎，可以看到默认情况下存储引擎就是 InnoDB，建立一个表的时候，可以看看在文件夹里发生了什么。 1mysql&gt; create table t1(id int, name char); 建表成功后在文件夹里多了两个文件： t1.frm t1.ibd frm是 frame 的缩写是表示该表的数据结构，而 ibd 表示 InnoDB data 表示存储的是 InnoDB 引擎的数据。 存储引擎就相当于一个用来存取数据的软件。 指定以某种存储引擎建表 1create table t2(id int name char)engine=memory; 建表语句创建表的完整语法，中括号里面的表示可选参数。 1234create table 表名(字段1 数据类型[(宽度) 约束条件],字段2 数据类型[(宽度) 约束条件],字段3 数据类型[(宽度) 约束条件]); 最后一个字段后面不能加逗号，否则会报错。 类型：使用限制字段必须以什么样的数据类型传值 约束条件：约束条件是在类型之外添加一种额外的限制。 注意 在同一张表中，字段名不能相同； 宽度和约束条件可选，字段名和类型是必须的； 最后一个字段后不加逗号。 数据类型整型：int、tinyint、bigint等 整型默认是有符号的，可以通过约束条件改变（unsigned）； 1mysql&gt; create table t3(x tinyint unsigned); 可选参数里面的宽度只有整型表示的是显示宽度，其他的都表示存储限制。 1mysql&gt; create table t4(x int(8) unsigned zerofill); 显示时不够八位的使用0填充，如果超过八位正常显示。 如果不指定限制宽度会有默认值： 1mysql&gt; create table t5(id int unsigned); 如果是有符号的整型，则会比无符号的多一位，因为要显示正负号。 1mysql&gt; create table t6(id int); 强调：对于整型来说，数据类型后的宽度并不是存储限制，而是显示限制。所以在创建表示，如果字段采用的是整型类型，完全无需指定显示宽度，默认的显示宽度，足够显示完整当初存放的数据。 浮点型：float、double、decimal等float 4字节 double 8字节 decimal 不固定 1mysql&gt; create table t7(num float(m,d)); m 表示总长度 d 表示小数部分长度 长度表示的是字符长度而不是数据存储范围。 各个类型的最大长度 float (255,30) double (255,30) decimal (65,30) 区别 float 与 double 的精度不同，都是不准确的小数，decimal 准确的小数不会丢失精度 具体使用哪种类型得需要使用场景判断 float 满足大部分使用场景，decimal 适合银行系统，科学研究。 括号中 m 和 d 的值，可以限制数据存储范围，与整型不同 重点：记住 m 和 d 的含义。 字符型常用两种 ​ char 定长字符串 ​ varchar 可变长度字符串 注意：字符串中，长度指定的是数据的字符长度，与字节没有关系，在创建时 varchar 必须指定，char 有默认值。 不同点： ​ char 类型在取数据时，根据长度来获取，不关心真实数据长度 ​ 无论数据有多长，占用的空间是固定的，造成了一定空间浪费。 ​ varchar 类型在取数据时，先获取数据长度，在根据长度获取真实数据时也关心真实数据长度，先存储长度需要一个字节，在存储真实数据不会浪费空间，但是由于需要计算数据的长度，所以存取速度会比定长慢。 相同点： ​ 括号中的数字，都是表示存储最大字符长度。 char 使用频率更高。 mysql 会在存储数据时自动将数据末尾的空格去掉，如果必须要存空格，需要修改 sql_mode 增加PAD_CHAR_TO_FULL_LENGTH 意思是把空格当做有效数据。 由于自动去除空格这个机制，在使用等于符号和 like 时有区别： ​ select * from t1 where name = ‘yh ‘; ​ 会自动去除空格 ​ select * from t1 where name like ‘yh’; ​ like 用于模糊匹配，使用%表示0或任意个字符 ​ 使用_表示一个任意字符。 日期类型year time date datetime timestamp Timestamp 特点是可以给 null 自动输入当前时间 当这条记录被修改了会自动更新当前时间 集合与枚举类型枚举​ enum 可以指定一堆字符串的值，在插入数据时 ​ 数据必须在堆字符串中的其中一个（‘’男的‘’，‘’女的‘’）多选一 集合​ set 可以指定一堆字符串的值 再插入数据时 ​ 数据必须这堆字符串中的其中一个（‘’男的‘’，‘’女的‘’）多选一 共同点：数据都是字符串类型 约束条件是一种对数据的限制。 约束的作用？ ​ 为了保证数据的正确性，完整性 ​ 例如要存出密码 char(20) 只限制了类型和长度，无法保证数据的正确性。 额外的约束语法： ​ 创建时指定约束 ​ create table 表名称(字段名 类型(长度) 约束名称1,约束名称n,…) ​ 后期修改的方式添加 约束 ​ alter table 表名称 modify 字段名 类型(长度) 约束名称1 约束名称n,… NOT NULL 非空约束 限制该字段的值不能为空UNIQUE 唯一性约束 限制该字段的值是唯一的不能出现重复DEFAULT 默认值约束 如果插入数据时没有指定该字段的值则使用默认值PRIMARY KEY 主键约束 限制该字段 不能为空 并且是唯一的 可以唯一标识一条数据 *FOREIGN KEY 外键约束 用来指向另一个表的主键 每个表都应该有一个主键，需要唯一标识，否则可能出现完全相同的两个数据，无法区分 UNIQUE 不能重复，但是可以为空，这样的话不能唯一标识。 UNIQUE NOT NULL 不能为空且唯一 可以唯一标识一条数据，书写顺序无所谓。 UNIQUE NOT NULL 与主键的区别 ​ UNIQUE NOT NULL 不能被其他表引用（不能作为其他表的外键） ​ UNIQUE NOT NULL 约束 一个表中可以有多个，但是主键只能有一个。 联合唯一： 索引：用于加速查询 InnoDB 中索引是树形结构 ​ 为了提高查询效率，InnoDB 会找一个不为空且惟一的字段作为主键 ​ 如果表中不存在这样的字段，会自动帮你建一个隐藏逐渐字段，但是无法提升查询效率。 ​ 只要是使用 InnoDB，就应该为每个表指定一个非空且唯一的字段，InnoDB 组织数据时，首先使用主键，如果没有主键，找一个非空且惟一的字段，如果没有那就会建一个隐藏字段。 多字段联合主键：不常用 1mysql&gt; create table t7(ip char(15),port int,primary key(ip,port)); 当一个表中，由于业务需求没有一个非空且惟一的字段时，我们可以建一个新的字段专门作为主键，管理主键的值挺麻烦，需要记录上一次的主键值，MySQL 使用 auto_increment 自动增长，auto_increment 只能用于整型字段，并且该字段必须具备索引。所以主键都会加上auto_increment。 手动修改自动增长计数 1alter teble 表名 auto_increment 新值； 注意：如果新的值小于当前最大值是无效的。 insert 语句 1mysql&gt; insert into 表名 values(值1,值n,...) 要求值得顺序个数必须与表字段完全对应 另一种写法： 1mysql&gt; insert into 表名(字段名,字段名n,...) values(值1,值n,...) 可以选择性插入某些字段，要求值得顺序必须与表名后面声明的字段一致。 SQL_MODE查看数据库的模式1mysql&gt; show variables like &apos;%mode%&apos;; 在最后一行的 sql_mode 有个值为NO_ENGINE_SUBSTITUTION意思为非严格模式，作用是在如果你存储的数据类型超过限制条件了也不会报错反而会存储限制条件的边界大小，比如 tinyint，如果是非严格模式，你存储一个大于255的数据，不会保错会存储为255。 1mysql&gt; create table t0(id tinyint); 修改为严格模式1mysql&gt; set global sql_mode=&apos;strict_trans_tables&apos;; 设置完成后，需要重新连接才会生效。 修改为严格模式后如果插入的值超过数据类型的界限后就会报错。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库（一）]]></title>
    <url>%2F2018%2F11%2F19%2F%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[前言OK, 经过网络编程和并发编程的学习,现在到了学习数据库愉快之旅了👽.感觉到一丝丝的兴奋,学习新知识的开始总是能够给人动力,何况还是学习数据库,一看就显得高大上,而且几乎都是命令行操作,黑客既视感有没有… 数据库介绍什么是数据库简单来说,数据库( DataBase)就是用来存放数据的仓库,就像 github 仓库一样是用来存放数据的,这个仓库是按照一定的数据结构(数据结构是指数据的组织形式或数据之间的联系)来组织和存储数据的,可以通过各种 SQL 语句来存取数据库里的数据.随着计算机技术的发展和信息的爆炸,数据库不仅仅是存储和管理数据了,而转变成用户所需要的各种数据管理方式.数据库有很多种类和功能,从最简单的存储有各种数据的表格到能够进行海量数据存储的大型数据库系统都在各方面得到了广泛的应用. 数据库之前在数据库之前是怎么存储数据的呢? 文本模型早先的数据都是保存在文本文件中的,所以这就促使了文本文件的编辑器非常流行,文本检索的速度慢效率低,当数据库文件变得庞大时,快速的检索数据就变成了一个难题.所以出现了 DB,DB 是以给每一行做一个特定的标志的方式来工作的,这个标记叫 key, 查找一个之需要先找到 key, 这样就能快速的检索大需要的值( value).DB 是伯克利大学开发的,它早期也叫 sleepcat. 但是随着数据的增加,以及用户对检索速度的需求,这就让很多数据直接工作在了内存中,当数据文件越来越大的时候,内存的容量就成了我们的瓶颈,而有些操作是完全需要载入内存中,然后由内存工作查询之后,才将结果反馈,在这种越来越复杂的机制下,使用纯文本来保存数据已经不能满足需求了,接着出现了层次模型. 层次模型层次模型将文本分成了像根–&gt;下级目录—&gt;下下级目录这样的形式.(层次模型中非常著名的是 Sybase)信息管理系统中最重要的就是数据,而如果把信息管理系统比作身体的话,数据就相当于血液,而我们的心脏,其实就是数据库.像之前的纯文本记录数据,能够实现数据记录的就是文本文件,而实现数据管理的就是检索命令.层次模型的出现,在很大程度上缓解了数据检索速度的难题,但它毕竟是按照倒置树的结构来执行的,这样的模型想要在多个节点之间建立某种联系非常困难.所以后来出现了网状模型. 网状模型这种模型是以彼此间如何建立关联来决定的.它在层次模型的基础上对于不同的节点建立了更多的连接,使得不同节点之间的连接变得轻松简单.但是这两种模型都有一种极大的缺陷,它们需要跟软件的耦合成都非常的高,如果我们想修改一下数据模型中的关系和结构的话,则势必要完全修改对应的数据模型下的数据管理软件.之后出现了关系模型. 关系模型关系模型其实就是一堆二维表,由行和列组成,在同一个数据库之间可以存在多张表,表与表之间还有相关的属性相关联.这样,表内之间有关系,表与表之间也有关系,这就是关系模型.而现在的关系模型经过进一步发展,有了对象—关系模型, MySQL 就是一个对象—关系模型.能够提供关系模型的就叫关系型数据库模拟系统. 数据库的作用一个良好的数据库管理系统,都有以下功能: 管理数据存储; 安全管理,为数据库提供避免非法访问的机制,非常重要; 管理元数据,描述数据库属性的,本身跟数据无关; 事务管理,为了保证数据一致性的一个重要机制,现在大多数数据管理系统都提供事务的功能; 支持连接,主要指网络支持能力; 性能优化,在性能方面提供一定的优化机制,这是现在最流行的关系型数据管理系统的最重要的标准之一.在 RDBMS 中检索效率最高的,是 Oracle和 MySQL; 提供备份和恢复机制,对于数据库管理系统,这也是必需的功能,像 MySQL 为了数据安全,每份数据都保存两份,虽然数据冗余,但是保证了数据的安全; 提供数据检索和修改的处理机制,快速查询数据和修改数据. 数据库相关概念数据库里存储很多数据库,一个数据库可以看做是一个文件夹,数据库里面的表可以看做由文件夹管理的文件.在表中有许多的字段.(可以看做是描述一个数据的特征) 字段 记录 表 库 DBMS 数据库服务器 数据库本质上是一套 C/S 架构的 socket 软件. 数据库分类及优缺点在当前的互联网中,最常用的数据库模型主要是两种,即关系型数据库和非关系型数据库. 关系型数据虽然网状数据库和层次数据库已经很好的解决了数据的几种和共享问题,但是在数据独立性和抽象性上仍有很大不足,而关系型数据库就可以较好的解决这些问题.关系型数据库模型是把复杂的数据结构归结为简单的二元关系(即二维表格形式).在关系数据库中,对数据的操作几乎全部建立在一个或多个关系表格上,通过对这些关联表的表格分类,合并,连接或选取等运算来实现数据的管理.关系型数据库诞生距今已有40多年,从理论产生到发展为产品,例如, MySQL 和 Oracle 数据库.Oracle 在数据库领域上升到霸主地位,形成每年高达数百亿美元的庞大市场,而 MySQL 也是一路坎坷,以至于被 Oracle 收购(先被 SUN 收购,然后 SUN 被 Oracle 收购) 总结:什么是关系型数据库 二维的表格; 通过 SQL 结构化查询语言来存取和管理数据; 保持数据一致性方面很强 非关系数据库非关系型数据库也称为 NoSQL,NoSQL 的本意是’ Not Only SQL’,指的是非关系型数据库,而不是’No SQL’的意思.因此, NoSQL 的产生并不是要彻底否定关系型数据库,而是作为传统关系型数据库的一个有效补充. NoSQL 数据库在特定的场景下可以发挥出难以想象的高效率和高性能.随着互联网 web2.0网站(以前基本是静态网页)的兴起,传统的关系型数据库在应付web2.0网站,特别是对于规模日益扩大的海量数据,超大规模和高并发的微博,微信, SNS 类型的 web2.0纯动态网站已经显得力不从心,暴露了很多难以克服的问题,例如:传统的关系型数据库 I/O 瓶颈,性能瓶颈都难以有效突破,于是开始出现了大批针对场景,以高性能和使用便利为目的的功能特异化得数据库产品, NoSQL( 非关系型)类的数据库就是在这样的场景中诞生并得到了非常迅速的发展. NoSQL 不将数据的一致性作为重点,或者是作为次重点.NoSQL是非关系型数据库的广泛定义.它打破了长久以来关系型数据库与 ACID 理论大统一的局面. NoSQL 数据存储不需要固定的表结构,通常也不存在连接操作.在大数据存储上具备关系型数据库无法比拟的性能优势.当今的应用体系结构需要数据存储在和兴伸缩性上能够满足需求.而 NoSQL 存储就是为了实现这个需求而诞生的. 总结:什么是非关系型数据库 NoSQL 不是否定关系型数据库,而是作为关系数据库的一个重要补充; NoSQL 为了高性能,高并发而生,忽略影响高性能,高并发的功能. 具体分类关系型数据库 Oracle: 目前最好的关系型数据库,优势在于用户管理与分布式,但是商业版收费; MySQL: 免费开源,功能没有 Oracle 强大,但足以满足中小企业使用; SQLserver: 属于微软生态,需要和 windows 配合使用; DB2:IBM 开发的大型关系型数据库,收费,通常和硬件捆绑销售. 非关系型数据库 MongoDB:面向文档 redis:持久化缓存 memercach:纯内存 MySQL 数据库Mysql 的安装MAC 版安装 下载MySQL 社区版 安装 MySQL 双击 mysql-5.7.24-macos10.14-x86_64.dmg 文件，加载镜像,一直点击继续,因为我已经安装了,就不演示了.注意安装成功后悔弹出一个对话框,告诉我们生成了一个 root 账户的临时密码.需要保存(实在不记得也没事,有办法修改) 启动 MySQL 打开系统偏好设置,会发现在最下方多了一个 MySQL 图标,点击进入设置界面 安装完成,默认 MySQL 的状态是 stopped, 需要点击 Start MySQL Server 来启动,启动之后,状态变为 running. 下方有一个设置是否开机自启动. 终端连接 MySQL 首先把 MySQL 路径添加到环境变量中; 命令行登陆 1mysql -u root -p 登陆成功后需要重设登录密码,否则使用不了. 1mysql&gt; show databases;ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.mysql&gt; 登陆成功 假如安装设置的默认密码忘记了怎么办呢?在使用客户端连接服务端的时候需要经过认证,那么因为服务端也在自己的电脑上,所以只要绕过认证就可以了. 绕过服务端认证 进入 mysql 下 bin 目录 1cd /usr/local/mysql/bin/ 获取超级权限 1sudo su 输入密码后输入 1./mysqld_safe --skip-grant-tables &amp; 打开另一个终端输入 1./mysql 进入 mysql 输入 1flush privileges; 出现 Query OK, 输入,修改完成 1set password for root@localhost = password(&apos;password&apos;); Windows 安装Windows 安装分为两种,一种是有界面安装;一种是无界面安装。 有界面安装安装和 MAC 差不多,选好自己需要的功能就可以了,默认是安装在c:\program files\mysql 下.关键记住自己设置的密码。 无界面安装 注意:5.7以后的版本安装成功后需要先初始化; 1mysqld --initialize-insecure 添加环境变量 打开环境变量,将 MySQL 安装目录线的 bin 目录加入 path 变量; 将 mysqld 加入到 windows 系统服务 1mysqld --install 修改密码 修改默认密码需要先登陆成功,然后执行 update 语句直接修改 user 表中的密码; 5.7及以后的版本 1update mysql.user set authentication_string = password(&apos;root&apos;) where user = &apos;root&apos;; 5.6及之前的版本 1update mysql.user set password = password(&apos;root&apos;) where user = &apos;root&apos;; 不需要登录但需要知道旧密码 1mysqladmin -u root -p 旧密码 password 新密码 忘记登录密码 其实思路和 mac 一样,都是需要绕过验证,然后登陆mysql 接着修改密码 启动服务器时,控制它不要加载授权表; 无密码登录服务器 执行sql 语句 1update mysql.user set authentication_string = password(&apos;root&apos;) where user = &apos;root&apos;; 重启服务器. 用到的系统指令 mysqld 直接运行服务器程序; mysqld –skip-grant-tables 跳过授权表,用于重设密码; tasklist | findstr mysqld 找到 mysqld 服务进程; taskkill /f /pid 结束服务器程序; mysql -u 用户名 -p 密码 -h 主机 -P 端口号; mysqld –install 将 mysqld 注册到 windows 服务中,在服务中叫 MySQL( 本质就是绑定了一个 exe 程序); sc delete mysql 删除 windows 服务(重新 install 的话会显示服务已存在,需要重启); exit 退出客户端 5.6和5.7的区别 5.7版本安装后需要初始化； 5.6游客模式 没有密码就可以登录但是无法操作数据，只能看到information_schema 和 mysql； 5.7中 data数据存放目录是由初始化时决定的 带界面的在 C:\ProgramData; 不带界面的在安装目录中和 bin 同级; 5.6中 data 就在安装目录中 密码存储字段名，在5.6中为 password，5.7中为anthentication_string SQL 语句什么是 SQLsql:结构化查询语言,是上个世纪70年代由 IBM 公司发明的一种专门检索,查询数据的编程语言,这种编程语言类似于脚本语言.它是一大堆的命令语句.只不过它执行的接口是 SQL 接口,它也提供了 SQL 的语句的解释器,比如 select,update 等命令,只不过这样的命令要比 bask 复杂一点.要向执行 SQL 的语句,需要有 SQL 模型才可以.首先需要把用户写的语句输送到服务器端,这就要服务器能够接受客户端的命令,并将命令所返回的结果,送回客户端.这就是 SQL 的执行环境,而这些语句,则是实现检索修改等相关的数据管理工作的.所以 SQL 就是一种管理语言,用于管理关系型系统的,实现管理,修改数据等工作的,一种特殊语言解析器.最开始是 IBM 提供的 SQL 数据接口( SEQUEL),但是 Oracle 也有自己的 SQL 数据接口,这就造成了规则不匹配.所以美国国家标准委员会,就定义了一个新标准: ANSI SQL 标准,它的发展历程: 上个世纪80年代,1986年研发出来,叫做 SQL-86标准; 89年扩展为 SQL-89; 1992年再次扩展, SQL-92:这一代被应用了很长的时间:各生产商 RDBMS 公司,要想实现上市,则必须严格的按照92的标准.但是这个标准定义的太严格,以至于几乎没有厂商可以达到这种标准,所以兼容的标准也分成了三中级别: Entry 级别, Intermediate 级别, Full 级别,几乎没有厂商可以达到 Full 级别,大部分都是 Entry 级别; 1999年再次扩展, SQL-99:MySQL 是完全兼容 SQL-99的 Entry 级别.而在此又出现了 Core SQL 级别; 2003年,又出现了 SQL-2003标准. XML 标准. SQL 的版本就和 bash 一样,每一个更新版本都有新功能,而且执行速度,使用便捷,提供的扩展也不一样. 简单的 sql 语句针对库的相关操作 增 create database 库名; 删 drop database 库名; 查 show databases;（查看所有数据库） show create database 库名;（查看建库语句） 改 alter database 库名 要修改的字段名; alter database 库名 DEAFULT CHARACTER SET utf8; （修改默认编码） alter database 库名 CHARSET utf8; 注意在mysql 中 只能写 utf8 针对表的相关操作 增：建表是首先要明确数据库 use 库名; create table 表名(字段名 类型(长度),….); create table 库名(name char(10),gender char(1), age int); create table 库名.表名(字段名 类型(长度),…); # 创建同时指定数据库 删 drop table 表名; 查 show tables; 查看所有表 desc 表名; 查看表结构 show create table 表名; 查建表语句 改 alter table 表名 drop|change|modify|add alter table 表名 drop 字段; alter table 表名 change 旧字段名 新字段名 新类型; alter table 表名 modify 字段名 新类型; alter table 表名 add 字段名 类型; 重命名表 rename table 旧表名 to 新表名; 修改表的属性 alter table 表名 属性名 值; 针对记录的相关操作 增 insert into 表名 values(值1,值2…); 删 delete from 表名 where 字段名=值; # 没有符合条件的话删除全部数据 查 select from 表名; # 表示通配符 查看所有字段 改 update 表名 set 字段名 = 新值 where 字段名 = 值; # 没有符合条件的话修改全部数据 命名规范 不能使用纯数字； 可以是数字、字母、下划线的组合； 可以用下划线开头； 不能使 sql 关键词，如 create； 不区分大小写。 修改默认配置配置文件放在安装路径根目录中就是和 bin 同级，名称必须叫my.ini（mac 的不一样） 12345678# 客户端的配置[mysql]user = rootpassword = passworddefault-character-set = utf8# 服务端的配置[mysqld]character-set-server = utf8]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[并发编程（六）]]></title>
    <url>%2F2018%2F11%2F18%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[前言前面两篇介绍了进程理论,创建进程的两种方式,互斥锁以及进程间通信的三种方式还有生产着消费者模型.除了进程间通信线程里面没有(因为线程间数据共享)其他的几乎没什么两样,而且在多进程模块里面的Process 类介绍也说了 The class is analagous to &#39;threading.Thread&#39; 大意就是说进程类和线程类类似,所以很多用法都一样. 线程线程理论为了充分利用 CPU 多核的性能,程序实现了多线程模型,通过多线程实现多任务的并行执行.]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[并发编程（五）]]></title>
    <url>%2F2018%2F11%2F17%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[前言上篇博客的内容是守护进程,对于操作系统来说可以在后台执行一些程序.这篇的内容是互斥锁,在上上篇博客上说到进程内存空间互相隔离,所以可以通过共享文件来操作同一个文件,那么这样操作的话会发生什么呢? 锁互斥锁多个进程需要共享数据时,先将其锁定,此时资源状态为’锁定’,其他进程不能更改;知道该进程释放资源,将资源的状态变成非’锁定’,其他的线程才能再次锁定该资源.互斥锁保证了每次只有一个进程进入写入操作,从而保证了多进程情况下数据的正确性. 我们使用一个demo 来模拟多个进程操作同一个文件: 12345678910111213141516171819202122232425262728293031import jsonimport time,randomfrom multiprocessing import Processdef show_tickets(name): time.sleep(random.randint(1,3)) with open('ticket.json', 'rt', encoding='utf-8') as f: data = json.load(f) print('%s 查看 剩余票数: %s' % (name, data['count']))def buy_ticket(name): with open('ticket.json', 'rt', encoding='utf-8') as f: dic = json.load(f) if dic['count'] &gt; 0: dic['count'] -= 1 time.sleep(random.randint(1,3)) with open('ticket.json', 'wt', encoding='utf-8') as f: json.dump(dic, f) print('%s: 购票成功' % name)def task(name): show_tickets(name) buy_ticket(name)if __name__ == '__main__': for i in range(1,11): p = Process(target=task, args=(i,)) p.start() 运行结果: 在 ticket.json 里面只有一张票,结果却造成多个用户购买成功,这很显然是不符合实际情况的.\ 那么怎么解决呢?如果多个进程对同一个文件进行读操作可以不进行限制,但是对同一个文件进行写操作就必要要进行限制,不可以同时多个人对同一个文件进行写操作.python 在多进程模块里提供一个类, Lock 类,当进程获取到锁的时候其他的进程就必须要等待锁释放才可以进行争抢,在这个例子里面就可以加上一把锁来保护数据安全. 1234567891011121314151617181920212223242526272829303132333435from multiprocessing import Process, Lockimport json,time,randomdef show_tickets(name): time.sleep(random.randint(1,3)) with open('ticket.json', 'rt', encoding='utf-8') as f: data = json.load(f) print('%s 查看 剩余票数: %s' % (name, data['count']))def buy_ticket(name): time.sleep(random.randint(1,3)) with open('ticket.json', 'rt', encoding='utf-8') as f: dic = json.load(f) if dic['count'] &gt; 0: dic['count'] -= 1 time.sleep(random.randint(1,3)) with open('ticket.json', 'wt', encoding='utf-8') as f: json.dump(dic, f) print('%s: 购票成功' % name)def task(name,lock): show_tickets(name) lock.acquire() buy_ticket(name) lock.release()if __name__ == '__main__': mutex = Lock() for i in range(1,11): p = Process(target=task, args=(i,mutex)) p.start() 运行结果: 这样加了锁(互斥锁)就可以解决同时操作同一个文件造成的数据混乱问题了. 当使用多进程开发时,如果多个进程同时读写同一个资源,可能会造成数据的混乱,为了防止发生问题,使用锁,或者使用 Process 的方法 join 将并行变为串行. join 和锁的区别 join 人为控制进程的执行顺序 join 把整个进程全部串行,而锁可以指定部分代码串行 一旦串行,效率就会降低,一旦并行,数据就可能会出错. 进程间通信进程间通信( internal-process communication),我们在开启子进程是希望子进程帮助完成任务,很多情况下需要将数据返回给父进程,然而进程间内存是物理隔离的. 解决办法: 将共享数据放到文件中 管道 多进程模块中的一个类,需要有父子关系 共享一快内存区域 需要操作系统分配 管道通信Pipe类返回一个由管道连接的连接对象,默认情况下为双工: 123456789101112from multiprocessing import Process,Pipedef f(conn): conn.send([42, None, 'hello']) conn.close() if __name__ == '__main__': parent_conn, child_conn = Pipe() p = Process(target=f, args=(child_conn,)) p.start() print(parent_conn.recv()) p.join() 运行结果: 1[42, None, 'hello'] 实例化 Pipe 类会返回两个连接对象表示管道的两端.每个连接对象都有 send() 和 recv() 方法(及其他).请注意,如果两个进程同时尝试读写管道的同一端,则管道中的数据可能会损坏.当然,同时使用管道的不同端部的过程不存在损坏的风险. 共享内存通信Queue 通信Queue类会生成一个先进先出的容器,通过往队列中存取数据而进行进程间通信. 1234567891011from multiprocessing import Process, Queuedef f(q): q.put([42, None, 'hello']) if __name__ == '__main__': q = Queue() p = Process(target=f, args=(q,)) p.start() print(q.get()) p.join() 运行结果: 1[42, None, 'hello'] 队列其他特性 123456789101112131415161718192021222324252627282930313233# 阻塞操作 必须掌握q = Queue(3)# # 存入数据q.put("hello",block=False)q.put(["1","2","3"],block=False)q.put(1,block=False)# 当容量满的时候 再执行put 默认会阻塞直到执行力了get为止# 如果修改block=False 直接报错 因为没地方放了# q.put(&#123;&#125;,block=False)# # # 取出数据print(q.get(block=False))print(q.get(block=False))print(q.get(block=False))# 对于get 当队列中中没有数据时默认是阻塞的 直达执行了put# 如果修改block=False 直接报错 因为没数据可取了print(q.get(block=False))# 了解q = Queue(3)q.put("q",timeout=3)q.put("q2",timeout=3)q.put("q3",timeout=3)# 如果满了 愿意等3秒 如果3秒后还存不进去 就炸# q.put("q4",timeout=3)print(q.get(timeout=3))print(q.get(timeout=3))print(q.get(timeout=3))# 如果没了 愿意等3秒 如果3秒后还取不到数据 就炸print(q.get(timeout=3)) ####Manager 通信 demo 1234567891011121314151617from multiprocessing import Process,Managerimport timedef task(dic): print("子进程xxxxx") # li[0] = 1 # print(li[0]) dic["name"] = "xx"if __name__ == '__main__': m = Manager() # li = m.list([100]) dic = m.dict(&#123;&#125;) # 开启子进程 p = Process(target=task,args=(dic,)) p.start() time.sleep(3) 可以创建一片共享内存区域用来存取数据. 生产者消费者模型什么是生产者消费者模型在软件开发过程中,经常碰到这样的场景: 某些模块负责生产数据,这些数据由其他模块来负责处理(此处的模块可能是:函数,线程,进程等).生产数据的模块称为生产者,而处理数据的模块称为消费者.在生产者与消费者之间的缓冲区称之为仓库.生产者负责往仓库运输商品,而消费者负责从仓库里取出商品,这就构成了生产者消费者模型. 结构图如下: 为了便于理解,我们举一个寄信的例子。假设你要寄一封信，大致过程如下： 你把信写好——相当于生产者生产数据; 你把信放入邮箱——相当于生产者把数据放入缓冲区; 邮递员把信从邮箱取出，做相应处理——相当于消费者把数据取出缓冲区,处理数据. 生产者消费者模型的优点 解耦 假设生产者和消费者分别是两个线程.如果让生产者直接调用消费者的某个方法,那么生产者对于消费者就会产生依赖(耦合).如果未来消费者的代码发生改变,可能会影响到生产者的代码.而如果两者都依赖于某个缓冲区,两者之间不直接依赖,耦合也就相应降低了. 举个例子,我们去邮局投递信件,如果不使用邮箱（也就是缓冲区,你必须得把信直接交给邮递员.有同学会说,直接给邮递员不是挺简单的嘛?其实不简单,你必须 得认识谁是邮递员,才能把信给他.这就产生了你和邮递员之间的依赖(相当于生产者和消费者的强耦合).万一哪天邮递员换人了,你还要重新认识一下(相当于消费者变化导致修改生产者代码).而邮箱相对来说比较固定,你依赖它的成本就比较低(相当于和缓冲区之间的弱耦合). 并发 由于生产者与消费者是两个独立的并发体,它们之间是使用缓冲区通信的,生产者只需要往缓冲区里丢数据,就可以接着生产下一个数据了,而消费者只需要从缓冲区拿数据即可,这样就不会因为彼此的处理速度而发生阻塞. 继续上面的例子,如果没有邮箱,就得在邮局等邮递员,知道他回来,把信交给他,这期间我们什么事都干不了(生产者阻塞).或者邮递员挨家挨户问,谁要寄信(消费者阻塞). 支持忙闲不均 当生产者制造数据快的时候,消费者来不及处理,为处理的数据可以暂时存在缓冲区中,慢慢处理,而不至于因为消费者的性能过慢造成数据丢失或影响生产者生产数据. 再拿寄信的例子,假设邮递员一次只能带走1000封信,万一碰上情人节或者其他的紧急任务,需要寄出的信超过了1000封,这个时候邮箱作为缓冲区就派上用场了.邮递员把来不及带走的信暂存在邮箱中,等下次过来时在拿走. ###使用 1234567891011121314151617181920212223242526from multiprocessing import Process, Queueimport time, randomdef producer(name, food, q): for i in range(10): res = '%s %s' % (food, i) time.sleep(random.randint(1,3)) q.put(res) print('%s 生产了 %s' % (name, res)) def consumer(name, q): while True: res = q.get() time.sleep(random.randint(1,3)) print('%s 消费了 %s' % (name, res))if __name__ == '__main__': q = Queue() p = Process(target=producer, args=('musibii', '🍔', q)) c = Process(target=consumer, args=('thales', q)) p.start() c.start() p.join() c.join() print('主进程') 运行结果: 这样的话该进程并不会结束,因为 get 方法是阻塞的,数据消费完就会一直等待知道生产者生产新的数据,而生产者只能生产9个数据.所以会一直阻塞. 改进使用我们需要在消费者消费的时候知道队列里面有多少数据,应该什么时候消费完了,所以可以在生产者里面生产结束后添加一个标志,比如 None. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import time, randomfrom multiprocessing import Process, Queue# 制作热狗def make_hotdog(queue, name): for i in range(1, 4): time.sleep(random.randint(1, 2)) print("%s 制作了一个🌭 %s" % (name, i)) # 生产得到的数据 data = "%s 生产的🌭%s" % (name, i) # 存到队列中 queue.put(data) # 装入一个特别的数据 告诉消费方 没有了 # queue.put(None)# 吃热狗def eat_hotdog(queue, name): while True: data = queue.get() if not data: break time.sleep(random.randint(1, 2)) print("%s 吃了 %s" % (name, data))if __name__ == '__main__': # 创建队列 q = Queue() p1 = Process(target=make_hotdog, args=(q, "musibii的热狗店")) p2 = Process(target=make_hotdog, args=(q, "egon的热狗店")) p3 = Process(target=make_hotdog, args=(q, "eureka的热狗店")) c1 = Process(target=eat_hotdog, args=(q, "thales")) c2 = Process(target=eat_hotdog, args=(q, "maffia")) p1.start() p2.start() p3.start() c1.start() c2.start() # 让主进程等三家店全都做完后.... p1.join() p2.join() p3.join() # 添加结束标志 注意这种方法有几个消费者就加几个None 不太合适 不清楚将来有多少消费者 q.put(None) q.put(None) # 现在 需要知道什么时候做完热狗了 生产者不知道 消费者也不知道 # 只有队列知道 print("主进程over") # 生产方不生产了 然而消费方不知道 所以已知等待 get函数阻塞 # 三家店都放了一个空表示没热狗了 但是消费者只有两个 他们只要看见None 就认为没有了 # 于是进程也就结束了 造成一些数据没有被处理 # 等待做有店都做完热狗在放None 运行结果: 这样就解决了最初版本消费之因为没有数据而阻塞的问题了,但是这里还是有问题,因为不知道到底有多少消费者,因为想让消费者知道数据已经结束了的话,需要给每个消费者一个标志位,这样是不现实的. 完美使用python 多进程模块提供了一个JoinableQueue类,追根溯源继承于 Queue,源码看的头疼. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import time, randomfrom multiprocessing import Process, JoinableQueue# 制作热狗def make_hotdog(queue, name): for i in range(1,4): time.sleep(random.randint(1, 2)) print("%s 制作的🌭 %s" % (name, i)) # 生产得到的数据 data = "%s 生产的🌭 %s" % (name, i) # 存到队列中 queue.put(data) # 装入一个特别的数据 告诉消费方 没有了 # queue.put(None)# 吃热狗def eat_hotdog(queue, name): while True: data = queue.get() time.sleep(random.randint(1, 2)) print("%s 吃了%s" % (name, data)) # 该函数就是用来记录一共给消费方多少数据了 就是get次数 queue.task_done()if __name__ == '__main__': # 创建队列 q = JoinableQueue() p1 = Process(target=make_hotdog, args=(q, "musibii的热狗店")) p2 = Process(target=make_hotdog, args=(q, "egon的热狗店")) p3 = Process(target=make_hotdog, args=(q, "eureka的热狗店")) c1 = Process(target=eat_hotdog, args=(q, "thales")) c2 = Process(target=eat_hotdog, args=(q, "maffia")) p1.start() p2.start() p3.start() # 将消费者作为主进程的守护进程 c1.daemon = True c2.daemon = True c1.start() c2.start() # 让主进程等三家店全都做完后.... p1.join() p2.join() p3.join() # 如何知道生产方生产完了 并且 消费方也吃完了 # 方法一:等待做有店都做完热狗在放None # # 添加结束标志 注意这种方法有几个消费者就加几个None 不太合适 不清楚将来有多少消费者 # q.put(None) # q.put(None) # 主进程等到队列结束时再继续 那队列什么时候算结束? 生产者已经生产完了 并且消费者把数据全取完了 q.join() # 已经明确生产放一共有多少数据 # 现在 需要知道什么时候做完热狗了 生产者不知道 消费者也不知道 # 只有队列知道 print("主进程over") # 生产方不生产了 然而消费方不知道 所以一直等待 get函数阻塞 # 三家店都放了一个空表示没热狗了 但是消费者只有两个 他们只要看见None 就认为没有了 # 于是进程也就结束了 造成一些数据没有被处理 运行结果: 查看 JoinableQueue 类方法 task_done 源码: 看不懂………]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[并发编程（四）]]></title>
    <url>%2F2018%2F11%2F17%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[前言上篇博客介绍了进程的创建,进程的相关属性以及三种特殊进程:僵尸进程,孤儿进程和守护进程. 守护进程是一个在后台运行并且不受任何终端控制的进程,用于执行特定的系统任务.很多守护进程在系统引导的时候启动,并且一直运行直到系统关闭.另一些只在需要的时候才启动,完成任务后就自动结束. 本篇博客详细介绍守护进程的产生原因以及作用.(因为我觉得守护进程对操作系统的正常运行还蛮重要的) 守护进程介绍以下介绍摘自百度百科 守护进程是一个在后台运行并且不受任何终端控制的进程. Unix 操作系统有很多典型的守护进程,他们在后台运行,执行不同的管理任务. 用户使守护进程独立于所有终端是因为,在守护进程从一个终端启动的情况下,这同一个终端可能被其他的用户使用.例如,用户从一个终端启动守护进程后退出,然后另一个人也登陆到这个终端.用户不希望后者在使用该终端的过程中,接收到守护进程的任何错误信息.同样,由终端键入的任何信号(例如中断信号)也不应该影响先前在该终端启动的任何守护进程的运行.虽然让服务器后台运行很容易(只要shell 命令行以&amp;结尾),但用户还应该做些工作,让程序本身能够自动进入后台,且不依赖于任何终端. 守护进程没有控制终端,因此当某些情况发生时,不管是一般的报告性信息,还是由管理员处理的紧急信息,都需要以某种方式输出. Syslog 函数就是输出这些信息的标准方法,它把信息发送给 syslogd 守护进程. 创建守护进程步骤在不同 Unix环境下,守护进程的具体变成细节并不一致.但所幸的是,守护进程的编程原则都一样,区别仅在于具体的实现细节不同,这个原则就是要满足守护进程的特性.编程规则如下: 在后台运行为避免挂起控制终端,要将守护进程放入后台运行,其方法是在父进程中调用 fork 使父进程终止,让子进程在后台执行,使得程序在 shell 终端里造成一个已经运行完毕的假象.之后所有的工作都在子进程中完成,而用户在 shell 终端里则可以执行其他命令,从而使得程序以僵尸进程运行,在形式上做到了与控制终端的隔离.具体就是 fork 产生子进程后,调用 exit 使父进程终止. 脱离控制终端,登陆会话和进程组登陆回话可以包含多个进程组,这些进程组共享一个控制终端,这个控制终端通常是创建进程的登陆终端,控制终端,登陆回话和进程组通常都是从父进程继承下来的.目的就是要脱离这些继承的东西,不受它们的影响. 这就要使用 setsid 函数使进程成为会话组长. setsid setsid 命令 子进程从父进程继承了: Session ID, 进程组 ID 合打开的终端.子进程如果要脱离这些,代码中可通过调用 setsid 来实现.而命令行或脚本中可以通过命令setsid 来实现. setsid 帮助一个进程脱离从父进程继承而来的已打开的终端,会话和进程组. 需要说明的是,当进程是会话组长时, setsid 调用会失败,大第一点已经保证进程不是会话组长.setsid 调用成功后,进程会成为新的会话组长和新的进程组长,并与原来的登陆会话和进程组脱离,由于会话过程对控制终端的独占性,进程同时与控制终端脱离. 具体操作就是: 成为新会话的首进程; 成为一个新进程组的首进程; 没有控制终端. 禁止进程重新打开控制终端现在进程已经成为无终端的会话组长,但它可以重新申请打开一个控制终端.可以通过是进程不再成为会话组长来禁止进程重新打开控制终端. 关闭打开的文件描述符进程从创建它的父进程那里继承了打开的文件描述符.如果不关闭,会造成资源浪给,造成进程所在地文件系统无法卸下以及产生无法预料的错误.一般来说,必要的是关闭0,1,2三个文件描述符,即标准输入,标准输出,标准错误.因为一般希望守护进程自己有一套信息输出,输入的体系,而不是把所有的东西都发送到终端屏幕上.所以需要调用 fclose 来关闭文件描述符. 改变当前工作目录将当前工作目录更改为根目录,从父进程继承过来的当前工作目录可能在一个装配的文件系统中.因为守护进程通常在系统引导之前是一直存在的,所以如果守护进程的当前工作目录在一个装配文件系统中,那么该文件系统就不能被拆卸. 另外,某些守护进程可能会把当前工作目录更改到某个指定位置,在此位置做它们的工作.例如,行式打印机守护进程常常将工作目录更改到 spool 目录上.可以调用 chdir 更改工作目录. 重设文件创建掩码文件创建掩码是指屏蔽掉文件创建时的对应为.由于使用 fork 后函数新建的子进程继承了父进程的文件创建掩码,这就给该子进程使用文件带来了诸多麻烦.因此,把文件创建掩码设置为0,可以大大增强该守护进程的灵活性.设置文件创建掩码的函数是 umask, 通常的使用方法为umask(0). 处理 SIGCHLD 信号处理 SIGCHLD 信号并不是必需的.但是对于某些守护进程,特别是服务器进程往往在请求到来时生产子进程出来请求.如果父进程不等待子进程结束,子进程将成为僵尸进程而占用系统资源.如果父进程等待子进程结束,将增加父进程的负担,影响服务器进程的并发性能.在系统下可以简单的将 SIGCHLD 信号的操作设为 SIG-IGN: signal(SIGCHLD,SIG_IGN) 这样,内核在子进程结束后不会产生僵尸进程,这一点与 BSD4不同,杂 iBSD4下必须显式等待子进程结束后才能释放僵尸进程. #python守护进程 12345678910111213141516171819202122232425262728293031323334353637import timeimport osimport sysdef initDaemon(stdoutfd, stderrfd=None, basePath=None): ''' 初始化为 daemon 进程 ''' basePath = '/' if basePath is None else basePath curTimeStr = time.strftime('%Y-%m-%d %H:%M:%S') try: stdoutfd.write('Start on %s, ' % curTimeStr) stdoutfd.flush() except: raise try: if os.fork() &gt; 0: os._exit(0) except OSError: raise OSError('fork error') os.chdir(basePath) os.setsid() sys.stdout = stdoutfd sys.stderr = stdoutfd if stderrfd is None else stderrfd sys.stdin = open('/dev/nu,,', 'r') try: if os.fork() &gt; 0: os._exit(0) except OSError: raise OSError('fork 2 error') pid = int(os.getpid()) stdoutfd.write('pid=%s\n' % pid) stdoutfd.flush() return ##守护进程运行方式 独立运行的守护进程独立运行的守护进程有 init 脚本负责管理,所有独立运行的守护进程的脚本在/etc/rc和/etc/init.d 目录下.系统服务都是独立运行的守护进程包括 syslogd 和 cron 等.服务器监听一个特定的端口上等待客户端的连接.如果客户端产生一个连接请求,守护进程就创建一个子服务器响应这个连接,而主服务器继续监听.以保持多个子服务器池等待下一个客户端请求连接. 由 xinetd 管理的守护进程从守护进程的概念可以看出,系统所运行的每一种服务,都必须运行一个监听某个端口连接所发生的守护进程,这通常意味着资源浪费.为了解决这个问题, Linux 引进了’网络守护进程服务程序’的概念. CentOS6.4使用的网络守护进程是 xinted(eXtendedInterNET services daemon). 上图是 ubuntu18.04使用的网络守护进程服务程序, xinted 能够同时监听多个指定的端口,在接受用户请求时,它能够根据用户请求的端口不同,启动不同的网络服务进程来处理这些用户请求.可以把 xinted 看做一个管理启动服务的管理服务器,它决定把一个客户请求交给那个程序处理,然后启动相应的守护进程. ##守护进程分类 按照服务类型分为如下几个: 系统守护进程: syslogd,login,crond,at 等 网络守护进程: sendmail,httpd,xinetd 等 独立启动的守护进程: httpd,named,xinetd 等 被动守护进程(由 xinetd 启动):telnet,finger,ktalk 等 python守护进程使用12345678910111213from multiprocessing import Processimport timedef task(): time.sleep(3) print('子进程') if __name__ == '__main__': p = Process(target=task) # 将该进程设为父进程的守护进程 p.daemon = True p.start() print('主进程') 注意 设置守护进程必须在启动进程之前执行. 总结对于一个操作系统来说,为了执行不同的管理任务,需要守护进程来协助管理.对于守护进程最重要的来说是需要在后台运行.其次,守护进程必须与其运行前的环境隔离开来.这些环境包括未关闭的文件描述符,控制终端,会话和进程组,工作目录以及文件创建掩码等.这些环境通常是守护进程从执行它的父进程(特别是 shell)继承下来的.最后守护进程的启动方式有其特殊之处.它可以在 Linux 系统启动时从启动脚本/etc/rc. d中启动,也可以由作业控制进程 crond 启动,还可以由用户终端(通常是 shell)执行. 除这几点之外,守护进程与普通进程基本上没什么区别.因此,编写守护进程实际上是把一个普通进程按照上述的守护进程的特性改造成为守护进程.]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[并发编程（三）]]></title>
    <url>%2F2018%2F11%2F16%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[前言经过前一篇博客的学习了解了 Unix 和 Windows 系统创建进程的方式了,对于 Unix系统来说,会把父进程的数据直接拷贝一份到子进程的内存空间;而 Windows 系统会重新加载一遍父进程的代码. 那么在 python 中怎么创建进程呢?其实也是调用了操作系统提供的接口,像 Unix 是 fork 接口, Windows 是 CreateProcess 接口. python 进程Process 源码探析首先不管怎么创建进程都是调用了一个multiprocessing模块里面的 Process 类,学习一个模块第一件事就是查看源码.(ps: 对我来说看源码很爽😋)因为 python3看不到源码,所以用 python2可以看到: 翻译 Process 类的注释:进程对象表示在隔开的进程中运行的活动,这个类和 threading.Thread 同义.(因为最开始的计算机都是单核,多进程是后面才出来的) 那么很显然,因为 Process 是个类,那么想要创建一个进程就是实例化一个 Process 类的对象.查看 init方法: 哇,参数好多啊,不过大部分都可以使用默认值,第一个参数是 group, 看后面有一句注释: group 参数当前必须为 None, 好了可以不用理会了;第二个参数很重要,表示创建的进程将要进行的任务,必须要传参数(函数名);第三个是名字,可以自定义进程名;第四个是可变长参数,参数会在创建进程的时候传进 target 中;第五个为关键词参数,也是给 target 传的. 1assert group is None 断言,只有该表达式值为 True 才会运行下面的代码.很显然不用管就行. 然后下面的都是一些类属性,需要关注的是 self._target,sekf._popen. 查看 process 模块的注释: 翻译可知: 模块提供 Process 类是模拟于’ threading.Thread’ 再分配和使用的源代码和二进制形式，无论有无修改,但必须符合下列的情况: 1.源代码的再分发必须保留上述版权声明，此条件列表和以下免责声明。 2.二进制形式的再分发必须在随分发提供的文档和/或其他材料中复制上述版权声明，此条件列表和以下免责声明。 3.未经事先书面许可，不得使用作者姓名或任何贡献者的姓名来认可或宣传本软件衍生的产品。(ps: 这注释怎么和 process 一点关系没有😲) 开启进程的两种方式 实例化 Process 类 创建一个子进程的 demo 如下: 123456789from multiprocessing import Process,current_processdef task(): print('子', current_process) if __name__ == '__main__': p = Process(target=task) p.start() # 启动一个进程 print('主', current_process) 注意:创建进程的代码为什么要放在 mian 下面? 这是因为在 windows 系统下创建进程会重新加载一遍父进程的代码,如果不放在 main 判断下面的话会重复执行创建进程的代码.在 类linux 系统下就不用了.创建进程后执行start方法其实就是运行传入的 task 函数: 这个类方法的注释含义为:运行在子进程中的方法,可以在子类中重写. 看看创建的子进程的运行结果: 结果会打印出主进程和子进程. 新建一个继承自 Process 类的子类并改写 run 方法 demo 如下: 1234567891011from multiprocessing import Process,current_processclass MyProcess(Process): def run(self): print('子', current_process())if __name__ == '__main__': p = MyProcess() p.start() print('主', current_process()) 运行结果: 进程之间内存空间互相隔离123456789101112from multiprocessing import Processx = 100def task(): global x x = 1 print('子', x) if __name__ == '__main__': p = Process(target=task) p.start() print('主', x) 运行结果: 可以得出即使在子进程中global x了,修改的也是子进程内存空间里面的名称,这和之前讲的子进程将父进程的代码重新加载了一遍,所以这里面的 x 是两个不同的 x. 为什么进程的内存空间需要切必须要互相隔离呢? 进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术.这个技术是为了避免A 进程写入 B 进程的情况发生.进程的隔离实现,使用了虚拟地址空间.进程 A 的虚拟地址和进程 B 的虚拟地址不同,这样就防止进程 A 将数据信息写入进程 B,总的来说就是为了数据安全,但也有办法可以实现进程间通信,稍后再谈. 父子进程执行顺序与 join 方法在上面的代码中实例一个进程对象然后执行 start 方法,会创建出一个子进程然后去执行任务,其实 python 只是调用了操作系统提供的接口,在上一篇博客说到,类 Unix 是调用了操作系统的 fork 函数, windows 是 CreateProcess 函数,所以是通过操作系统来调用并创建一个进程的,而创建进程需要一些必要的资源,那么在操作系统分配这些资源的过程中,主进程代码的执行应该进行完成了,所以运行结果会先出现主进程代码执行完,后子进程的代码执行完. 创建进程的具体时间 123456789101112131415161718from multiprocessing import Processimport timedef task(): start_time = time.time() print('子进程运行时间') print(time.time() - start_time)if __name__ == '__main__': start_time = time.time() p = Process(target=task) p.start() print('创建子进程', time.time() - start_time) print('主', time.time() - start_time) 运行结果: 可以得出创建子进程几乎花了总程序运行时间的90%以上,所以主进程先运行结束就很正常了. join 方法 那么如何可以让主进程等待子进程运行结束主进程才结束呢? 12345678910111213141516171819from multiprocessing import Processimport timedef task(): start_time = time.time() print('子进程运行时间') print(time.time() - start_time)if __name__ == '__main__': start_time = time.time() p = Process(target=task) p.start() print('创建子进程', time.time() - start_time) p.join() print('主', time.time() - start_time) 运行结果: 这样主进程就会等待子进程运行结束才会结束. join 方法:主进程等待子进程运行完毕,即主进程在原地阻塞而不影响子进程的运行. 进程对象相关属性和方法12345678910111213141516171819from multiprocessing import Processimport os,timedef task(name): print('start', name) time.sleep(5) print('stop', name) if __name__ == '__main__': p = Process(target=task, args=('musibii',), name='musibii_Process') p.start() print(p.name) # 获取进程名,可以自定义 print(p.pid) # 获取进程 pid p.terminate() # 结束子进程 print(p.is_alive()) # 判断进程是否存活,布尔值 print(os.getpid()) # 当前主进程 pid print(os.getppid()) # 执行 py 文件的进程,当前为 pycharm 进程pid 运行结果: 为什么在 terminate 之后判断子进程是否存活,结果为 True 呢? 因为在执行终结子进程命令后需要操作系统来结束子进程,而完全终结子进程需要一定的时间,而代码执行速度很快,所以会是 True. 僵尸进程与孤儿进程以及守护进程僵尸进程在类 Unix 系统中,僵尸进程是指完成执行(通过 exit 系统调用,或运行时发生致命错误或收到终止信号所致)但在操作系统的进程表中仍然有一个表项(进程控制块 PCB),处于’终止状态’的进程. 孤儿进程在操作系统中,孤儿进程指的是在其父进程执行完成或被终止后仍继续运行的一类进程,这类进程由操作系统进行管理和回收. 守护进程在一个多工的电脑作业系统中,守护进程是一种在后台执行的电脑程序.此类程序会被以进程的形式初始化.守护进程程序的名称通常以’ d’结尾:例如 syslogd 就是指管理系统日志的守护进程. 详解: 一般情况下,子进程是由父进程创建的,而子进程和父进程的退出是无顺序的,两者之间都不知道谁先退出.正常情况下父进程先结束则会调用 wait 或者 waitpid 函数等待子进程完成再退出,而一旦父进程不等待直接退出,则剩下的子进程会被 init(pid=1)进程接收,成被孤儿进程.(进程树种除了 init 都会有父进程) 如果子进程先退出,父进程还未结束并且没有调用 wait 或者 waitpid 函数获取子进程的状态信息,则子进程残留的状态信息(task_struct 结构和少量系统资源信息)会变成僵尸进程. 守护进程是指在后台运行,没有控制终端与之相连的进程.它独立于控制终端,通常周期性的执行某种任务.(特别的,守护进程不能有子进程)守护进程脱离于终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的终端信息所打断. 产生的危害 孤儿进程结束后会被 init 进程管理并处理后事,并没有危害,而僵尸进程则会一直占着进程号,操作系统的进程数量有限则会受影响. 解决办法: 一般僵尸进程的产生都是因为父进程的原因,则可以通过kill 父进程解决,这时候僵尸进程就变成了孤儿进程,被 init 进程管理.]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[并发编程（二）]]></title>
    <url>%2F2018%2F11%2F16%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[前言在第三代计算机的发展中因为出现了多道技术使得同一时刻可以在内存中同时运行多个程序,那么这样就产生了进程的概念. 在本篇博客中将介绍进程相关的理论知识,对操作系统进一步的认识. 进程什么是进程进程( process),是指计算机中已运行的程序.进程曾经是分时系统的基本运行单位.在面向进程设计的系统(如早期的 UNIX,Linux2.4及更早的版本)中,进程是程序的基本执行实体,是操作系统的资源单位;在面向线程设计的系统(如当代多数操作系统, Linux2.6及更新的版本)中,进程本身不是基本运行单位,运行单位变为线程,进程是线程的容器.程序本身只是指令,数据及其组织形式的描述,进程才是(指令和数据)的真正运行实例.若干进程有可能与同一个程序相关系,且每个进程皆可以同步(循序)或异步(平行)的方式独立运行.现代计算机系统因为空间共享(空间复用)可在同一段时间内以进程的形式将多个程序加载到存储器中,并借由时间共享(时间复用),以在一个处理器上表现出异步(平行)运行的感觉. ###开启进程需要的资源 用户下达运行程序的命令后,就会产生进程.同一程序可产生多个进程(一对多的关系),以允许同时又多位用户运行同一程序,却不会产生冲突. 开启进程需要一些必要的资源才能完成工作,如 CPU 使用时间,存储器,文件以及 I/O 设备,且为依序逐一进行,也就是每个 CPU 内核任何时间内仅能运行一项进程. ###进程包含的资源 一个计算机系统集成包括(或者说拥有)下列资源: 那个程序的可执行机器代码的一个在存储器的映像; 分配到的存储器(通常是虚拟的一个存储器区域).存储器的内容包括可执行代码,特定于进程的数据(输入或输出),调用堆栈(用于保存运行时运输中途产生的数据); 分配给该进程的资源的操作系统描述符,诸如文件描述符( UNIX 术语)或文件句柄( Windows),数据源和数据终端; 安全特性,诸如进程拥有者和进程的权限集(可以容许的操作); 处理器状态,诸如寄存器内容,物理存储器定址等.当进程正在运行时,状态通常保存在寄存器,其他数据保存在存储器. ###进程的状态 进程在运行中,状态会随时发生改变.所谓状态,就是指进程目前的动作: 新生( new):进程新产生重; 运行(running):正在运行; 等待( waiting):等待某事发生,例如等待用户输入完成.也称之为阻塞; 就绪( ready):等待 CPU; 结束( terminated):完成运行. 各状态名称可能虽不同的操作能够系统而不同,对于单核系统( UP),任何时间可能有多个进程为等待,就绪,但必定仅有一个进程在运行. ###进程表 对于一个进程来说,操作系统为了能够在CPU离开后继续执行该进程,会把此时进程运行的所有状态保存下来,为此,操作系统和会维护一张表格,即进程表( process table),每个进程占用一个进程表项(也称之为进程控制块). 对于上图中重要项的解释如下: 寄存器:如累加器,变址寄存器,堆栈指针以及一般用途寄存器,状况代码等,主要用途在于中断 进程时暂时存储数据,以便稍后继续利用;其数量及类别因计算机体系结构有所差异; 程序计数器:接下来要运行的指令地址; 进程状态:可以是 new,ready,running,waiting,blocked或 terminated; 优先级( CPU 排班法):优先级,排班队列等指针以及其他参数; 存储管理:如标签页表,正文段指针,数据段指针以及堆栈指针等; 会计信息:如 CPU 遇实际时间值使用数量,时限,账号,工作或进程号; 输入输出状态:配置进程使用 I/O 设备,如磁带机. Unix进程类 Unix 系统进程概念Unix进程PID在类 Unix 系统中可以使用 ps 命令查询正在运行的进程,比如 ps -eo pid,comm,cmd,下图为执行结果:(-e 表示列出全部进程, -o pis,comm,cmd 表示我们需要 PID,COMMAND,CMD 信息) 每一行代表一个进程.每一行分为三列.第一列为 PID(Process IDentity)是一个整数,每一个进程都有一个唯一的 PID 来表示自己的身份,进程也可以根据 PID 来识别其他的进程.第二列 COMMAND 是该进程的简称.第三列 CMD 是进程所对应的程序以及运行时所带的参数.(第三列有一些由[]括起来的,它们是内核的一部分功能) 在第一行的 PID 为1,名字为 systemd(18.04,版本为16.04该名字为 init).这个进程是执行/sbin/init 这一文件(程序)产生的(不知道我的为什么不是,查看了朋友的是/sbin/init😭).当 Linux 启动的时候, systemd 是系统创建的第一个进程,这一进程会一直存在,直到关闭计算机. 实际上,当计算机开机时,内核( kernel)只建立了一个systemd 进程. Linux 内核并不提供直接建立新进程的系统调用.剩下的所有进程都是 systemd 进程通过fork 机制建立的.新的进程要通过老的进程复制自身得到,这就是fork.fork 是一个系统调用.进程存活于内存中.每个进程都在内存中分配有属于自己的一片空间(address space).当进程fork 的时候, Linux 在内存中开辟出一片新的内存空间给新的进程,并将老的进程空间中的内容复制到新的空间中,此后两个进程同时运行. 老进程成为新进程的父进程(parent process),而相应的,新进程就是老进程的子进程(child process).一个进程除了有一个 PID 之外,还会有一个 PPID(parent PID)来存储父进程的 PID. 如果我们循着 PPID 不断向上追溯的话,总会发现其源头是 systemd 进程.所以说,所有的进程也构成一个以 systemd 为根的树状结构. 进程树使用 pstree命令查看进程树: 可以看到 systemd 进程是整个进程树的根. fork 通常作为一个函数调用,这个函数会有两次返回,将子进程的 PID 返回给父进程,0返回给子进程.实际上,子进程总可以查询自己的 PPID 来知道自己的父进程是谁,这样,一对父子进程就可以随时查询对方.在调用fork 函数后,程序会设计一个 if 选择结构.当 PID 等于0时,说明该进程为子进程,那么让它执行某些指令;而当 PID 为一个正整数时,说明为父进程,则执行另外一些指令.由此,就可以在子进程建立之后,让它执行与父进程不同的功能. 子进程的终结当子进程终结时,它会通知父进程,清空自己所占据的内存,并在内核里留下自己的退出信息( exit code, 如果顺利运行,返回0;如果有错误或异常状况,为&gt;0的整数).在这个信息里,会解释该进程为什么退出.父进程在得知子进程终结时,有责任对该子进程使用 wait 系统调用.这个 wait 函数能从内核中取出子进程的退出信息,清空该信息在内核中所占据的空间.但是,如果父进程早于子进程终结,子进程就会成为一个孤儿(orphand)进程.孤儿进程会过继给 systemd 进程, systemd 进程也就成了该进程的父进程. systemd 进程负责该子进程终结时调用 wait 函数, 一个糟糕的程序也完全可能造成子进程的退出信息滞留在内核中的状况(父进程不对子进程调用 wait 函数),这样的情况下,子进程成为僵尸( zombie)进程.当大量僵尸进程积累时,内存空间会被挤占. 类 UNIX 系统进程和线程的区别尽管在 UNIX 中,进程与线程是有联系但不同的两个东西,但在 Linux 中,线程只是一种特殊的进程.多个线程之间可以共享内存空间和 IO 接口.所以,进程是 Linux 程序的唯一实现方式. Linux创建进程从系统调用fork 中返回时,两个进程除了返回值 PID 不同外,具有完全一样的用户级上下文.在子进程中, PID的值为0.在系统启动时有内核创建的进程1是唯一不通过系统调用fork 而创建的进程.也就是上图的 systemd进程. 内核为系统调用fork 完成下列操作: 为新进程在进程表中分配一个空项; 为子进程赋一个惟一的进程标识号 PID; 做一个父进程上下文的逻辑副本.由于进程的某些部分,如正文区,可能被几个进程所共享,所以内核有时只要增加某个区的引用数即可,而不是真的将该区拷贝到一个新的内存物理区; 增加与该进程相关联的文件表和索引节点表的引用数; 对父进程返回子进程的进程号,对子进程返回零. 下面是系统调用fork 的算法.内核首先确信有足够的资源来完成fork. 如果资源不满足要求,则系统调用fork 失败.如果资源满足要求,内核在进程表中找一个空项,并开始构造子进程的上下文. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546输入:无输出:对父进程是子进程的 PID, 对子进程是0&#123; 检查可用的内核资源 取一个空闲的进程表项和唯一的 PID 号 检查用户没有过多的运行进程 将子进程的状态设置为'创建'状态 将父进程的进程表中的数据拷贝到子进程表中 当前目录的索引节点和改变的根目录(如果可以)的引用数加1 文件表中的打开文件的引用数加1 在内存中做父进程上下文的拷贝 在子进程的系统级上下文中压入虚设系统级上下文层 /* 虚设上下文层中含有使子进程能 /* 识别自己的数据,使子进程被调度时 /* 从这里开始运行if (正在执行的进程是父进程)&#123; 将子进程的状态设置为'就绪'状态 return (子进程的 PID) //从系统到用户 &#125; else &#123; 初始化计时区 return 0; &#125;&#125; 来看下面的例子.该程序说明的是经过系统调用fork 之后,对文件的共享存取.用户调用改程序时应有两个参数,一个是已经有的文件名;另一个是要创建的新文件名.该进程打开已有的文件,创建一个新文件,然后假定没有遇见错误,它调用fork 来创建一个子进程.子进程可以通过使用相同的文件描述符来继承的存取父进程的文件(即父进程已经打开和创建的文件). 当然,父进程和子进程要分别独立的调用rdwrt 函数并执行一个循环,即从源文件中读一个字节,然后写一个字节到目标文件中去.当系统调用 read 遇见文件尾时,函数rdwrt 立即返回. 1234567891011121314151617181920212223242526272829303132#include &lt;fcntl.h&gt;int fdrd, fdwt;char c;main(int argc, char *argv[])&#123; if (argc != 3) &#123; exit(1); &#125; if ((fdrd = open(argv[1], O_RDONLY)) == -1) &#123; exit(1); &#125; if ((fdwt = creat(argv[2], 0666)) == -1) &#123; exit(1); &#125; fork(); // 两个进程执行同样的代码 rdwrt(); exit(0);&#125;rdwrt()&#123; for (;;) &#123; if (read(fdrd, &amp;c, 1) != 1) &#123; return ; &#125; write(fdwt, &amp;c, 1); &#125;&#125; 在这个例子中,两个进程的文件描述符都指向相同的文件表项.这两个进程永远不会读或写到相同的文件偏移量,因为内核在每次 read 和 write 调用后,都要增加文件的偏移量.尽管两个进程似乎是将源文件拷贝了两次,但因为它们分担了工作任务,因此,目标文件的内容依赖于内核调度两个进程的次序.如果内核这样调度两个进程:是它们交替的执行它们的系统调用,甚至使它们交替的执行每对 read 和 write 调用,则目标文件的内容和源文件的内容完全一致.但考虑这样的情况:两个进程正要读源文件中的连续的字符’ab’.假定父进程读了字符’a’,这时,内核在父进程write 之前,做了上下文切换来执行子进程。如果子进程 读到字符 “b”，并在父进程被调度前，将它写到目标文件，那么目标文件将不再含有 字符串 “ab”，而是含有 “ba”了。内核并不保证进程执行的相对速率。 另一个例子: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;string.h&gt;char string[] = "Hello, world";main()&#123; int count, i; int to_par[2], to_chil[2]; // 到父、子进程的管道 char buf[256]; pipe(to_par); pipe(to_chil); if (fork() == 0) &#123; // 子进程在此执行 close(0); // 关闭老的标准输入 dup(to_child[0]); // 将管道的读复制到标准输入 close(1); // 关闭老的标准输出 dup(to_par[1]); // 将管道的写复制到标准输出 close(to_par[1]); // 关闭不必要的管道描述符 close(to_chil[0]); close(to_par[0]); close(to_chil[1]); for (;;) &#123; if ((count = read(0, buf, sizeof(buf)) == 0) exit(); write(1, buf, count); &#125; &#125; // 父进程在此执行 close(1); // 重新设置标准输入、输出 dup(to_chil[1]); close(0); dup(to_par[0]); close(to_chil[1]); close(to_par[0]); close(to_chil[0]); close(to_par[1]); for (i = 0; i &lt; 15; i++) &#123; write(1, string, strlen(string)); read(0, buf, sizeof(buf)); &#125;&#125; 子进程从父进程继承了文件描述符0和1(标准输入和标准输出)。两次执行系统调用 pipe 分别在数组 to_par 和 to_chil 中分配了两个文件描述符。然后该进程 执行系统调用 fork，并复制进程上下文：象前一个例子一样，每个进程存取 自己的私有数据。父进程关闭他的标准输出文件(文件描述符1)，并复制(dup)从管道 线 to_chil 返回的写文件描述符。因为在父进程文件描述符表中的第一个空槽是刚刚 由关闭腾出来的，所以内核将管道线写文件描述符复制到了文件描述符表中的第一 项中，这样，标准输出文件描述符变成了管道线 to_chil 的写文件描述符。 父进程以类似的操作将标准输入文件描述符替换为管道线 to_par 的读文件 描述符。与此类似，子进程关闭他的标准输入文件(文件描述符0)，然后复制 (dup) 管道 线 to_chil 的读文件描述符。由于文件描述符表的第一个空项是原先的标准 输入项，所以子进程的标准输入变成了管道线 to_chil 的读文件描述符。 子进程做一组类似的操作使他的标准输出变成管道线 to_par 的写文件描述 符。然后两个进程关闭从 pipe 返回的文件描述符。上述操作的结果是：当 父进程向标准输出写东西的时候，他实际上是写向 to_chil–向子进程发送 数据，而子进程则从他的标准输入读管道线。当子进程向他的标准输出写的时候， 他实际上是写入 to_par–向父进程发送数据，而父进程则从他的标准输入 接收来自管道线的数据。两个进程通过两条管道线交换消息。 无论两个进程执行的顺序如何，这个程序执行的结果是不变的。他们可能去执行睡眠 和唤醒来等待对方。父进程在15次循环后退出。然后子进程因管道线没有写进程而读 到“文件尾”标志，并退出。 Windows进程进程 PIDwindows 也是使用 PID 来唯一标识一个进程. 在一个进程内部,使用进程句柄来标识关注的每个进程.使用 Windows API 从进程 PID 获取进程句柄: 1OpenProcess(PROCESS_ALL_ACCESS, TRUE, procId); //或者PROCESS_QUERY_INFORMATION 使用 API 函数: GETModuleFileNameEx 或 GetProcessImageFileName 或QUeryFullProcessImageName 查询进程的 exe 文件名,使用 API 函数 GetCurrentProcess可以获取本进程的伪句柄(值为-1),只能用于本进程的 API 函数调用;不能被其他进程继承或复制.可用 API 函数 DuplicateHandle 获得进程的真句柄. Windows创建进程Windows 系统使用 CreateProcess 创建进程, WaitForSingleObject 可等待子进程的结束.例如: 12345678910111213141516171819202122232425262728293031#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;void main() &#123; STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(&amp;si, sizeof(si)); si.cb = sizeof(si); ZeroMemory(&amp;pi, sizeof(pi)); // Start the child process. if (!CreateProcess(NULL, // No module name (use command line) "demo.exe arg1", // Command line NULL, // Process handle not inheritable NULL, // Thread handle not inheritable FALSE, // Set handle inheritance to FALSE 0, // No creation flags NULL, // Use parent's environment block NULL, // Use parent's starting directory &amp;si, // Pointer to STARTUPINFO structure &amp;pi) // Pointer to PROCESS_INFORMATION structure,用于给出子进程主窗口的属性 ) &#123; printf("CreateProcess failed (%d).\n", GetLastError()); return; &#125; // Wait until child process exits. WaitForSingleObject(pi.hProcess, INFINITE); // Close process and thread handles. CloseHandle(pi.hProcess); CloseHandle(pi.hThread);&#125; 父子进程关系创建的子进程可以继承父进程的: CreateFile 返回的打开句柄,包括文件,控制台输入缓冲区,控制台屏幕缓冲区,命名管道,串口通信设备,邮槽; 打开的句柄,包括:进程,线程,互斥锁,事件对象,信号量,命名管道,匿名管道,文件映射对象; 环境变量; 当前目录; 控制台,除非进程脱离( detach)或创建了新的控制台; 错误模式,使用 API 函数 SetErrorMode 设置; 进程亲和掩码( affinity mask),用以指示期望使用 CPU 的哪些核; 在哪个任务中. 子进程不能继承: 优先级类别 Priority class; 句柄,有 LocalAlloc,GlobalAlloc,HeapCreate,HeapAlloc 返回; 伪句柄,有 GetCurrentProcess或 GetCurrentThread 返回; DLL 模块句柄,由 LoadLibrary 返回; GDI 对象句柄或 USER 对象句柄,如 HBITMAP 或 HMENU. 为继承句柄,父进程在创建(或者代开,复制)各种可继承对象句柄时,在 SECURITY_ATTRIBUTES 结构的 blnheritHandle 成员为 TRUE. 在 CreateProcess 的blnheritHandles 参数为 TRUE; 如果要继承标准输入,标准输出,标准错误的句柄, STARTUPINFO 结构的 dwFlags 成员包含 STARTF_USESTDHANDLES 标志位. 获取进程信息的相关函数 GetCommandLine：当前进程的命令行字符串 GetStartupInfo：当前进程被创建时的STARTUPINFO结构 GetProcessVersion：获取可执行头的版本信息 GetModuleFileName：获取包含了进程代码的可执行文件的全路径与文件名 GetGuiResources：获取使用中的GUI对象的句柄数量 IsDebuggerPresent：确定进程是否被调试 GetProcessIoCounters：获取进程执行的所有I/O操作的薄记信息。 GetProcessMemoryInfo：获取进程的工作集内存的信息 GetProcessWorkingSetSize：获取进程的工作集内存被允许的下限与上限 SetProcessWorkingSetSize：设置进程的工作集内存的下限与上限 进程终结子进程终止时,所有打开的句柄被关闭,进程对象被处罚( signaled).进程的退出码( exit code)或者 ExitProcess,TerminateProcess 函数中指出,或者是 main,WinMain 函数返回值.如果进程由于一个致命异常(fatal exception)而终止,退出码是这个异常值,同时进程的所有执行中的线程的退出码也是这个异常值. 优雅的关闭其他进程的方法使用RegisterWindowMessage 登记私有消息,用 BroadcastSystemMessage 播放消息,收到消息的进程用ExitProcess关闭. 获取特定名字的进程 PID如果想要获取特定名字的进程的ID，需要枚举所有进程。传统办法是CreateToolhelp32Snapshot、Process32First、Process32Next函数；也可以使用EnumProcesses、EnumProcessModules函数来获取所有的进程ID，一个进程的所有模块的句柄。示例如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344PROCESSENTRY32 pe32;HANDLE hSnaphot;HANDLE hApp;DWORD dProcess;hSnaphot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); // 获取进程快照Process32First(hSnaphot, &amp;pe32); // 枚举第一个进程do &#123; if (lstrcmpi(pe32.szExeFile, _T("NotePad.exe")) == 0) &#123; // 查找进程名称为 NotePad.exe dProcess = pe32.th32ProcessID; break; &#125;&#125; while (Process32Next(hSnaphot, &amp;pe32)); // 不断循环直到枚举不到进程hApp = OpenProcess(PROCESS_VM_OPERATION | SYNCHRONIZE, FALSE, dProcess); // 根据进程 ID 获取程序的句柄if (!WaitForSingleObject(hApp, INFINITE)) // 等待进程关闭 AfxMessageBox(" 记事本已经关闭！");// 另一种方法DWORD aProcId[1024], dwProcCnt, dwModCnt;HMODULE hMod[1000];TCHAR szPath[MAX_PATH];// 枚举出所有进程IDif (!EnumProcesses(aProcId, sizeof(aProcId), &amp;dwProcCnt)) &#123; //cout &lt;&lt; "EnumProcesses error: " &lt;&lt; GetLastError() &lt;&lt; endl; return 0;&#125;// 遍例所有进程for (DWORD i = 0; i &lt; dwProcCnt; ++i) &#123; // 打开进程，如果没有权限打开则跳过 HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, aProcId[i]); if (NULL != hProc) &#123; // 打开进程的第1个Module，并检查其名称是否与目标相符 if (EnumProcessModules(hProc, &amp;hMod, 1000, &amp;dwModCnt)) &#123; GetModuleBaseName(hProc, hMod, szPath, MAX_PATH); if (0 == lstrcmpi(szPath, lpName)) &#123; CloseHandle(hProc); return aProcId[i]; &#125; &#125; CloseHandle(hProc); &#125;&#125;return 0;]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程（六）]]></title>
    <url>%2F2018%2F11%2F11%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[前言在上篇文章解决了 TCP 和 UDP 并发的问题,是通过一个 socketserver模块实现的,那么这个模块到底做了什么可以实现并发的效果呢? socketserver 源码分析进入 socketserver 中查看注释: 翻译如下: 通用套接字服务类 该模块试图捕获定义服务器的各个方面 基于套接字的服务器 基于请求的服务器 在进一步查看请求之前进行客户地址验证,(这实际上是一个钩子,用于任何需要在进行其他操作之前查看请求的处理) 如何处理多个请求: ​ 同步(一次处理一个请求) ​ 分叉(每个请求由一个新进程处理) ​ 线程化(每个请求由一个新线程处理) 这个模块的类喜欢编写最简单的服务器类型:一个同步的 TCP/IP 服务器.这是糟糕的设计,但是节省了一些输入.(还有一个问题是,深度类层次结构会减慢方法查找的速度) 在继承关系图中有五个类,其中四个表示四种类型的同步服务器: 注意UnixDatagramServer 继承于 UDPServer, 而不是 UnixStreamServer–IP 和 Unix 服务器之间的唯一区别是地址族,这在两个 Unix 服务器类中都是重复的. 可以使用FrokingMixIn 和ThreadingMixIn 混合类创建每种类型服务器的进程和线程版本.例如,创建一个线程 UDP 服务器如下所示: 12class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass 混合类必须首先出现,因为它覆盖了 UDPServer 中定义的方法,设置各种成员变量还会改变底层服务器机制的行为. 要实现服务,必须从 BaseRequestHandler 派生一个类,并重新定义它的 handle() 方法.然后,你可以通过将一个服务器类与请求处理程序类组合在一起来运行服务的不同版本. 对于数据报或流式服务器,请求处理程序类必须是不同的.这可以通过使用请求处理程序子类 StreamRequestHandler 或 DatagramRequestHandler 类来隐藏. 当然,你还得动动脑子. 例如,如果服务在内存中包含可以由请求修改的状态,那么使用进程服务器是没有意义的(因为子进程中的修改永远不会达到父进程中保留并传递给每个子进程的初始状态).在这种情况下,你可以使用线程化服务器,但是你可能必须使用锁来避免几乎同时出现的两个请求,以对服务器状态应用冲突更改. 另一方面,如果你正在构建一个 HTTP 服务器,其中所有数据都存储在外部(例如文件系统中),同步类本质上是在处理一个请求时使服务’听不见’,如果客户端读取其请求的所有数据很慢,那么这种情况可能会持续很长时间,在这里,线程或进程服务器是合适的. 在某些情况下,同步的处理请求的一部分可能是合适的,但根据请求数据在进程子节点中完成处理可能是合适的.这可以通过使用同步服务器和在请求处理程序类 handle() 方法中执行显式进城来实现. 处理多个同时请求的另一种方法既不支持线程也不支持进程的环境(这些环境太昂贵或不适合服务)是维持一个部分完成的请求的显式表和使用选择器决定下一个要处理的请求(或者是否处理新的请求)对对流服务尤为重要.每个客户端可能长时间连接的地方.(如果线程或子线程不能使用) 未来的工作: ​ Sun RPC 的标准类(使用 TCP 或 UDP) ​ 标准混合类实现各种身份验证 总结: 上面的翻译是 socketserver 的注释翻译,能够是我们大致了解该模块的工作流程.那么当我们自定义自己的类是如何进行实例化得呢? 结合源码查看自定义类的步骤该模块分为两大类: server 类(解决连接问题)和 request 类(解决通信问题) server 类继承关系: request 类继承关系: 总结继承关系: 以下述代码为例,分析 socketserver 源码: 服务端 12345678910111213141516171819202122232425262728293031323334353637383940414243import socketserverimport jsonimport structimport osclass FtpServer(socketserver.BaseRequestHandler): coding = 'utf-8' server_dir = 'file_upload' max_packet_size = 1024 BASE_DIR = os.path.dirname(os.path.abspath(__file__)) def handle(self): print(self.request) while True: data = self.request.recv(4) data_len = struct.unpack('i', data)[0] head_json = self.request.recv(data_len).decode(self.coding) head_dic = json.loads(head_json) cmd = head_dic['cmd'] if hasattr(self, cmd): func = getattr(self, cmd) func(head_dic) def put(self, args): file_path = os.path.normpath(os.paht.join( self.BASE_DIR, self.server_dir, args['filename'])) filesize = args['filesize'] recv_size = 0 print('----&gt;', file_path) with open(file_path, 'wb') as f: while recv_size &lt; filesize: recv_data = self.request.recv(self.max_packet_size) f.write(recv_data) recv_size += len(recv_size) print('recvsize: %s filessize: %s' % (recv_size, filesize))ftpserver = socketserver.ThreadingTCPServer(('', 8080), FtpServer)ftpserver.serve_forever() 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import socketimport structimport jsonimport osclass MyTCPClient: address_family = socket.AF_INET socket_type = socket.SOCK_STREAM allow_reuse_address = False max_packet_size = 8192 coding = 'utf-8' request_queue_size = 5 def __init__(self, server_address, connect=True): self.server_address = server_address self.socket = socket.socket(self.address_family, self.socket_type) if connect: try: self.client_connect() except: self.client_close() raise def client_connect(self): self.socket.connect(self.server_address) def client_close(self): self.socket.close() def run(self): while True: inp = input('&gt;&gt;&gt;:').strip() if not inp: continue l = inp.split() cmd = l[0] if hasattr(self, cmd): func = getattr(self, cmd) func(l) def put(self, args): cmd = args[0] filename = args[1] if not os.path.isfile(filename): print('file: %s is not exist' % filenam) return else: filesize = os.path.getsize(filename) head_dic = &#123;'cmd': cmd, 'filename': os.path.basename(filename), 'filesize': filesize&#125; print(head_dic) head_json = json.dumps(head_dic) head_json_bytes = bytes(head_json, encoding=self.coding) head_struct = struct.pack('i', len(head_json_bytes)) self.scoket.send(head_struct) self.socket.send(head_json_bytes) send_size = 0 with open(filename, 'rb') as f: for line im f: self.socket.send(line) send_size += len(line) print(send_size) else: print('upload successful') client = MyTCPClient(('', 8080))client.run() 以上述代码为例,分析 socketserver源码: 12ftpserver = socketserver.ThreadingTCPServer(('', 8080))ftpserver.serve_forever() 查找属性的顺序可以从上面第三个继承图得到答案: 1ThreadingTCPServer-&gt;ThreadingMixIn-&gt;TCPServer-&gt;BaseServer 实例化得到 ftpserver, 先查找 ThreadingTCPServer 的初始化方法,发现左继承的 ThreadingMixIn 没有初始化方法,于是在 TCPServer 中找到,然后执行self.server_bind和 self.server_activate 方法; 初始化成功后执行ftpserver.serve_forever,发现在 ThreadingMixIn和 TCPServer 中都没有,于是只好去 BaseServer 中找到并执行 serve_forever,进而执行 self._handle_request_noblock(),该方法同样在 BaseServer 中 执行self_handle_request_noblock()进而执行 request,client_address = self.get_request(),在这里发现在 TCPServer 中有该方法,于是执行这个方法 执行 self.socket.accept(),发现该方法在 socket 中,然后执行 self.process_address(request, client_address) 在 ThreadingMixIn 中找到process_request, 开启多线程应对并发,进而执行process_request_thread,执行 self.finish_request(request, client_address) 上述四部分完成了连接循环,接下来进入处理通信部分,在 BaseServer 中找到 finish_request,触发我们定义的类的实例化并初始化一个对象,因为自己定义的类中中没有该方法,则依据继承关系计算出的 MRO 列表查找属性 源码分析总结: 基于 TCP 的 socketserver 定义出的类: self.server 即套接字对象; self.request 即一个连接; self.client_address即客户端地址 基于 UDP 的 socketserver 定义出的类: self.request 是一个元祖(第一个元素是客户端发来的数据,第二部分是服务端的 udp 套接字对象),如(b’musibii’, &lt;socket.socket fd=200, family=AddressFamily.AF_INET, type=SocketKind.SOCK_DGRAM, proto=0, laddr=(‘127.0.0.1’, 8080)&gt;); self.client_address 即客户端地址. 总结本文查看了一下 socketserver 模块的源码,大致的实例化对象的步骤和主要运行流程差不多搞清楚了,但是有些地方还是需要仔细琢磨的,比如第五步怎么一下就到开启多线程实现并发了. 总的来说,查看源码还是有点用的,而且该模块的继承也对之前学习的继承知识进行了补充,特别是根据继承解析出来的( MRO)列表,这个列表是类中属性的查找顺序表,和是否直接继承没有关系.]]></content>
      <categories>
        <category>socketserver源码探析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[并发编程（一）]]></title>
    <url>%2F2018%2F11%2F11%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[前言该系列为并发编程,在几乎所有的编程语言中,并发始终是绕不开的坎,可以说学习一门编程语言,学好了并发就说明这门语言你学的还可以.所以接下来就让我们好好看看 python 的并发是怎么实现的吧. 在学习并发之前,有必要学习一下计算机操作系统发展史,因为可以实现并发可操作系统的发展是分不开的. 操作系统发展史操作系统的发展史在某种意义上来说也是计算机的发展史.操作系统提供对硬件控制的调用和应用程序所必需的功能. 背景早期的计算机没有操作系统.只有单独的机器,操作者会带着记录有程序和数据的卡片或较后期的打孔纸带去操作机器.程序读入机器后,机器就开始工作直到程序停止.由于程序难免有误,所以机器通常都会中途崩溃.程序一般通过控制板的开关和状态灯来调试. 后来,机器引入帮助程序输入输出等工作的代码库.这是现代操作系统的起源.然而,机器每次只能执行一个任务.在英国剑桥大学,这些任务的磁从前是排成一排挂在衣钩上的,衣钩的颜色代表任务的优先级. 概念意义上的操作系统和通俗意义上的操作系统差距越来越大.通俗意义上的操作系统为了方便而把最普通的包和应用程序的集合包括在操作系统内.随着操作系统的发展,一些功能更强的’第二类’操作系统软件也被包括进去.在今天,没有图形界面和各种文件浏览器已经不能称之为一个真正的通俗意义上的操作系统,但事实上,运行在数据中心和服务器等领域的操作系统往往是没有图形界面的. 第一代计算机(1940~1955):真空管和穿孔卡片第一代之前人类是想用机械取代人力，第一代计算机的产生是计算机由机械时代进入电子时代的标志，从Babbage失败之后一直到第二次世界大战，数字计算机的建造几乎没有什么进展，第二次世界大战刺激了有关计算机研究的爆炸性进展。 lowa州立大学的john Atanasoff教授和他的学生Clifford Berry建造了据认为是第一台可工作的数字计算机。该机器使用300个真空管。大约在同时，Konrad Zuse在柏林用继电器构建了Z3计算机，英格兰布莱切利园的一个小组在1944年构建了Colossus，Howard Aiken在哈佛大学建造了Mark 1，宾夕法尼亚大学的William Mauchley和他的学生J.Presper Eckert建造了ENIAC。这些机器有的是二进制的，有的使用真空管，有的是可编程的，但都非常原始，设置需要花费数秒钟时间才能完成最简单的运算。 在这个时期，同一个小组里的工程师们，设计、建造、编程、操作及维护同一台机器，所有的程序设计是用纯粹的机器语言编写的，甚至更糟糕，需要通过成千上万根电缆接到插件板上连成电路来控制机器的基本功能。没有程序设计语言（汇编也没有），操作系统则是从来都没听说过。 第二代计算机(1955~1965):晶体管和批处理系统由于当时的计算机非常昂贵,自认很自然的想办法减少计算机运行时间的浪费.通常采用的就是批处理系统. 特点:设计人员、生产人员、操作人员、程序人员和维护人员直接有了明确的分工，计算机被锁在专用空调房间中，由专业操作人员运行，这便是‘大型机’,有了操作系统的概念. 有了程序设计语言：FORTRAN语言或汇编语言，写到纸上，然后穿孔打成卡片，再讲卡片盒带到输入室，交给操作员，然后喝着咖啡等待输出接口. 工作过程: 第二代计算机解决了第一代计算机的一些问题: 把一个人的输入改为批量输入; 然后顺序计算(这个仍然有问题); 把一个人的输出改为批量输出. 优点:因为是批处理系统,节省了计算机的使用时间,增加的计算机的使用效率; 缺点: 整个流程需要人参与控制,将磁带搬来搬去; 计算的过程仍然是顺序计算-&gt;串行; 程序员原来独享一段时间的计算机,现在必须被统一规划到一批作业中,等待结果和重新调试的过程都需要等同批次的其他程序都运行完才可以接着使用. 第三代计算机(1965~1980):集成电路芯片和多道程序设计在第三道计算机的操作系统广泛的应用了第二代计算机的操作系统没有的关键技术:多道技术. 多道程序设计技术就是指允许多个程序同时进入内存并运行.即同时把多个程序放入内存,并允许他们交替在 CPU 中运行,它们共享系统中的各种硬,软件资源.当一道程序因 I/O 请求而暂停运行时, CPU 便立即转去运行另一道程序. 多道技术: ​ 多道技术中的多道指的是多个程序,多道技术的实现是为了解决多个程序竞争或者说共享同一个资源(比如 CPU)的有序调度问题,解决方式即多路复用,多路复用分为时间和空间的复用. 空间复用: ​ 将内存分为几部分,每个部分放入一个程序,这样,同一时间内内存中就有了多道程序. 时间复用: ​ 当一个程序在等待 I/O 时,另一个程序可以使用 CPU, 如果内存中可以同时存放足够多的任务,则 CPU 的利用率可以接近100%.操作系统采用了多道技术后,可以控制进程的切换,或者说进程之间去争抢CPU 的执行权限.这种切换不仅会在一个进程遇到 I/O 时进行,一个进程占用 CPU 时间过长也会切换,或者说被操作系统夺走 CPU 的执行权限. 详解: ​ 现代计算机或者网络都是支持多用户登录的,多个用户不仅共享硬件,而且共享文件,数据库等信息,共享意味着会发生冲突和运行无序. 操作系统的主要作用为: 记录哪个程序使用什么资源; 对资源请求进行分配; 为不同的程序和用户调解互相冲突的资源请求. 我们将上述操作系统的功能总结为:处理来自多个程序发起的多个(多个即多路)共享(共享即复用)资源的请求,简称多路复用. 在空间复用上的问题为:程序之间的内存必须隔离,这种隔离需要在硬件层面上实现,由操作系统控制.如果内存彼此不分割,则一个程序可以访问另外一个程序的内存,这样一来就会产生应用程序的数据不安全,比如你的 qq 程序可以访问操作系统的内存,这意味着 qq 可以拿到操作系统的所有权限.其次丧失的是稳定性,某个程序崩溃时有可能把其他的程序的内存一起回收了,比如说把操作系统的内存回收,则操作系统崩溃. 第四代计算机(1980~):个人计算机时代微型处理器的发展使计算机的应用普及至中小企业及个人爱好者。而计算机的普及又推动了硬件组件公共接口的发展（如S-100,SS-50,Apple II,ISA和PCI总线），并逐渐地要求有一种“标准”的操作系统去控制它们。在这些早期的计算机中，主要的操作系统是8080/8085/Z-80 CPU用的CP/M-80，它创建在数字研究公司(Digital Research)先前几个针对PDP-11架构的操作系统的基础上。在此基础上又产生了MS-DOS（或IBM公司的PC-DOS）。这些计算机在ROM（只读存储器）都有一个小小的启动程序，可以把操作系统从磁盘装载到内存。IBM-PC系列的BIOS是这一思想的延伸。自1981年第一台IBM-PC诞生以来，BIOS的功能得到不断地增强。 随着显示设备和处理器成本的降低，很多操作系统都开始提供图形用户界面。如：许多UNIX提供的X Window一类的系统、微软的Windows系统、苹果公司的Mac OS和IBM公司的OS/2等。最初的图形用户界面是由Xerox Palo Alto研究中心70年代初期研发出来的，之后被许多公司模仿，继承发展。 操作系统的作用 隐藏了复杂的硬件调用接口,为应用程序员调用硬件资源提供更好,更简单,更清晰的模型.应用程序员有了这些接口后,就可以不用考虑操作硬件的细节,专心写代码即可; 将应用程序对硬件资源的竞争请求变得有序. 多道技术在之前第三代计算机的时候产生了多道技术,可以更高效率的使用计算机的资源.产生背景为:那时候的计算机都是单核,为了能够同一时间运行多个程序产生了多道技术. 多道技术的产生直接影响了计算机的发展方向,多道技术出现后,单核可以实现并发工作了.]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程（五）]]></title>
    <url>%2F2018%2F11%2F10%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[前言在上一篇文章中我们学习了 基于 TCP 套接字的服务端和客户端通信,并解决了粘包的问题,解决粘包问题的思路很简单,就是确保接受方能够把数据收取干净,发多少,就收多少. 出现粘包的问题:原因有两个,一个是接收数据量少于发送数据量;一个是因为为了优化 TCP 的传输效率,使用了 Nagle算法,当客户端连续发送时间间隔很短的两个数据包时,在未确认数据发送的时候让发送器把数据送到系统缓存里.任何数据随后继续直到得到明显的数据确认或者直到攒到了一定数量的数据了再发包. 这是不可避免的,为了优化传输效率,尽量发送大块数据,避免网络中充斥的许多小数据块.知道了解决方法,那么避免粘包就很简单了,只需要在每次发送数据之前先发送真实数据的长度,然后接收方可以根据收到的真实长度收取数据了. SOCKET使用SOCKET AF_INET套接字主要有两种协议,现在来看 UDP 协议是如何进行网络通信的. 基于 UDP 连接的套接字tcp 是无连接,不稳点的套接字,但是传输效率较高,所以在某些应用上如实时直播,游戏, DNS 服务器,DHCP 服务器等等. 服务端 12345678910from socket import *serverSock = socket(AF_INET, SOCK_DGRAM)serverSock.bind(('', 8080))while True: data, client_addr = serverSock.recvfrom(1024) print(data) serverSock.sendto(data.upper, client_addr)serverSock.close() 客户端 123456789from socket import *clientSock = socket(AF_INET, SOCK_DGRAM)while True: msg = input('&gt;&gt;&gt;').strip() clientSock.sendto(msg.encode('utf-8'), ('', 8080)) data, server_addr = clientSock.recvfrom(1024) print(data) 当我们连续开多个客户端和服务端通信的时候,没有出现阻塞的情况,发出去的消息都可以收回来,这是因为 udp 是无连接的套接字,不用关注一个连接,只要你给我发消息拿到了发送方的 ip 和端口,那么就可以直接和你通信,而且不像 TCP 那样必须先启动服务端才可以, udp 在发送数据的时候,服务端没有启动也可以发送过去,只不过是发到了对方的系统缓存中. 那么 udp 可以实现多个客户端同时和客户端通信吗? 之前几个客户端可以同时和服务端通信是因为服务端的处理能力很大,看起来是同时通信一样,但是如果把客户端加到 1w, 甚至更多就会感觉到明显的时间差了. 那么如何可以实现真正的并发呢?关键点就在一个通信循环和连接循环互相不干扰,不用因为 i/o 堵塞而耽搁另一个循环要做的事. Socketserver 模块实现并发在这里 python 有一个模块为 socketserver 可以实现真正的并发. 基于 TCP 协议的并发服务端 123456789101112131415161718import sockerserverclass MyTCPhandler(socketserver.BaseRequestHandler): def handler(self): while True: try: data = self.request.recv(1024) if len(data) == 0: break print('--&gt;收到客户端的消息:', data) self.request.send(data.upper()) except ConnectResetError: break self.request.close() if __name__ == '__main__': serverSock = socketserver.ThreadingTCPServer(('127.0.0.1', 8081), MyTCPhandler) serverSock.serve_forever() # 和客户端进行连接 客户端 123456789101112from socket import *clientSock = socket(AF_INET, SOCK_STREAM)clientSock.connect(('127.0.0.1', 8081))# 通信循环while True: clientSock.send(b'hello') data = clientSock.recv(1024) print(data) clientSock.close() 这样就解决了 TCP 不能实现并发的问题了. 基于 UDP 协议的并发服务端 12345678910import socketserverclass MyUDPhandler(socketserver.BaseRequestHandler): def handler(self): data, serverSock = self.request serverSock.sendto(data.upper(), self.client_address) if __name__ == '__main__': server = socketserver.ThreadingUDPServer(('127.0.0.1', 8081), MyUDPhandler) server.serve_forever() 客户端 12345678from socket import *clientSock = socket(AF_INET, SOCK_DGRAM)while True: clientSock.sendto(b'hello', ('127.0.0.1', 8081)) data, server_addr = client.recvfrom(1024) print(data) 这就是 UDP 实现并发的模板. 总结到此,网络编程终于告一段落了,其实我写的是网络编程里面极少的也是较为重要的一部分,还有很多底层协议没了解,像 ping 服务器时发送的 ICMP 包,还有很多,不过我觉得了解了这些其实也就了解了互联网工作的基本方式,其余的待有时间了再来学习. 如有不对的地方,欢迎指正.]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程（四）]]></title>
    <url>%2F2018%2F11%2F09%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[前言经过之前三篇文章的学习我们大致了解了互联网是如何基于五层协议进行通信了,由应用层产生数据,然后进行封装,依次经过传输层,网络层,数据链路层的封装最后由物理层发送电信号进行数据的传输,在接收端首先由物理层接收到字节型的数据,然后拆包,验证 MAC 地址, IP 地址和端口,最后由目标应用获取数据并解码出来. 那么为了使用 TCP 协议建立连接,不用去管什么三次握手四次挥手以及数据到底是怎么在互联网中传输的,在应用层和传输层虚拟出一个抽象层,叫 socket( 套接字)层,这是一个模块为我们封装好了很多底层的协议,以便于我们只关注与实际的数据传输,而不用关系底层的实现. 所以我们就直接使用套接字和网络通信进行交互. socketsocket是什么socket是应用层与 TCP/IP协议族通信的中间软件抽象层,它是一组接口.在设计模式中, socket 就是一个模块,它把复杂的 TCP/IP 协议族隐藏在 socket 接口后面,对用户来说,一组简单的接口就是全部,让 socket 去组织数据,以符合指定的协议. 也有人说, socket 其实就是 ip 和 port 的组合, ip 用来标识互联网中的一台主机的位置,而 port 是用来标识这台机器上的一个应用程序, ip 地址是配置到网卡的,而 port 是应用程序开启的,这样 ip 和 port 就标识了互联网中独一无二的一个应用程序. 套接字发展史即分类套接字起源于20世纪70年代加利福尼亚大学伯克利分校版本的 Unix, 即 BSD Unix. 因此,有时人们也把套接字称为’伯克利套接字’或’ BSD 套接字’.一开始,套接字被设计用在同一台主机上的多个应用程序之间的通信.这也被称之为进程间通信或 IPC(inter-process communication).套接字有两大家族,分别是基于文件型和基于网络型.我们主要学习基于网络型的套接字. 基于文件类型的套接字家族: 套接字家族名字: AF_UNIX UNIX 哲学为一切皆文件(其实也不是所有的),基于文件的套接字调用的就是底层的文件系统来取数据,两个套接字进程运行在同一机器,可以通过访问同一个文件系统间接完成通信. 基于网络类型的套接字家族: 套接字家族名字: AF_INET 基于网络也就是 OSI 协议进行数据通信 套接字工作流程其实就跟打电话很像,有拨号,接电话,通信,挂电话 首先由服务端初始化一个套接字对象,然后与本机的某个大于1023的端口绑定( bind),接着对该端口进行监听(listen),调用 accept 接口阻塞等待客户端的连接.如果在这时客户端初始化一个套接字对象,然后连接(connect)服务端的 ip 和port,如果连接成功,这时客户端与服务端的连接就建立成功了. 这时候可能有人再问了,三次握手呢? 当客户端 connect 服务端的时候就说明三次握手开始了,如果服务端 accept 有返回值,那么就说明三次握手成功.(可以使用 wireshark 进行抓包分析)wireshark 教程 TCP 连接建立成功后客户端和服务端就可以进行数据交互了.客户端发送数据请求,服务端接收请求并处理请求,然后把回应数据发送给客户端,客户端读取数据,最后关闭连接,一次通信结束. SOCKET使用套接字服务端通用使用方法from socket import * sct = socket(socket_family, socket_type, protocal=0) socket_family 可以为AF_UNIX 或 AF_INET,socket_type 可以是 SOCK_STREAM 或 SOCK_DGRAM.protocol 一般不填,缺省值为0. 获取 tcp/ip 套接字 tcpSock = socket(AF_INET, SOCK_STREAM) 绑定 ip port tcpSock.bind((&#39;&#39;, 8080)) 开始监听 tcpSock.listen(5) 被动接受 TCP 客户端连接(阻塞式) tcpSock.accept() 获取 udp/ip 套接字 udpSock = socket(AF_UNIX, SOCK_DGRAM) 绑定 ip port udpSock.bind((&#39;&#39;, 8081)) 套接字客户端通用方法连接服务端主动初始化 TCP 服务器连接 tcpSock.connect((&#39;&#39;, 8080)) 公共用途的套接字函数sock.recv() 接收 TCP 数据 sock.send() 发送 TCP 数据( send 在待发送数据量大于已端缓存区剩余空间时,数据将会丢失) sock.sendall() 发送完整的 TCP 数据(本质就是循环调用 send,sendall 在待发送数据量大于已端缓存区剩余空间时,数据不丢失,循环调用 send 知道发完) sock.recvfrom() 接收 UDP 数据 sock.sendto() 发送 UDP 数据 sock.getpeername() 连接到当前套接字的远端地址 sock.getsockname() 获取当前套接字的地址 sock.getsockopt() 返回指定套接字的参数 sock.setsockopt() 设置指定套接字的参数 sock.close() 关闭套接字 基于 TCP 连接的套接字tcp 是基于连接的,必须先启动服务端,然后再启动客户端去连接服务端 tcp 服务端 12345678910111213141516171819from socket import *# 创建tcp套接字对象serverSock = socket(AF_INET, SOCK_STREAM)# 绑定 ip 和端口serverSock.bind(('', 8080))# 监听连接serverSock.listen(5)# 被动等待客户端的连接,如果有客户端连接会返回一个用于和客户端通信的套接字以及客户端的地址conn, addr = serverSock.accept()# 接收客户端的数据data = conn.recv(1024)# 给客户端返回数据conn.send(data2) tcp 客户端 123456789101112131415161718from socket import *# 创建客户端套接字对象clientSock = socket(AF_INET, SOCK_STREAM)# 连接服务器clientSock.connect(('', 8080))# 发送数据到服务端data = input('&gt;&gt;&gt;').strip()clientSock.send(data.encode('utf-8'))# 接收服务端的数据data = clientSock.recv(1024)print(data.decode('utf-8'))# 关闭客户端套接字clientSock.close() 基于 TCP 的通信循环套接字在上个版本中,服务端和客户端进行了一次通信就关闭了,很明显和实际应用不符合,所以加上通信循环,使得客户端可以和服务端进行多次通信. 服务端必须满足三点要求: 绑定一个固定的 ip 和 port 一直对外提供稳定的服务 能够支持并发(学了多进程多线程可以支持) 服务端 1234567891011121314151617181920212223from socket import *serverSock = socket(AF_INET, SOCK_STREAM)serverSock.bind(('', 8081))serverSock.listen(5)conn, addr = serverSock.accept()# 通信循环while True: try: data = conn.recv(1024) if len(data) == 0:break # 针对 linux 系统 print('--&gt;收到客户端消息:', data) conn.send(data.upper()) except ConnectionResetError: breakconn.close()serverSock.close()# 加上异常处理是因为当客户端异常断开连接时,服务端会报错 客户端 12345678910111213from socket import *clientSock = socket(AF_INET, SOCK_STREAM)client.connect(('', 8081))# 通信循环while True: msg = input('&gt;&gt;&gt;:').stript() clientSock.send(msg.encode('utf-8')) data = clientSock.recv(1024) print(data)clientSock.close() 基于 TCP 的连接循环通信循环套接字在上一个版本中解决了客户端重复发消息的问题,但是作为一个服务端不可能只为一个客户提供服务,所以服务端必须可以接收多个连接(并发),这里实现的是伪并发. 服务端 12345678910111213141516171819202122from socket import *serverSock = socket(AF_INET, SOCK_STREAM)serverSock.bind(('', 8082))serverSock.listen(5)# 连接循环while True: conn, addr = serverSock.accept() print(conn) # 通信循环 while True: try: data = conn.recv(1024) if len(data) == 0: break print('--&gt;收到客户端的消息:', data) conn.send(data.upper()) except ConnectionResetError: break conn.close()serverSock.close() 客户端 12345678910111213from socket import *clientSock = socket(AF_INET, SOCK_STREAM)client.connect(('', 8081))# 通信循环while True: msg = input('&gt;&gt;&gt;:').stript() clientSock.send(msg.encode('utf-8')) data = clientSock.recv(1024) print(data)clientSock.close() 至此一个可以接受多个客户端连接的 C/S 通信程序就完成了,不过服务端连接了一个客户端,那么只能为这个客户端服务,只有等这个客户端断开连接才可以连接其他的客户端. TCP 套接字的参数理解在写服务端代码的时候,发现绑定的地方的 ip 我用了空的字符串,这表示是绑定到本机的,也可以用127.0.0.1来代替,然后还有一个参数为 listen, 里面填的5. 在启动一个服务端时,服务端就会进入 LISTEN 状态,表示监听客户端的连接,那么这个5就表示可以监听5个连接,在套接字里面有个名词叫半连接池,就是说启动服务端时,就自动开启一个半连接池,当客户端连接服务端的时候,表示一个半连接进入半连接池了,然后操作系统就从半连接池取出这个连接,开始处理这个连接,那么后来的连接也是放进这个半连接池里,因为填的5,所以加上服务端处理的那个,一共可以连接6个(处理一个),那么之后的客户端连接都会被服务端拒绝连接,只有等之前处理的或者是半连接池里的少了一个才可以连接上服务端. 那么这个半连接发生在 TCP 三次握手的第几次握手呢?发生在客户端 connect 的时候,也就是第一次握手的时候,第一次握手成功,客户端连接就进入了半连接池,那么等服务端 accept 的时候,就说明三次握手连接成功. 目前我们实现了一个不太完美的 C/S 程序,那么有什么办法可以让服务端既可以连接多个客户端,又可以同时为它们服务呢?答案是让连接循环和通信循环放在两个 py 文件里面. 模拟 SSH 实现远程执行命令结合之前学习的模块 subprocess, 可以执行传过来的命令参数,在命令行中.那么我们使用客户端传送命令,在服务端运行 subprocess 执行命令,并把得到的结果传过去. 服务端 1234567891011121314151617181920212223242526from socket import *import subprocessserverSock = socket(AF_INET, SOCK_STREAM)serverSock.bind(('', 8085))server.listen(5)while True: conn, addr = serverSock.accept() while True: try: cmd = conn.recv(1024) if len(cmd): break obj = subprocess.Popen(cmd.decode('utf-8'), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) stdout = obj.stdout.read() stderr = obj.stderr.read() print(len(stdout) + len(stderr)) conn.send(stdout+stderr) except ConnectionResetError: break conn.close()serverSock.close() 客户端 123456789101112131415from socket import *clientSock = socket(AF_INET, SOCK_STREAM)clientSock.connect(('', 8085))while True: cmd = input('&gt;&gt;&gt;').strip() if len(cmd) == 0: continue client.send(cmd.encode('utf-8')) client.send(cdm.encode(;utf-8)) cmd_res = clientSock.recv(1024) print(cmd_res.decode('utf-8'))clientSock.close() 结果表明当服务端发送的数据大于1024时,客户端一次收取数据量会收不完整,那么当你下次发送命令的时候,服务端回过来的数据会和上次未收完的数据粘在一起,这是一种粘包情况. 有时候命名关闭服务端了,重启服务端是会出现这种问题是因为当TCP主动关闭连接一方将继续等待一定时间,这是 TCP 连接状态中的 TIME_WAIT 状态,该状态的作用是用来重发可能丢失的 ACK 报文,其二当一个服务器断开连接时,该端口可能还会重复使用,那么该端口就不能被其他的应用使用. Nagle 算法1 Nagle 算法规则 当客户端连续发送时间间隔很短的两个数据包时,因为 TCP 协议为了优化传输效率和较少资源浪费,内部使用一种Nagle 的算法.Nagle 算法通常会在 TCP 程序里添加两行代码,在未确认数据发送的时候让发送器把数据送到系统缓存里.任何数据随后继续直到得到明显的数据确认或者直到攒到了一定数量的数据了再发包. TCP/IP 协议中,无论发送多少数据,总是要在数据前面加上协议头,同时,对方收到数据,也需要发送 ACK 表示确认.为了尽可能的利用网络带宽, TCP 总是希望尽可能的发送足够大的数据.(一个连接会设置 MSS 参数,因此, TCP/IP 希望每次都能以 MSS 尺寸的数据块来发送数据).Nagle 算法就是为了尽可能发送大块数据,避免网络中充斥着许多小数据块. Nagle 算法的基本定义时任意时刻,最多只能有一个未被确认的小段.所谓小段,指的是小于 MSS 尺寸的数据块,所谓未被确认,是指一个数据块发出后,没有收到对方的 ACK 确认数据已被收到. Nagle 算法的规则: 如果包长度达到 MSS, 则允许发送; 如果该包含有 FIN, 则允许发送; 设置了 TCP_NODELAY 选项,则允许发送; 未设置 TCP_CORK 选项时,如所有发出去的小数据包(包长度小于 MSS)均被确认,则允许发送; 上述条件都未满足,但发生了超时(一般为200ms),则立即发送. Nagle 算法只允许一个未被 ACK确认的包存在于网络,它并不管包的大小,因此它事实上就是一个扩展的停-等协议,只不过它是基于包停-等的,而不是基于字节停-等的. Nagle 算法完全由 TCP 协议的 ACK 机制决定,这会带来一些问题,比如如果对端 ACK 回复很快的话, Nagle 事实上不会拼接太多的数据包,虽然避免了网络拥塞,网络总体的利用率依然很低. Nagle 算法是 silly window syndrome(SWS)预防算法的一个半集.SWS 算法预防发送少量的数据, Nagle 算法是其在发送方的实现,而接收方要做的是不要通告缓冲空间的很小增长,不通知小窗口,除非缓冲区空间有显著地增长.这里显著地增长定义为完全大小的段( MSS)或增长到大于最大窗口的一半. 注意：BSD的实现是允许在空闲链接上发送大的写操作剩下的最后的小段，也就是说，当超过1个MSS数据发送时，内核先依次发送完n个MSS的数据包，然后再发送尾部的小数据包，其间不再延时等待。（假设网络不阻塞且接收窗口足够大） 举个例子，client端调用socket的write操作将一个int型数据（称为A块）写入到网络中，由于此时连接是空闲的（也就是说还没有未被确认的小段），因此这个int型数据会被马上发送到server端，接着，client端又调用write操作写入‘\r\n’（简称B块），这个时候，A块的ACK没有返回，所以可以认为已经存在了一个未被确认的小段，所以B块没有立即被发送，一直等待A块的ACK收到（大概40ms之后），B块才被发送。 这里还隐藏了一个问题，就是A块数据的ACK为什么40ms之后才收到？这是因为TCP/IP中不仅仅有nagle算法，还有一个TCP确认延迟机制 。当Server端收到数据之后，它并不会马上向client端发送ACK，而是会将ACK的发送延迟一段时间（假设为t），它希望在t时间内server端会向client端发送应答数据，这样ACK就能够和应答数据一起发送，就像是应答数据捎带着ACK过去。在我之前的时间中，t大概就是40ms。这就解释了为什么’\r\n’（B块）总是在A块之后40ms才发出。 当然，TCP确认延迟40ms并不是一直不变的，TCP连接的延迟确认时间一般初始化为最小值40ms，随后根据连接的重传超时时间（RTO）、上次收到数据包与本次接收数据包的时间间隔等参数进行不断调整。另外可以通过设置TCP_QUICKACK选项来取消确认延迟。 2. TCP_NODELAY 选项 默认情况下，发送数据采用Nagle 算法。这样虽然提高了网络吞吐量，但是实时性却降低了，在一些交互性很强的应用程序来说是不允许的，使用TCP_NODELAY选项可以禁止Nagle 算法。 此时，应用程序向内核递交的每个数据包都会立即发送出去。需要注意的是，虽然禁止了Nagle 算法，但网络的传输仍然受到TCP确认延迟机制的影响。 3. TCP_CORK 选项 所谓的CORK就是塞子的意思，形象地理解就是用CORK将连接塞住，使得数据先不发出去，等到拔去塞子后再发出去。设置该选项后，内核会尽力把小数据包拼接成一个大的数据包（一个MTU）再发送出去，当然若一定时间后（一般为200ms，该值尚待确认），内核仍然没有组合成一个MTU时也必须发送现有的数据（不可能让数据一直等待吧）。 然而，TCP_CORK的实现可能并不像你想象的那么完美，CORK并不会将连接完全塞住。内核其实并不知道应用层到底什么时候会发送第二批数据用于和第一批数据拼接以达到MTU的大小，因此内核会给出一个时间限制，在该时间内没有拼接成一个大包（努力接近MTU）的话，内核就会无条件发送。也就是说若应用层程序发送小包数据的间隔不够短时，TCP_CORK就没有一点作用，反而失去了数据的实时性（每个小包数据都会延时一定时间再发送）。 4. Nagle算法与 CORK算法区别 Nagle算法和CORK算法非常类似，但是它们的着眼点不一样，Nagle算法主要避免网络因为太多的小包（协议头的比例非常之大）而拥塞，而CORK算法则是为了提高网络的利用率，使得总体上协议头占用的比例尽可能的小。如此看来这二者在避免发送小包上是一致的，在用户控制的层面上，Nagle算法完全不受用户socket的控制，你只能简单的设置TCP_NODELAY而禁用它，CORK算法同样也是通过设置或者清除TCP_CORK使能或者禁用之，然而Nagle算法关心的是网络拥塞问题，只要所有的ACK回来则发包，而CORK算法却可以关心内容，在前后数据包发送间隔很短的前提下（很重要，否则内核会帮你将分散的包发出），即使你是分散发送多个小数据包，你也可以通过使能CORK算法将这些内容拼接在一个包内，如果此时用Nagle算法的话，则可能做不到这一点。 TCP 粘包问题在上面的 TCP 服务端和客户端收数据的时候填的都是1024字节,表示一次从操作系统的缓存区域收取最大1024字节的数据,当一次发送数据量小于1924字节的时候每次都可以把数据收取干净,这当然是没问题的,但是如果数据量大于1024呢?会发生什么现象.会发生粘包, 上述代码显示了第一中粘包情况,就是一方收取的数据量小于缓存中的数据量,造成粘包,另外一种是由于 Nagle算法导致的,当客户端连续发送两个数据量较小的包时,算法会将这两个一起发送造成粘包. 第二种粘包例子: 1234567891011121314151617181920212223# 服务端from socket import *import subprocessserverSock = socket(AF_INET, SOCK_STREAM)serverSock.bind(('', 8086))serverSock.listen(5)conn, addr = serverSock.accept()data1 = conn.recv(5)print('第一次收:', data1)data2 = conn.recv(5)print('第二次收:', data2)data3 = conn.recv(10)print('第三次收:', data3)data4 = conn.recv(5)print('第四次收:', data4)# 粘包问题是 tcp 协议流式传输数据的方式导致的# 如何解决粘包问题:接收端能够精确地收干净每个数据包没有任何残留 1234567891011# 客户端from socket import *clientSock = socket(AF_INET, SOCK_STREAM)clientSock.connect(('', 8086))# tcp 协议会将数据量较小且发送时间间隔的数据合并成一个包发送clientSock.send(b'hello')clientSock.send(b'world')clientSock.send(b'musibii')clientSock.send(b'1') 12345# 运行结果第一次收: b'hello'第二次收: b'world'第三次收: b'musibii1'第四次收: b'' 可以看出当两次发包间隔时间较短且数据量较少时,会当成一个包发送出去. 那么怎么解决粘包问题呢? 一是因为数据量太大收取不完全导致的,二是因为两次发包间隔时间较短且数据量较小导致的,导致收取的一方将两次数据一次性收取完成. 解决办法一还是以模拟 ssh 远程执行命令的代码作为例子: 首先根本原因是收取的一方不知道到底应该收取多少数据量导致的,那么我们在每次发包之前将数据的长度发过去,然后在发送真实数据,接收端先接收到真实数据的长度大小,然后依据真实数据长度大小来收包不就完美解决了吗. 看实例: 服务端 123456789101112131415161718192021222324252627282930313233from socket import *import subprocessimport struct # 该模块专门用来处理字节的数据类型serverSock = socket(AF_INET, SOCK_STREAM)serverSock.bind(('', 8088))serverSock.listen(5)while True: conn, addr = serverSock.accept() while True: try: cmd = conn.recv(1024) if len(cmd) == 0: break obj = subprocess.Popen(cmd.decode('utf-8'), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) stdout = obj.stdout.read() stderr = obj.stderr.read() print(len(stdout) + len(stderr)) data_len = len(stdout) + len(stderr) # 1. 先制作固定长度的报头 header = struct.pack('i', data_len) # i表示转 int 型 # 2. 发送报头 conn.send(header) # 3. 发送真实数据 conn.send(stdout) conn.send(stderr) except ConnectionResetError: break conn.close()serverSock.close() 客户端 1234567891011121314151617181920212223from socket import *import structclientSock = socket(AF_INET, SOCK_STREAM)clientSock.connect(('', 8088))while True: cmd = input('&gt;&gt;&gt;').strip() if len(cmd) == 0: continue clientSock.send(cmd.encode('utf-8')) # 1. 先收报头,从报头里解出真实数据长度 header = clientSock.recv(1024) total_size = struct.unpack('i', header)[0] # 2. 接收真实数据 cmd_res = b'' recv_size = 0 while recv_size &lt; total_size: data = clientSock.recv(1024) recv_size += len(data) cmd_res += data print(cmd_res.decode('utf-8'))clientSock.close() 可以看出来,数据可以收干净了,所以目前来讲是不存在粘包问题的,但是问题又来了,在实际应用中,想要传输的数据如果很大怎么办?这种办法也可以行得通吗? 当我把要传输的数据大小调大时: 123# demoimport structdata_len = struct.pack('1', 1111111111111111111) 运行结果 这说明 struct 转化 int 类型的时候是有大小限制的,数字太大的转不了,那么 struct 还有一个类型表示长整形的为 q, 来试试看. 123# demoimport structdata_len = struct.pack('q', 11111111111) 运行结果 可以看出来是可以转的,转成了8个字节,那么如果数字在大一点呢,总归有一个不能转的数字,那么这就不是最好的解决办法. 解决办法二我们只想接收端接收到真实的数据长度就可以了,那么可不可以用一个容器把真实数据长度保存然后通过转化传输出去呢. 这就是在自己开发一款 C/S 程序时需要考虑的问题了,涉及到数据传输的话就需要自定义报头了.报头就是可以将真实数据的一些信息保存起来,先于真实数据发送出去 自定义报头 123456789101112131415import structimport jsonheader_dic = &#123; 'filename': 'musibii.jpg', 'md5': '165069c8f668edb6b48f208f7a5c6a00', 'total_size': 11111111111111111111111111111111111111&#125;header_json = json.dumps(header_dic)header_bytes = header_json.encode('utf-8')print(len(header_bytes), header_bytes)data_bytes_len = struct.pack('i', len(header_bytes))print(data_bytes_len,len(data_bytes_len)) 运行结果 可以看出来,通过这种方法可以把数据量很大的东西发送给客户端. 具体解决办法 服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445from socket import *import json,structserverSock = socket(AF_INET, SOCK_STREAM)serverSock.bind(('', 9090))serverSock.listen(5)while True: conn, addr = serverSock.accept() while True: try: data = conn.recv(1024) if len(data) == 0: break obj = subprocess.Popen(data.decode('utf-8'), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) stdout = obj.stdout.read() stderr = obj.stderr.read() data_bytes_len = len(stdout) + len(stderr) # 1. 先制作报头 header_dic = &#123; 'filename': 'musibii.jpg', 'md5': '165069c8f668edb6b48f208f7a5c6a00', 'total_size': data_bytes_len &#125; header_json = json.dumps(header_dic) header_bytes = header_json.encode('utf-8') # 2. 先发送4个 bytes 的字典转化后的字节 conn.send(struct.pack('i', len(header_bytes))) # 3. 发送完整报头 conn.send(header_bytes) # 4. 发送真实数据 conn.send(stdout) conn.send(stderr) except ConnectionResetError as e: print(e) break conn.close()serverSock.close() 客户端 12345678910111213141516171819202122232425262728293031323334from socket import *import struct,jsonclientSock = socket(AF_INET, SOCK_STREAM)clientSock.connect(('', 9090))while True: cmd = input('&gt;&gt;&gt;').strip() if len(cmd) == 0: continue clientSock.send(cmd.encode('utf-8')) # 1. 先收4bytes 的服务端发过来的转化报头 header_size = struct.unpack('i', clientSock.recv(4))[0] # 2. 接收完整的报头,就是 header_dic header_bytes = clientSock.recv(header_size) # 3. 转化得到完整的报头字典 header_json = header_bytes.decode('utf-8') header_dic = json.loads(header_json) # 4. 根据 key 得到真实数据长度 total_size = header_dic['total_size'] # 5. 接受真正的数据 cmd_res = b'' recv_size = 0 while recv_size &lt; total_size: data = clientSock.recv(1024) recv_size += len(data) cmd_res += data print(cmd_res.decode('utf-8'))clientSock.close() 这个程序就加了两个步骤,在发送真实数据之前发送了4个字节的报头,然后发送了真是的报头数据. 首先在服务端定义报头(字典类型),由字典转为 json 格式,由 json 格式转为二进制,由 struct 转成四个字节的数据,客户端收到4个字节struct 转化的数据, unpack 成二进制, decode 为 json 格式的数据类型,然后反序列化成 python 字典类型,得到里面的真实数据长度.然后服务端发送真实数据,客户端循环接收真实数据. 到此,就完美的解决了粘包的问题.如有不对的地方,欢迎指正.]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程（三）]]></title>
    <url>%2F2018%2F11%2F07%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[在之前两篇文章我们已经大概了解了互联网的工作原理,知道了一个数据包的诞生与结束中间经历的过程,那么在这篇博客我们将了解一个稳定可靠地 TCP 连接是怎么产生的,它的数据传送有什么优点和缺点? 该博客将重点介绍 传输层的 TCP 协议建立连接和断开连接的过程. UDP 因为不是可靠的连接所以就不重点介绍了. 介绍在传输层通常遵循的协议为 TCP 和 UDP协议,并且是基于端口运行的,但是两者为应用层提供不同的服务. TCP 提供的是一种稳定,可靠地字节流服务. 面向连接意味着两个使用 TCP 的应用在数据传送之前需要建立 TCP 连接.这一过程可以理解为打电话,先拨号,等待接通,然后稳定的通信. 那么 UDP 是无连接,不可靠的数据包服务,因为无连接,所以可能会产生丢包,但是效率却较高,因为不用对方发送确认包,所以 UDP 广泛应用与游戏,直播等软件. TCP 报文格式在网络编程(二)中已经知道 TCP是基于端口发送数据包的,所以会记录本机端口号和目的端口号,具体格式如下: 上图有几个重要的字段需要了解: 序 列号: seq 序号,占32位,用来标识从 TCP 源端向目的端发送的字节流,发送方的发送数据时对比进行标记; 确认号: ACK 序号,占32位,只有 ACK 标志位位1时,确认号字段才有效, ack=seq+1; 标志位:共6个,即 URG,ACK,PSH,RST,SYN,FIN 等,具体含义如下: URG: 紧急指针有效; ACK: 确认序号有效; PSH: 接收方应该尽快将报文交给应用层; RST: 重置连接; SYN: 发起一个新连接 FIN: 释放一个连接. 两个号码 Sequene number: 顺序号码 Acknowledge number: 确认号码 注意: 不要将确认序号 Ack 与标志位中的 ACK 搞混了; 确认方 ack=seq+1(不论哪方发送),两端才建立连接. 三次握手详解所谓的三次握手( Three-Way Handshake)即建立 TCP 连接,就是指建立一个 TCP 连接时,需要客户端和服务端发送三个包用来确认连接的建立.在套接字编程中,这一过程由客户端执行 connect 来主动触发,整个流程如下: 三次握手 第一次握手: 客户端发送 SYN 包( seq=x)的数据包到服务器,并进入 SYN_SEND 状态,等待服务器确认; 第二次握手: 服务器收到 SYN 包,必须确认客户端的 SYN(ACK=x+1),同时自己也发送一个 SYN 包(seq=y),即 SYN+ACK 包,此时服务器进入 SYN_RCVD 状态; 第三次握手: 客户端收到服务器的 SYN+ACK 包,向服务器发送确认包 ACK(ACK=y+1),此包发送完毕,客户端和服务端都进入 ESTABLISHED 状态,完成三次握手. 注意 握手过程传送的包不包含任何数据,三次握手完毕后,客户端与服务器才正式开始传送数据.理想状态下, TCP 连接建立.在通信双方中的任何一方主动关闭连接之前, TCP 连接都将被一直保持下去.(双方都可以主动断开连接) 四次挥手详解在建立 TCP 连接之后,客户端和服务端开始传输数据,因为这是双向连接,所以任一方都可以主动断开连接. 四次挥手 第一次挥手: 主动关闭方发送一个 FIN, 用来关闭主动方到被动方的数据传送,也就是主动关闭方告诉被动关闭方:我的数据传输已经完成了,不会再给你发送数据了(当然,在 FIN 包之前发送出去的数据,如果没有收到对应的 ACK 确认报文,主动关闭方依然会重发这些数据),但是此时主动关闭方还可以接收数据. 第二次挥手: 被动关闭方收到 FIN 包后,发送一个 ACK 给对方,确认序号为收到序号+1(与 SYN 相同,一个 FIN 占用一个序号). 第三次挥手: 被动关闭方发送一个 FIN, 用来关闭被动关闭方到主动关闭方的数据传送,也就是告诉主动关闭方,我的数据也发送完成,不会再给你发送数据了(但是在 FIN 发送之前发送的数据仍然需要主动关闭方发送确认包). 第四次挥手: 主动关闭方收到 FIn 后,发送一个 ACK 给被动关闭方,确认序号为收到序号+1,至此,完成四次挥手. TCP 状态转换图 CLOSED: 表示初始状态 LISTEN(服务器): 表示服务器的某个套接字处于坚挺状态,可以接受客户端的连接 YN_RCVD(服务器): 这个状态表示服务器接收到了客户端的 SYN 报文,在正常情况下,这个状态是服务端的 SOCKET 在建立 TCP 连接时的三次握手会话过程中的一个中间状态,很短暂,基本上用 netstat 是很难看到这种状态的,因此这种状态时,当收到客户端的 ACK 报文后,他会进入 ESTABLISHED 状态 SYN_SENT: 这个状态与 SYN_RCVD 相对应,当客户端SOCKET 执行 CONNECT 连接时,它首先发送 SYN 报文,因此也随机会进入 SYN_SENT, 并等待服务端发送三次连接中的第二个报文. SYN_SENT 表示客户端已发送 SYN 请求连接报文. ESTABLISHED: 表示连接已经建立 FIN_WAIT_1: 其实 FIN_WAIT_1和 FIN_WAIT_1状态的真正含义都是表示等待对方的 FIN 报文.而这两种状态的区别是: FIN_WAIT_1状态实际上是当SOCKET 在 ESTABLISHED 状态时,它想主动关闭连接,向对方发送了 FIN 报文,此时该 SOCKET 即进入到 FIN_WAIT_1状态.而当对方回应ACK 报文后,则进入到 FIN_WAIT_2状态,当然在实际的正常情况下,无论对方在何种情况,都应该回应 ACK 报文,所以 FIN_WAIT_1状态一般是不容易见到的,而 FIN_WAIT_2可以用 netstat 看到 FIN_WAIT_2: 实际上 FIN_WAIT_2状态下的 SOCKET, 表示半连接,也即有一方要求 CLOSE 连接,但另外还告诉对方,我暂时还有点数据需要传送,等会再关闭连接 TIME_WAIT: 表示收到了对方的 FIN 报文,并发送了 ACK 报文,就等2MSL 后即可回到 CLOSED 可用状态了(初始状态).如果 FIN_WAIT_1状态下,收到了对方同时带 FIN标志和 ACK 标志的报文时,可以直接进入到 TIME_WAIT 状态,而无需经过 FIN_WAIT_2状态 注意: MSL( 最大分段生存期)指明 TCP 报文在 internet 上最长生存时间,每个具体的 TCP 实现都必须选择一个确定的 MSL 值. RFC1122建议为2分钟,但 BSD 传统实现了采用30秒. TIME_WAIT 状态最大保持时间是2*MSL, 也就是1-4分钟. 结论: 在 TIME_WAIT 下等待2MSL, 只是为了尽最大努力保证四次握手正常关闭.确保老的报文段在网络中消失,不会影响新建立的连接. CLOSING: 这种状态比较特殊,实际情况中很少见.正常情况下,当你发送 FIN 报文后,按理来说应该先收到(或同时受到)对方的 ACK 报文,再收到对方的 FIN 报文.但是 CLOSING 状态表示你发送 FIN 报文后,并没有收到对方的 ACK报文,反而收到了对方的 FIN 报文.那么什么情况下会出现这种情况.那就是双方几乎在同时 close 一个 SOCKET 的时候,那么久出现了双方同时发送 FIN 报文的情况,也即会出现 CLOSING 状态,表示双方都正在关闭 SOCKET 连接. CLOSE_WAIT: 这种状态的含义其实是在表示等待关闭.当对方 close 一个 SOCKET 后发送 FIN 报文给自己,系统毫无疑问会回应一个 ACK 报文给对方,此时则进入 CLOSE_WAIT 状态.接下来就需要考虑是否还有数据需要发送给对方,如果没有的话,那么就可以 close 这个 SOCKET, 发送 FIN 报文给对方,也即关闭连接.所以在 CLOSE_WAIT 状态下,需要等待你去关闭连接 LAST_ACK: 它是被动关闭一方在发送 FIN 报文后,最后等待对方的 ACK 报文.当收到 ACK 报文后,也即可以进入到 CLOSED可用状态.( 初始状态) 补充: 默认情况下,当调用 close 时,如果发送缓冲中还有数据, TCP 会继续把数据发送完; 发送了 FIN 只是表示这端不能继续发送数据(应用层不能调用 send 发送),但是仍然可以接收数据; 应用层如何知道对端关闭?通常,在最简单的阻塞模型中,当你调用 recv 时,如果返回0,则表示对端关闭.在这个时候通常的做法就是也调用close, 那么会发送 FIN, 完成四次握手.如果不调用 close, 那么对端就会处于 FIN_WAIT_2状态,而本端则会处于 CLOSE_WAIT状态. 很多时候, TCP 连接的断开都是有 TCP 层自动进行,例如使用 CTRL_C 终止程序, TCP 连接依然会正常关闭. 问题: 为什么建立连接协议是三次握手,而关闭连接是四次挥手呢? 这是因为服务端的 LISTEN 状态下的 SOCKET 收到 SYN 的请求连接时,可以把 ACK和 SYN(ACK起应答作用,而 SYN 起同步作用)放在一个报文里一起发送.但是关闭连接时,当收到对方的 FIN 报文通知时,它仅仅表示对方没有数据发送了,但是另一方未必所有的数据 都全部发送完全了,所以可能不会立马关闭 SOCKET, 也即你可能还需要发送一些数据给对方之后,再发送 FIN 报文给对方表示你同意现在关闭连接了,所以这里的 ACK 报文和 FIN 报文是分开发送的. 为什么不能用两次握手进行连接? 在三次握手中,总共需要完成两个重要的功能,既要双方做好发送数据的准备工作(双方都知道彼此已经准备好),也要允许双方就初始序列号进行协商,这个序列号在握手过程中被发送和确认. 现在把三次握手改成仅需要两次握手,是可能会发生死锁的.考虑计算机客户端和服务端之间的通信,假定客户端给服务端发送一个连接请求分组,服务端收到了这个分组,并发送了确认应答分组.按照两次握手的协定,服务端认为链接已经成功的建立了,可以开始发送数据分组.可是,客户端在服务端的应答分组在传输中被丢失的情况下,将不会知道服务端是否已准备好,不知道服务端建立什么样的序列号,客户端甚至会怀疑服务端是否收到自己的连接请求分组.在这种情况下,客户端认为连接还未建立成功,将忽略服务端发来的任何数据分组,只等待连接确认应答分组.而服务端在发出的数据分组超时后,重复发送同样的数据分组,就形成了死锁. 为什么 TIME_WAIT 状态需要等2MSL 后才能返回到 CLOSED 状态? 什么是 MSL? MSL 即Maximum Segment Lifetime, 也就是报文最大生存时间.’MSL 是任何报文段被丢弃前在网络内的最长时间.’那么,2MSL 也就是这个时间的两倍,当 TCP 连接完成四个报文段的交换时,主动关闭的一方将继续等待一定时间(2-4)分钟,即使两端的应用程序结束. 为什么需要2MSL 呢. 第一,虽然双方都同意关闭连接了,而且握手的四个报文也都协调和发送完毕,按理可以直接回到 CLOSED 状态(就好比从 SYN_SEND 状态到 ESTABLISH 状态那样);但是因为对方处于 LAST_ACK 状态下的 SOCKET 可能会因为超时未收到 ACK 报文,而重发 FIN 报文,所以这个 TIME_WAIT 状态的作用就是用来重发可能丢失的 ACK 报文. 第二,报文可能会被混淆,意思是说其他时候的连接可能会被当做本次的连接. 当某个连接的一端处于 TIME_WAIT 状态时,该连接将不能再被使用.事实上,对于我们比较有现实意义的是,这个端口将不能再被使用.某个端口处于 TIME_WAIT(其实应该是这个连接) 状态时,这意味着这个 TCP 连接并没有断开(完全断开),那么.如果你 bind 这个端口,就会失败.对于服务器而言,如果服务器突然 crash 掉了,那么他将无法在2MSL 内重新启动,因为 bind 会失败.解决这个问题的一个方法就是设置 SOCKET 的 SO_REUSEADDR 选项.这个选项意味着可以重用一个地址. 当建立一个 TCP 连接时,服务端会继续用原有端口监听,同时用这个端口与客户端通信.而客户端默认情况下会使用一个随机端口与服务端的监听端口通信.有时候,为了服务端的安全性,我们需要对客户端进行验证,即限定某个 IP 的某个特定端口的客户端.客户端可以使用 bind 来使用特定的端口.对于服务端,当设置了 SO_REUSEADDR 选项时,它可以在2MSL 内启动并 listen成功.但是对于客户端,当使用 bind 并设置 SO_REUSEADDR 时,如果在2MSL 内启动,虽然 bind 会成功,但是在 windows 平台上 connect 会失败.而在 linux 是哪个不存在这个问题. 要解决 windows 平台的问题,可以设置 SO_LISTEN 选项. SO_LINGER 选项决定调用 close 时 TCP 的行为. SO_LINGER 涉及到 linger 结构体,如果设置结构体中 l_onoff 为非0,l_linger 为0,那么调用 close 时 TCP 连接会立刻断开, TCP 不会将发送缓冲中未发送的数据发送,而是立即发送一个 RST 报文给对方,这个时候 TCP 连接(关闭时)就不会进入 TIME_WAIT 状态.这样做虽然解决了问题,但是并不安全.通过以上方式设置 SO_LINGER 状态,等同于设置 SO_DONTLINGER 状态. 当 TCP 连接发生一些物理上的意外情况时,例如网线断开, linux 上的 TCP 实现会依然认为该连接有效,而 windows 则会在一定时间后返回错误信息.]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程（二）]]></title>
    <url>%2F2018%2F11%2F06%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[六 网络编程(一)总结首先对网络编程(一)做个总结:我们现在知道互联网通信其实就是发送数据包与接收数据包.电脑 A 向电脑 B 发送一个数据包, B 收到然后回复一个数据包,才实现了电脑之间的通信.数据包的结构,基本是下图的形式: 想要发送这个数据包需要知道两个地址: 对方的 MAC 地址 对方的 IP 地址 只有发送方知道这两个地址,数据包才可以准确的发送到接收方.之前已经了解,单纯的 MAC 地址是有局限性的,就是只能在一个局域网内通过MAC 地址通信,如果两台计算机不在一个局域网,那么只能发送给网关( gateway),由网关走路由协议发送给对方. 上图中,1号狄电脑想要个4号电脑通信.首先需要知道对方电脑的 IP 和子网掩码,然后通过 ARP 协议计算出自己和对方的网络号,然后判断是否处于同一个局域网,不是的话,1号电脑将数据包发给网关 A. 网关 A 通过路由协议,发现4号电脑位于网络 B, 又把数据包发给网关 B, 网关 B 再转发给4号电脑. 1号电脑想要把数据包发给网关 A, 首先必须知道网关 A 的 MAC 地址.所以,数据包的目标地址,实际上分为两种情况: 场景 数据报地址 同一个局域网 对方的 MAC 地址,对方的 IP 地址 非同一个局域网 网关的 MAC 地址,对方的 IP 地址 发送数据包之前,电脑必须判断对方与自己是否处于同一个局域网,然后选择相应的处理方式来发送数据包. 四 首次联网相关设置一 静态IP 设置当我们购买了一台新电脑时,插上网线,开机,这时候电脑能够上网吗?说到这想到我大二干的一件蠢事,那时候不知道路由器的工作原理,以为买了路由器就可以连无线网上网了,然后兴冲冲在网上买了一个路由器,收到货之后插上电,插上网线,发现 WiFi 倒是出现了,可是连上却没有反应,然后我就想啊,不对啊怎么连不上网?之后我想明白了,我 TM 的根本就没装宽带,哪来的网.好在那个路由器也没闲着,终于在去年服役了… 当购买的新电脑连上网线时,通常需要做一些设置,一般现在都会自动设置 IP, 子网掩码 DNS 服务器啦,但是也有有手动设置的,一般会设置四个参数: 本机 IP 地址 子网掩码 网关 IP 地址 DNS IP 地址 看看 linux 系统的设置 这四个参数缺一不可,由于这是给定的,计算机每次开机都会分到同样的 IP 地址,所以这种情况称为静态 IP 地址上网. 但是这样的设置比较专业,而且不够灵活.所以大多数用户使用动态 IP 地址上网. 二 动态 IP 地址上网所谓动态 IP 地址,值得是计算机开机后,会由服务器自动分配一个 IP 地址,不需要人为设置.使用的协议为 动态主机设置协议(Dynamic Host Configuration Protocol，DHCP) 协议,是一个局域网的网络协议,使用 UDP协议工作,主要有两个用途: 用于内部网或网络服务供应商自动分配 IP 地址给用户; 用于内部网管理员作为对所有计算机作中央管理的手段. 这个协议规定,每一个局域网中,有一台计算机负责管理本网络的所有 IP 地址,它叫做DHCP 服务器.新的计算机加入网络,首先必须向 DHCP 服务器发送一个 DHCP 请求数据包,申请 IP 地址和相关的网络参数. 前面说过,如果两台计算机在同一个局域网,必须知道对方的 MAC 地址和 IP 地址,才能发送数据包.但是新加入的计算机并不知道这两个地址,怎么发送数据包呢?这就是 DHCP 的功劳了. 三 DHCP 协议首先, DHCP 是应用层协议,建立在 UDP 之上的,数据包是这样的: 最前面的以太网标头,设置发送方(本机)的 MAC 地址和接收方( DHCP)的 MAC 地址.前着就是本机网卡的 MAC 地址,后者这时候并不知道,就填入一个广播地址:FF-FF-FF-FF-FF-FF.这个地址是具有特殊意义的MAC 地址. 后面的 IP 标头,设置发送方的 IP 地址和接收方的 IP地址.这时候,对于这两者,本机都不知道.于是发送方的 IP 地址就设为0.0.0.0,接收方得 IP 地址设为255.255.255.255. 最后的 UDP 标头,设置发送方的端口和接收方的端口.这一部分是 DHCP 协议规定好的,发送方为68端口,接收方为67端口. 数据包内容构造完成后,就可以发包了.以太网是基于广播方式发送的,同一个局域网的每个计算机都会收到这个数据包.因为接收方的 MAC 地址是FF-FF-FF-FF-FF-FF,看不出是发给谁的,所以每台计算机收到数据包后都会进行拆包才能确定是不是发给自己的.当看到发送方 IP 地址为0.0.0.0,接收方是255.255.255.255时, DHCP 服务器知道,哦,原来这个包是发给我的,所以其他的计算机就可以丢弃这个包了. 于是 DHCP 服务器读取数据包内容,分配好 IP 地址,发送一个 DHCP 响应数据包.这个是数据包的结构和上面是类似的,以太网标头的 MAC 地址是双方的网卡地址, IP 标头的 IP 地址是 DHCP 副武器的 IP 地址(发送方)和255.255.255.255(接收方),UDP 标头的端口是67(发送方)和68(接收方),分配给请求端的 IP 地址和本网络的具体参数则包含在 Data 部分. 新加入的计算机收到这个响应包,于是就知道了自己的 IP 地址,子网掩码,网关地址和DNS 服务器地址. 四 小结这是联网的第一步,不管是静态 IP 地址还是动态 IP 地址,想要连上互联网,需要确定这四个参数: 本机 IP 地址 子网掩码 网关 IP 地址 DNS IP 地址 只有这四个参数确定了,才可以愉快的进行网络冲浪.那么当我们访问网页的时候,互联网协议是如何工作的呢? 五 访问网页一 本机参数假定经过上一节的步骤,用户设置好了自己的网络参数: IP 地址:192.168.2.238 子网掩码:255.255.255.0 路由器(网关地址):192.168.2.1 DNS 服务器:192.168.2.1 打开浏览器访问谷歌,在地址栏输入 www.google.com,这意味着,浏览器向 google 发送一个网页请求的数据包. 二 DNS 协议我们知道,向谷歌发送一个数据包,必须要知道对方的 IP 地址.但是现在只知道一个网址,并不知道它的 IP 地址. DNS 协议可以帮助我们,将这个网址转换成 IP 地址,已经知道我们的 DNX 服务器为192.168.2.1,于是向这个地址发送一个 DNS 数据包(53端口). 然后, DNS 服务器作出相应,告诉我们谷歌的地址是174.36.196.242.于是我们知道了对方的 IP 地址. 三 子网掩码接下来需要判断该 IP地址和本机是否处于同一个局域网,这就需要子网掩码来进行 AND 位运算. 已知子网掩码是255.255.255.0,本机用子网掩码和自己的 IP地址192.168.2.238,做一个二进制的 AND 运算,计算结果为192.168.2.0,然后对谷歌的 IP 地址也做一个 AND 运算,计算结果为174.36.196.0.两个结果不相等,所以结论是谷歌与本机不在一个局域网. 因此我们想要和谷歌通信的话需要通过网关转发,网关地址为192.168.2.1,也就是所接收方得 MAC 地址是网关的 MAC 地址. 四 应用层协议浏览网页用的是 HTTP/HTTPS 协议,这两种协议的数据构造差不多: HTTP部分的内容,类似下面这样: 假定这个部分的长度为4960字节,它会被嵌在 TCP 数据包中. 五 TCP 协议TCP 数据包需要设置端口,接收方( Google)的 HTTPS默认是443,发送方(本机)的端口是一个随机生成的1024-65535之间的整数,假定为51775. TCP 数据包的标头长度为20字节,加上嵌入 HTTPS 的数据包,总长度为4980字节. 六 IP 协议然后, TCP 数据包再嵌入 IP 数据包.IP 数据包需要设置双方的 IP地址,这是已知的,发送方是192.168.2.238(本机),接收方为174.36.196.242( Google). IP 数据包的标头长度为20字节,加上嵌入的 TCP 数据包,总长度变为5000字节. 七 以太网协议最后, IP地址数据包嵌入以太网数据包.以太网数据包需要设置双方的 MAC 地址,发送方为本机的网卡 MAC 地址,接收方为网关192.168.2.1的 MAC 地址(通过 ARP 协议获得) 本机的 MAC 地址: 网关的 MAC 地址: 以太网数据包的数据部分,最大长度为1500字节,而现在的 IP 数据包长度为5000字节.因此, IP 数据包必须分割成四个包.因为每个包都有自己的标头(20字节),所以四个包的 IP 数据包的长度分别为1500,1500,1500,560. 八 服务端响应经过多个网关的转发, google 服务器收到了四个以太网数据包. 根据 IP 标头的序号, google 将四个包拼起来,取出完整的 TCP 数据包,然后读取里面的 HTTPS 请求,接着做出 HTTPS 响应,再用 TCP 协议回复一个数据包. 本机收到 HTTPS 响应以后,就可以将网页显示出来,完成以一次网络通信.]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程（一）]]></title>
    <url>%2F2018%2F11%2F02%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一 客户端/服务端架构 硬件 C/S 架构 软件 C/S 架构 互联网处处是 C/S 架构的 如一个网站就是服务端,浏览器是客户端( B/S 架构) 服务端需要遵循的原则: 服务端与客户端都需要有惟一的地址,但是服务端的地址必须固定/绑定 对外一直提供服务,需要稳定运行 服务端需要支持并发 网络 网络建立的目的是为了数据交互(通信) 如何实现通信: 1. 建立好底层的物理连接介质 2. 有一套统一的通信标准,称之为互联网协议 互联网协议:就是计算机界的标准语言 二 七层模型总览互联网的实现,总共可以分为七层.每一层都靠下一层的支持.用户接触的是第七层,也就是应用层.想要理解互联网协议,必须从最下层开始,自下而上理解每一层的功能. OSI 模型可以分为七层,五层,四层,其实都是一个道理,只不过合并了几层而已.从下而上分别为:物理层,数据链路层,网络层,传输层,会话层,表示层,应用层. 每层运行常见的物理设备: 三 tcp/IP 五层模型理解一般讲应用层,表示层,会话层并做应用层,从 tcp/IP 五层协议的角度来阐述每层的由来和功能,搞清楚了每层的主要协议也就理解了互联网通信的原理. 每层都运行特定的协议,越往上越靠近用户,越往下越靠近硬件. 一 物理层物理层也可以称之为实体层.电脑想要互相通信,第一件事先要把电脑连起来,可以用光缆,电缆等方式实现通信.这就叫实体层,它就是把电脑连接起来的物理手段.它主要规定了网络的一些电器特性.它的功能室基于电器特性发送高低电压(电信号),高电压对应数字1,低电压对应数字0. 二 数据链路层物理层单纯的传输电信号0和1没有任何意义,必须规定电信号多少位一组,每组什么意思. 数据链路层的功能:定义了电信号的分组方式,这就是数据链路层的功能,它在物理层的上方,确定了0和1的分组方式. 1 以太网协议早期的时候各个公司都有自己的分组方式,后来形成了统一的标准,即以太网协议 Ethernet. Ethernet 规定 一组电信号构成一个数据包,也叫数据帧 每一组数据帧分成:报头 head 和数据 data 两部分 报头包含数据包的一些说明项,比如发送者的源地址,接受者的源地址以及数据类型等等. 发送者/源地址: 6个字节 接受者/目标地址: 6个字节 数据类型: 6个字节 数据则是数据包的具体内容 数据包最短为46字节,最长为1500字节 所以一个数据帧的长度最短为64字节,最长1518字节,超过最大限制就分片发送. 2 mac 地址head 中包含的源地址和目标地址的由来: Ethernet 规定接入 Internet 的设备都必须具备网卡,发送端和接收端的地址便是指网卡的地址,即MAC 地址. mac 地址:每块网卡出厂时都被烧制上世界上一个惟一的MAC 地址,长度为48位2进制,通常由12位16进制数表示(前六位是厂商编号,后六位是流水线号) 装了好多次虚拟机,我现在也不知道那个是我的了… 3 广播定义MAC 地址只是第一步,在一部电脑第一次接入局域网的时候,是怎么知道它的MAC 地址的呢.在局域网内通信都是通过MAC 地址来发包收包的,只要知道了对方的MAC 地址才可以互相通信.这就要靠ARP(addres resolution protocol) 协议来获取MAC 地址了,那么 arp 协议是如何解析出对方的MAC 地址呢? 这里等到了网络层再来解释. 注意:以太网数据包必须知道接收方的MAC 地址,才能发包. 那么在同一个局域网内,知道了对方的MAC 地址,系统怎样才能把数据包准确送到接收方呢? 以太网采用了一种很’原始’的方式,它并不是直接把数据包发到接收方,而是向局域网内所有的计算机发送,让每台计算机自己拆包后判断自己是否为接收方(前提知道对方MAC 地址) 上图中,1号计算机向2号计算机发送一个数据包,局域网内其他的计算机都会收到这个包.他们读取数据包的报头,找到接收方得MAC 地址,然后与自身的MAC 地址相比较,如果两者相同,就接收这个包,做进一步的处理,不相同的话就丢弃这个数据包.这种发送方式叫’广播’. 有了数据包的定义,网卡的MAC 地址,广播的发送方式,数据链路层就可以在同一局域网内的计算机之间传送数据了. 三 网络层1 网络层的由来以太网协议,依靠MAC 地址发送数据,但这仅仅只能在同一个局域网内发送数据.理论上,依靠MAC 地址,是可以和全球任何一个MAC 地址发送数据的,因为MAC 地址是惟一的.但是这样做有一个致命的缺陷. 以太网依靠广播方式发送数据包,而广播就意味着每个人都要发送一份,那么全球这么多的计算机,在找到对方的MAC 地址之前都要发一份无疑会造成巨大的浪费,而且效率极低,而且局限在发送者的局域网.也就是说,如果两台计算机不在同一个局域网,广播是传不过去的.这种设计是合理的,否则的话互联网上每一台计算机都会收到所有包,那会引起灾难. 互联网可以想象成由无数个局域网组成的一个巨型网络,如果想要跨局域网通信必须找到另一种方式,能够区分哪些MAC 地址属于同一个局域网,哪些不属于同一个局域网.如果是同一个局域网的话,就采用广播发送(如何知道对方的MAC 地址),否则就采用’路由’的方式发送.(‘路由’的意思,就是指如何向不同局域网发送数据包) 这就导致了’网络层’的诞生.它的作用是引进一套新的地址,使得我们能够区分不同的计算机是否属于同一个局域网.这套地址叫做’网络地址’,简称’网址’. 于是,网络层出现以后,每台计算机有了两种地址,一种是MAC 地址,另一种是网络地址.两种地址之间没有任何联系,MAC 地址是绑定到网卡上的,网络地址则是由MAC 服务器分配的,当一台计算机第一次联网时,会向MAC 服务器发送一个包,然后MAC 服务器会分配好网络地址. 网络地址帮助我们确定计算机所在的局域网,MAC 地址则将数据包发送到该局域网中的目标MAC 地址.因此从逻辑上判断,必定是先处理网络地址,然后处理MAC 地址. 可以这样理解,互联网中的通信都是MAC 地址互相发送数据包,而网络地址是为了帮我们确认需要往哪个局域网里面的目标MAC 地址发送数据包,两者缺一不可. 2 IP 协议规定网络地址的协议,叫做 IP 协议.它定义的地址,称为 IP 地址. 目前,广泛采用的是 IP 协议第四版,简称 IPV4.这个版本规定,网络地址由32个二进制位组成. 可以看出我的 IP 地址为192.168.11.95,习惯上,用四段的十进制数表示 IP 地址,从0.0.0.0到255.255.255.255. IP 地址一般分为5类:A,B,C,D,E 类, D 和E 类为其他用途的. 可以看粗来 IP 地址是有限的,而且现在的 IPV4 地址已经分完了,以后使用的就是 IPV6了,据说世界上的每一粒沙子都有一个惟一的 IP 地址. 互联网上的每一台计算机,都会分配到一个 IP 地址.这个地址分为两部分,前一部分代表网络,后一部分代表主机.比如, 我的 IP 地址192.168.11.95,这是一个32位的地址,我的网络部分是前面24位192.168.11,那么主机号就是后8位.处于同一个局域网的电脑,它们 IP 地址的网络部分必定是相通的,也就是说192.168.11.95与192.168.11.49处于同一个局域网. 但是我们单纯从 IP 地址是无法判断网络部分的,我为什么知道我的 IP 地址的网络号?其实没有另外一个地址的话我也不知道的. 那么怎样从 IP 地址来判断计算机是否处于同一个局域网呢?这就是另外一个地址的作用了,也就是子网掩码. 所谓子网掩码,就是表示子网络特征的一个参数.它在形式上等同于 IP 地址,也是一个32位二进制数字,它的网络部分全为1,主机部分全部为0.比如我的 IP192.168.11.95,因为我的网络部分为前24位,那么我的子网掩码就是255.255.255.0. 知道了子网掩码,就可以判断,任意两个 IP 地址是否处于同一个局域网.方法是将两个 IP 地址与子网掩码分别进行 AND 运算(两个数位都为1,则为1,否则为0),然后比较结果是或否相同,如果相同,就表明处在同一个局域网,否则就不是,就需要通过路由协议发送数据包. IP 协议的作用主要有两个:一个是为每一台计算机分配 IP 地址,另一个是和子网掩码结合确定元 IP 与目标 IP 是否处于同一个局域网. 3 IP 数据包根据 IP 协议发送的数据,叫做 IP 数据包,不难想象,其中必定包括 IP 地址信息. 但是前面说过.以太网数据包只包含MAC 地址,并没有 IP 地址的位置.那么是否需要修改数据定义在添加一个位置呢? 我们可以直接把 IP 数据包放进以太网数据包的数据部分,因此完全不用修改以太网的规格.这就是互联网分层结构的好处:上层的变动完全不涉及下层的结构. 具体来说, IP 数据包也分为报头和数据两个部分 报头部分主要包括版本,长度, IP 地址等信息,数据部分则是 IP 数据包的具体内容.它放进以太网数据包后,以太网数据包就拥有了两个报头. IP 数据包的报头部分的长度为20到60个字节,整个数据包的总长度最大为65535字节.因此,理论上,一个 IP 数据包的数据部分,最长为65515字节,前面说过,以太网数据包的数据部分,最长为1500字节.因此,如果 IP 数据包超过了1500字节,它就需要分割成几个以太网数据包,分开发送. 4 ARP 协议从数据链路层和网络层我们知道,想要发送一个数据包,必须知道两个地址,一个是对方的 MAC 地址,另一个是对方的 IP 地址.通常情况下,对方的 IP 地址是已知的,但是不知道对方的 MAC 地址. 所以需要一种机制能够从 IP 地址得到 MAC 地址. 这里可以分为两种情况:第一种情况,如果两台主机不在同一个局域网,那么事实上没办法得到对方的 MAC 地址,只能把数据包传送到两个局域网连接处的网关’ gateway’,让网关去处理. 第二种情况,如果两台主机在同一个局域网,那么可以使用 ARP 协议,得到对方的 MAC 地址. ARP 协议也是发送一个数据包(包含在以太网数据包中),其中包含它索要查询主机的IP 地址,在对方 MAC 地址这个位置,填的是 FF:FF:FF:FF:FF:FF,表示这是一个广播地址.它所在局域网的每一台计算机都会收到这个数据包,从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。 总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。 四 传输层1 传输层的由来有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。 接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？ 也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。 “端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。 “传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。 2 UDP 协议现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。 UDP数据包，也是由”报头”和”数据”两部分组成。 “报头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样： 3 TCP 协议UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。 为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。 因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。 TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 五 应用层应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。 “应用层”的作用，就是规定应用程序的数据格式。 举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。 这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。 至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的.]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[异常处理]]></title>
    <url>%2F2018%2F11%2F01%2F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常之问 什么是异常? 异常就是程序运行时发生错误的信号(在程序出现错误时,则会产生一个异常,若程序没有处理它,则会抛出该异常,程序的运行也随之终止)在Python 中,错误触发的异常如下: Traceback 为异常的追踪信息 NameError 为异常的类型 name ‘a’ is not defined 为异常值 在 Python 中的错误分为两种: 语法错误:这种错误,通过不了 python 的语法检测,这种错误也捕捉不了,必须在程序执行前改正. 逻辑异常:语法没问题,通过了 Python的语法检测,但因为对 python 数据类型的错误使用导致出错. 异常的种类 在 Python 中不同的异常可以用不同的类型( python 中统一了类与类型,类型即类)去标识,一个异常标识一种错误. 常用异常: AttributeError 试图访问一个对象没有的属性 IOError 输入/输出异常;通常为无法打开文件 ImportError 无法引入模块或包;基本上是路径问题或名称错误 IndentationError 语法错误的子类;代码没有正确对其 IndexError 下标索引超出序列边界 KeyError 试图访问字典中不存在的键 KeyboardInterrupt 键盘终止,通常为 Ctrl+C 同时被按下 NameError 使用一个还未被赋予对象的变量 SyntaxError python 代码非法,代码不能编译 TypeError 传入对象类型与要求的不符合 UnboundLocalError 试图访问一个还未被赋值的局部变量,基本是由于另有一个同名的全局变量,导致你以为正在访问它 ValueError 传入一个调用者不期望的值,即使值得类型是正确的 更多异常: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748ArithmeticErrorAssertionErrorAttributeErrorBaseExceptionBufferErrorBytesWarningDeprecationWarningEnvironmentErrorEOFErrorExceptionFloatingPointErrorFutureWarningGeneratorExitImportErrorImportWarningIndentationErrorIndexErrorIOErrorKeyboardInterruptKeyErrorLookupErrorMemoryErrorNameErrorNotImplementedErrorOSErrorOverflowErrorPendingDeprecationWarningReferenceErrorRuntimeErrorRuntimeWarningStandardErrorStopIterationSyntaxErrorSyntaxWarningSystemErrorSystemExitTabErrorTypeErrorUnboundLocalErrorUnicodeDecodeErrorUnicodeEncodeErrorUnicodeErrorUnicodeTranslateErrorUnicodeWarningUserWarningValueErrorWarningZeroDivisionError 异常处理 为了保证程序的健壮性与容错性,即在遇到错误时程序不会崩溃,我们需要对异常进行处理.如果错误发生的条件是可预知的,需要用 if 进行处理:在错误发生之前进行预防;如果错误的发生条件不可预知,则需要用 try…except: 在错误发生之后进行处理. 12345# 基本语法try: 被检测的代码块except 异常类型: try 中一旦检测到异常,就执行这个位置的逻辑 几个栗子: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 异常类只能用来处理指定的异常情况,如果非指定异常则无法处理s1 = 'hello'try: int(s1)except IndexError as e: # 捕获异常失败,报错 print(e) # 多分支s1 = 'hello'try: int(s1)except IndexError as e: print(e)except KeyError as e: print(e)except ValueError as e: print(e)# 万能异常 Exceptions1 = 'hello'try: int(s1)except Exception as e: print(e) # 多分支异常与万能异常# 如果想要的效果是:无论出现什么异常,我们统一丢弃,或者使用同一段代码逻辑去处理它们,那么一个 Exception 就够了.# 如果想要对不同的异常使用不同的处理逻辑,那么就需要用到多分支异常.# 为了防止对异常类型判断错误,可以在多分支后面跟上 Exceptions1 = 'hello'try: int(s1)except IndexError as e: print(e)except KeyError as e: print(e)except ValueError as e: print(e)except Exception as e: print(e) # 异常的其他结构s1 = 'hello'try: int(s1)except IndexError as e: print(e)except KeyError as e: print(e)except ValueError as e: print(e)else: print('没有产生异常则执行')finally: print('无论异常与否,都会执行该代码') # 主动触发异常try: raise TypeError('类型错误')except Exception as e: print(e)# 自定义异常class ExceptionMusibii(BaseException): def __init__(self, msg): self.msg = msg def __str__(self): return self.msg try: raise ExceptionMusibii('类型错误')except ExceptionMusibii as e: print(e)# 断言: assert 条件assert 1 == 1assert 2 == 2# 总结:try...except# 1. 把错误处理和真正的工作分开来;# 2. 代码更易组织,更清晰,复杂的工作任务更容易实现;# 3. 代码更加健壮,不易崩溃. 什么时候用异常处理 只有在错误发生的条件无法预知的情况下才应该加上 try…except]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[热河]]></title>
    <url>%2F2018%2F10%2F31%2F%E7%83%AD%E6%B2%B3%2F</url>
    <content type="text"><![CDATA[《热河》 作词：李志 作曲：李志 热河路就像八十年代的金坛县 梧桐 垃圾 灰尘 和各式各样的杂货店 人们总是早早的离开 拉上卷帘门 在天黑前穿上毛衣 点一根烟 热河路有一家 开了好多年的理发店 不管剪什么样的发型 你只要付五块钱 老板和他的妹妹坐在椅子上 对着镜子一言不发 他们的老家 在身后 在岸边 在安徽全椒县 没有人在热河路谈恋爱 总有人在天亮时伤感 如果年轻时你没来过热河路 那你现在的生活是不是很幸福 纪念碑旁 有一家破旧的电影院 往北走五百米 就是南京火车西站 每天都有外地人 在直线和曲线之间迷路 气喘嘘嘘眼泪模糊 奔跑 跌倒 奔跑 秋林龙虾换了新的地方 32路还是穿过挹江门 高架桥拆了修了新的隧道 走来走去走不出我的盐仓桥 来到城市已经八百九十六天 热河路一直是相同的容颜 偶尔有干净的潘西路过 她不会说 你好再见 没有人在热河路谈恋爱 总有人在天黑时伤感 如果年轻时你来过热河路 那你现在是不是已经被他们淹没 没有新的衣服能让你爱恋 总有一种天气让我怀念 醒来或者吃饱又是一年 相遇然后分别就在一天 没有人在热河路谈恋爱 总有人在天黑时伤感 如果年轻时你来过热河路 那你现在是不是已经被他们淹没 没有新的衣服能让我爱恋 总有一种天气让我怀念 醒来或者吃饱又是一年 相遇然后分别就在一天]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>李志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沧海一声笑]]></title>
    <url>%2F2018%2F10%2F30%2F%E6%B2%A7%E6%B5%B7%E4%B8%80%E5%A3%B0%E7%AC%91%2F</url>
    <content type="text"><![CDATA[《沧海一声笑》 作词：黄霑 作曲：黄霑 沧海笑滔滔两岸潮 浮沉随浪记今朝 苍天笑纷纷世上潮 谁负谁胜出天知晓 江山笑烟雨遥 涛浪淘尽红尘俗事知多少 清风笑竟惹寂寥 豪情还剩了一襟晚照 苍生笑不再寂寥 豪情仍在痴痴笑笑 啦…啦…啦… ​ 记金庸大侠（查良镛） ​ 与夏梦同一天归西 ​ 2018年10月30日]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>None</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 模块与包的导入问题]]></title>
    <url>%2F2018%2F10%2F27%2Fpython-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[类的内置方法]]></title>
    <url>%2F2018%2F10%2F25%2F%E7%B1%BB%E7%9A%84%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[类的内置方法都是继承object基类的,内置方法通常为双下划线的方法,比如__init__方法,而类的内置方法也叫做魔术方法,因为太强大了. 在介绍魔术方法之前先看一些判断对象和类的继承关系的方法: isinstance(obj, A_tuple):判断某个对象是否属于某一个集合类的对象 issubclass(x, A_tuple): 判断某个类是否是某一个集合类的子类 1 __str__方法会在对象被打印的时候自动触发,然后将返回值当做打印的结果 使用例子: 123456789101112class People: de __init__(self, name, age): self.name = name self.age = age def __str__(self): return '&lt;%s : %s&gt;' % (self.name, self.age) peo = People('musibii', 18)print(peo) # print(peo.__str__())# 运行结果&lt;musibii : 18&gt; 2 __del__方法会在对象被删除时自动触发执行,用来在对象被删除前回收资源 使用例子: 123456789101112class Bar: def __init__(self, x, y, filepath): self.x = x self.y = y self.f = open(filepath, 'r', encoding='utf-8') def __del__(self): # 写回收系统资源相关的代码 self.f.close() obj = Bar(10, 20)del obj 未完待续]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过字符串来操作类或对象的属性]]></title>
    <url>%2F2018%2F10%2F25%2F%E9%80%9A%E8%BF%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A5%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%88%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[通过字符串来查看获取修改删除类或对象的属性的使用场景为获取用户的输入,因为得到的值都是字符串类型,那么就可以直接通过字符串来操作属性而不用把字符串修改为可以通过句点法访问的形式了. 那么有四个方法可以通过字符串来操作属性: hasattr:是否具有该属性,返回布尔值 getattr:获取属性值,没有该属性的话会报错,设置一个默认值 None setattr:修改属性值, 有就修改,没有就添加 delattr:删除属性,有就删除,没有会报错,应该加个判断 一 hasattr方法查看源码可知: 1234567def hasattr(*args, **kwargs): # real signature unknown """ Return whether the object has an attribute with the given name. This is done by calling getattr(obj, name) and catching AttributeError. """ pass 翻译过来就是:返回对象是否具有给定名称的属性。这是通过调用getattr函数和捕获AttributeError错误来完成的. 使用例子 1234567class Foo: def __init__(self, name, age): self.name = name self.age = age def tell_info(self): print('%s : %s' % (self.name, self.age)) 123456789# hasattrobj = Foo('musibii', 18)print(hasattr(obj, 'name'))print(hasattr(obj, 'age'))print(hasattr(obj, 'gender'))# 运行结果TrueTrueFalse 二 getattr方法查看源码可知: 123456789def getattr(object, name, default=None): # known special case of getattr """ getattr(object, name[, default]) -&gt; value Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y. When a default argument is given, it is returned when the attribute doesn't exist; without it, an exception is raised in that case. """ pass 实际该方法是调用的传入对象的魔术方法__getattribute__,查看object的源码,从魔术方法__getattribute__的注释发现’’’return getattr(self, name)’’’,当对对象调用getattr方法是,就会触发__getattribute__方法.只有对象具有__getattribute__魔术方法,才可以使用getattr方法,一般来说除非定义类的时候改写了该方法,有不同的结果. 使用例子 12345678# getattrprint(getattr(obj, 'name'))print(getattr(obj, 'age'))print(getattr(obj, 'gender', None)) # 如果没有要获取的属性的话,应该定义默认值,否则会报错# 运行结果musibii18None 三 setattr方法查看源码可知: 1234567def setattr(x, y, v): # real signature unknown; restored from __doc__ """ Sets the named attribute on the given object to the specified value. setattr(x, 'y', v) is equivalent to ``x.y = v'' """ pass 设置所给对象的属性一个给定的值. 和getattr一样,该方法传入的对象需要有__setattr__魔术方法才可以调用getattr方法. 使用例子: 1234567891011# setattrprint(obj.__dict__)setattr(obj, 'name', 'maffia')print(obj.__dict__)setattr(obj, 'gender', 'male')print(obj,__dict__)# 运行结果&#123;'name': 'musibii', 'age': 18&#125;&#123;'name': 'maffia', 'age': 18&#125;&#123;'name': 'maffia', 'age': 18, 'gender': 'male'&#125;# 如果设置的属性对象里面没有的话会新增属性 四 delattr方法查看源码可知: 1234567def delattr(x, y): # real signature unknown; restored from __doc__ """ Deletes the named attribute from the given object. delattr(x, 'y') is equivalent to ``del x.y'' """ pass 从所给对象删除属性. 和getattr一样,该方法传入的对象需要有__delattr__魔术方法才可以调用delattr方法. 使用例子: 12345# delattr# 删除属性的时候,如果没有所给的属性名,那么会报错,所以在使用delattr的时候加上if判断delattr(obj, 'gender')if hasattr(obj, 'xxx'): delattr(obj, 'xxx')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类方法之绑定方法和非绑定方法]]></title>
    <url>%2F2018%2F10%2F25%2F%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B9%8B%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在类中定义的函数总共可以分为两大类: 绑定方法 绑定方法 特殊之处:绑定给谁就应该由谁来调用,谁来调用就会将谁当做第一个参数自动传入 绑定给对象的方法:在类中定义函数没有被任何装饰器装饰的情况下,默认就是绑定对象的. 绑定给类的方法:为类中定义函数添加一个classmethod装饰器,就是绑定给类的. 非绑定方法 特殊之处:非绑定方法就是一个普通函数,既不与类绑定又不与对象绑定,意味着类和对象都可以调用,但是无论谁来调用都是一个普通函数,没有自动传值的效果. 非绑定方法:为类中定义函数添加一个staticmethod装饰器,就是非绑定方法. 类中的绑定方法通常来说是默认给对象是用的,加了classmethod装饰器才是给类使用的,那么这三种方法的使用场景是什么呢? 默认绑定给对象的没什么好说的, 绑定给类的方法:一般用来自动实例化对象(传入某些特殊的配置文件对象), 非绑定方法:非绑定方法不用传入对象,也不用传入类,用在单纯的返回或得到某些值. 123456789101112131415161718192021222324252627282930313233343536373839404142class Foo: def func1(self): print('func1', self) @classmethod def func2(cls): print('func2', cls) @staticmethod def func3(x, y): print('func3', x, y) obj = Foo()# 绑定给对象的方法# 绑定给对象的,应该由对象来调用obj.func1()print(obj)# 运行结果func1 &lt;__main__.Foo object at 0x107e8c6d8&gt;&lt;__main__.Foo object at 0x107e8c6d8&gt;# 绑定给类的方法# 绑定给类的方法应该由类来调用print(Foo.func2)print(obj.func2) # 由对象来调用的结果一样# 运行结果&lt;bound method Foo.func2 of &lt;class '__main__.Foo'&gt;&gt;&lt;bound method Foo.func2 of &lt;class '__main__.Foo'&gt;&gt;# 非绑定方法print(obj.func3)print(Foo.func3)obj.func3(1, 2)obj.func3(1, 2)# 运行结果&lt;function Foo.func3 at 0x1063e3bf8&gt;&lt;function Foo.func3 at 0x1063e3bf8&gt;func3 1 2func3 1 2 实际使用的例子:主要是绑定给类的使用场景; 123# settings.pyIP='1.1.2.2'PORT=3306 1234567891011121314151617181920212223242526272829303132333435# main.pyimport settingsclass MySQL: def __init__(self, ip, port): self.id = self.creat_id() self.ip = ip self.port = port def tell_info(self): print('&lt;%s : %s : %s' % (self.id, self.ip, self.port)) @staticmethod def creat_id(self): import uuid return uuid.uuid4() @classmethod def from_conf(cls): return cls(settings.IP, settings.PORT) obj = MySQL('1.1.1.1', 3306)obj.tell_info()# 运行结果&lt;86044651-cea8-4d93-99dc-46a02e169d6d : 1.1.1.1 : 3306&gt;a = obj.from_conf() # 产生一个新的对象a.tell_info()# 运行结果&lt;efec5e5f-4bfc-4534-8e60-940824532506 : 1.1.1.2 : 3306&gt;obj1 = MySQL.from_conf()obj1.tell_info()# 运行结果&lt;9463911a-ebcf-416a-9332-54282f3f3cba : 1.1.1.2 : 3306&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器的进一步学习]]></title>
    <url>%2F2018%2F10%2F24%2F%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[今天在调用被装饰器装饰的函数的时候实际调用函数返回的值和自己预想的不一样,经过朋友的指点发现问题在返回被装饰器装饰的函数的运行结果上. 12345678910111213141516def auth_login(func): def wrapper(*args, **kwargs): func(*args, **kwargs) return wrapper@auth_logindef paymoney(total): if total &gt; 0: return True else: return False if paymoney(10): print('数额充足')else: print('数额不足') 这个简单的装饰器应该很容易分析出结果,预想中的结果应该是打印:数额充足,然而结果却是什么都没打印,其实是因为装饰器有问题,因为并没有把被装饰的函数运行结果返回,那么装饰器的运行结果就为None,自然什么都不会打印. 正确的装饰器如下: 12345def auth_login(func): def wrapper(*args, **kwargs): res = func(*args, **kwargs) return res return wrapper]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>发现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类的三大特性之多态]]></title>
    <url>%2F2018%2F10%2F24%2F%E7%B1%BB%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态三问 什么是多态? 多态指的是同一种事物的多种形态,举个例子:每个人都会睡觉,但是每个人的睡觉姿势,睡眠质量都不一样,再说,每个人的祖宗都是猿类,但是现在几乎没有一模一样的两个人,有句话说世界上没有两片相同的叶子,这就是多态,这也是为什么这个世界多姿多彩,因为我们一样,我们也不一样. 为何要用多态? 我觉得不是用不用多态的问题,python的哲学是一切皆对象,那么对象其实可以想象成现实生活中的个体,这就自然而然有了多态的概念了,多个对象的某一个相同的方法,却有不一样的表现形式.那么在Python中怎么定义多态呢? 123456789101112131415import abcclass Animal(metaclass=abc.ABCMeta): @abc.abstractmethod def speak(self): pass # Animal() 父类不能实例化,因为父类本身就是用来制定标准的# speak方法被一个装饰装饰了,意味着只要是继承Animal类的子类都必须实现speak方法,强制实行的class People(Animal): def speak(self): pass #只有这样,才可以继承Animal类 python是一门自由度很高的语言,几乎没有什么强制要做的事情,这有好处也有坏处.好处是一门语言越自由那么开发者的创新性就越强,所以才有了越来越多的第三方库,使得python的生态环境愈发完善,像著名的requests库,唯一的一个非转基因的python HTTP库,人类可以安全享用.(扯远了…),越来越多的开发者使用python,开发新的特性和新的库,那么坏处就是python很自由,所以没有什么标准,你可以有你的标准,我可以有我的标准,按理说python是不禁止的,那么怎么解决这个问题呢? python的开发者都约定成俗的执行一些事情,比如常量全大写,函数名小写或者加下划线,类呢,就使用驼峰法命名,那么我们一看到变量名就可以知道这是个什么类型的变量了,同理,在python的类中,也约定成俗了用同样的名字改写自己的方法,查看基类object的源码可知: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110class object: """ The most base type """ def __delattr__(self, *args, **kwargs): # real signature unknown """ Implement delattr(self, name). """ pass def __dir__(self): # real signature unknown; restored from __doc__ """ __dir__() -&gt; list default dir() implementation """ return [] def __eq__(self, *args, **kwargs): # real signature unknown """ Return self==value. """ pass def __format__(self, *args, **kwargs): # real signature unknown """ default object formatter """ pass def __getattribute__(self, *args, **kwargs): # real signature unknown """ Return getattr(self, name). """ pass def __ge__(self, *args, **kwargs): # real signature unknown """ Return self&gt;=value. """ pass def __gt__(self, *args, **kwargs): # real signature unknown """ Return self&gt;value. """ pass def __hash__(self, *args, **kwargs): # real signature unknown """ Return hash(self). """ pass def __init_subclass__(self, *args, **kwargs): # real signature unknown """ This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. """ pass def __init__(self): # known special case of object.__init__ """ Initialize self. See help(type(self)) for accurate signature. """ pass def __le__(self, *args, **kwargs): # real signature unknown """ Return self&lt;=value. """ pass def __lt__(self, *args, **kwargs): # real signature unknown """ Return self&lt;value. """ pass @staticmethod # known case of __new__ def __new__(cls, *more): # known special case of object.__new__ """ Create and return a new object. See help(type) for accurate signature. """ pass def __ne__(self, *args, **kwargs): # real signature unknown """ Return self!=value. """ pass def __reduce_ex__(self, *args, **kwargs): # real signature unknown """ helper for pickle """ pass def __reduce__(self, *args, **kwargs): # real signature unknown """ helper for pickle """ pass def __repr__(self, *args, **kwargs): # real signature unknown """ Return repr(self). """ pass def __setattr__(self, *args, **kwargs): # real signature unknown """ Implement setattr(self, name, value). """ pass def __sizeof__(self): # real signature unknown; restored from __doc__ """ __sizeof__() -&gt; int size of object in memory, in bytes """ return 0 def __str__(self, *args, **kwargs): # real signature unknown """ Return str(self). """ pass @classmethod # known case def __subclasshook__(cls, subclass): # known special case of object.__subclasshook__ """ Abstract classes can override this to customize issubclass(). This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or NotImplemented. If it returns NotImplemented, the normal algorithm is used. Otherwise, it overrides the normal algorithm (and the outcome is cached). """ pass __class__ = None # (!) forward: type, real value is '' __dict__ = &#123;&#125; __doc__ = '' __module__ = '' 这里面的双下划线的方法,是基类已经定义好了的方法,那么继承基类的类,如果没有就用我的,如果有的话,你也用相同的名字,这样的话不管什么对象,都有同样的方法执行类似的事情,这就是多态,这也是python语言的魅力. 具体点来说,像linux的哲学是一切皆文件,那么通常来说文件只有两个属性,读和写,那么linux已经把各种复杂的方法封装为了读和写两个方法,那么就算我们不了解linux里面的某些硬件,我们也可以使用同样的方法来操作硬件.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类的三大特性之封装]]></title>
    <url>%2F2018%2F10%2F24%2F%E7%B1%BB%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[封装三问 什么是封装? 装指的是把属性装进一个容器 封指的是隐藏的意思,但是这种隐藏是对外不对内的 为什么要封装? 封装不是单纯意义的隐藏; ​ 封装数据的目的:将数据属性封装起来,类外部的使用就无法直接操作该数据属性 ​ 想要在内部操作属性的话需要在类内部提供一个接口给使用者,类的设计者可以在接口之上附加任意逻辑,从而严格控制使用者对属性的操作 ​ 封装函数属性的目的:隔离复杂度 如何封装? 只需要在属性前加上__开头,该属性就会被隐藏起来,该隐藏具备的特点: 1. 只是一种语法意义上的变形,即__开头的属性会在检测语法时发生变形,变为\_类名\_\_属性名; 2. 这种隐藏是对外不对内的,因为在类内部检测语法时所有的代码统一都发生变形; 3. 这种变形只在检测语法时发生一次,在类定义之后新增的__开头的属性并不会发生变形; 4. 如果父类不想让子类覆盖自己的属性,可以在属性前加上__开头. 一 封装的意图一 封装数据属性的真实意图123456789101112131415161718192021222324252627282930313233343536# coding: utf-8# @Time : 2018/10/24 6:39 PM# @Author : MUSIBII# @Email : shaozuanzuan@gmail.com# @File : 封装数据属性的真实意图.pyclass People: def __init__(self, name, age): self.__name = name self.__age = age def tell_info(self): print('name: %s age:%s' % (self.__name, self.__age)) def set_info(self, new_name, new_age): if type(new_name) is not str: print('名字必须是str类型') return if type(new_age) is not int: print('年龄必须是int类型') return self.__name = new_name self.__age = new_age def clear_info(self): del self.__name del self.__ageobj = People('musibii', 18)obj.tell_info()obj.set_info('maffia', 23) 二 封装函数属性的真实意图123456789101112131415161718192021222324252627282930313233# coding: utf-8# @Time : 2018/10/24 6:53 PM# @Author : MUSIBII# @Email : shaozuanzuan@gmail.com# @File : 封装函数属性的真实意图.pyclass ATM: def __card(self): print('插卡') def __auth(self): print('用户认证') def __input(self): print('输入提取金额') def __print_bill(self): print('打印账单') def __take_money(self): print('取款') def withdraw(self): self.__card() self.__auth() self.__input() self.__print_bill() self.__take_money()a = ATM()a.withdraw() 我们自己设置的私有属性并不是不让用,而是为了减少复杂度以及保护数据,在类里面定义的私有属性应该怎么访问呢? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# coding: utf-8# @Time : 2018/10/24 6:39 PM# @Author : MUSIBII# @Email : shaozuanzuan@gmail.com# @File : 封装数据属性的真实意图.pyclass People: def __init__(self, name, age, x): self.__name = name self.__age = age self.x = x def tell_info(self): print('name: %s age:%s' % (self.__name, self.__age)) def set_info(self, new_name, new_age): if type(new_name) is not str: print('名字必须是str类型') return if type(new_age) is not int: print('年龄必须是int类型') return self.__name = new_name self.__age = new_age def clear_info(self): del self.__name del self.__ageobj = People('musibii', 18, 13)obj.tell_info()obj.set_info('maffia', 23)print(obj.x)print(obj.__dict__)print(obj._People__name)# 运行结果name: musibii age:1813&#123;'_People__name': 'maffia', '_People__age': 23, 'x': 13&#125;maffia 虽然通过直接访问没用,查看对象的名称空间可以看到,原本的__name变形为了_People__name,那么可以通过这个名字访问到对象中的私有属性,同理函数也是一样的方法访问. 这种变形需要注意的问题是: 这种机制并没有真正意义上限制我们从外部直接访问属性,知道了类名和属性名就可以拼出名字:_类名__属性,然后就可以访问了,如a._A__N,即这种操作并不是严格意义上的限制外部访问,仅仅只是一种语法意义上的变形,主要用来限制外部的直接访问; 变形过程只在类的定义时发生一次,在定义后的赋值操作,不会变形. 在继承中,父类如果不想让子类覆盖自己的方法,可以将方法定义为私有属性. 1234567891011121314151617181920212223242526272829303132# 子类继承父类的非私有属性class A: def fa(self): print('from A') def test(self): self.fa()class B(A): def fa(self): print('from B')b=B()b.test()# 运行结果from B# 子类和父类具有同名的私有属性,那么在父类调用私有属性的话就以父类的为准class A: def __fa(self): #在定义时就变形为_A__fa print('from A') def test(self): self.__fa() #只会与自己所在的类为准,即调用_A__faclass B(A): def __fa(self): print('from B')b = B()b.test()# 运行结果from A 二 封装不是单纯意义的隐藏封装的真谛在于明确的区分内外,封装的属性可以在内部直接使用,而不能被外部直接使用,然而定义的属性的目的终归是要使用的,外部要想用类隐藏的属性,需要内部提供接口,让外部能够间接地用到我们隐藏起来的属性,那这么做的意义何在? 封装数据: 将数据隐藏起来不是目的.隐藏起来然后对外提供操作该数据的接口,然后我们可以在接口附加上对该数据操作的限制,以此完成对数据属性操作的严格控制. 封装方法: 封装方法的目的是隔离复杂度,在编程语言里,对外提供的接口(接口可以理解为一个入口),可以是函数,成为接口函数,这与接口的概念不一样,接口代表一组接口函数的集合体. 了解 python并不会真的阻止你访问私有属性,模块也遵循这种约定,如果模块名以单下划线开头,那么from import 时不能被导入,但是你from module import _private_module依然可以导入. 三 特性属性什么是特性? property是一种特殊的属性,访问它时会执行一段功能(函数)然后返回值.类中可能会有某些函数运行后的值是特定的或者就单纯的计算出某种特定的值,那么这种情况下,可以把该函数变为特性. 为什么要用property? 将一个类的函数定义为特性后,对象再去使用的时候,可以是访问数据属性一样访问,就好像装饰器一样,其实你根本不知道外面做了什么操作,而property也是一个装饰器. 123456789101112131415161718class People: def __init__(self, name, weight, height): self.name = name self.weight = weight self.height = height # @property def bmi(self): return self.weight / (self.height ** 2) obj = People('musibii', 60, 1.73)obj.weight = 65print(obj.bmi())# 运行结果21.71806608974573# 把注释去掉后,调用方法bmi()就可以像访问属性一样进行访问了.print(obj.bmi) 另外一种方法也可以实现这种方法: 12345678910111213141516171819202122class People: def __init__(self, name): self.__name = name def yyy_name(self, new_name): if type(new_name) is not str: print('名字必须是str类型') return self.__name = new_name def zzz_name(self): del self.__name def xxx_name(self): return '&lt;name:%s&gt;' % self.__name name = property(xxx_name, yyy_name, zzz_name)obj = People('musibii')print(obj.name) 这种方法稍显奇怪,其实作用是一样的,但是这种方法有一个需要注意的地方,那就是property类的__init__方法的参数是位置参数,所以严格按照每个方法的位置传值.查看__init__源码可得: 想要对该方法操作的数据属性实现删除,修改,查看是和property装饰器结合起来使用的: 123456789101112131415161718192021222324252627class People: def __init__(self,name): self.__name=name @property def name(self): return '&lt;name:%s&gt;' %self.__name @name.setter def name(self,new_name): if type(new_name) is not str: print('名字必须是str类型') return self.__name=new_name @name.deleter def name(self): del self.__nameobj=People('musibii')print(obj.name)# obj.name=123# print(obj.name)del obj.nameprint(obj.__dict__) 这样才真正实现了在不改变操作数据形式的基础上修改了数据属性的值. 经过本篇博客可知:封装其实是更高层次的一个函数形式,我觉得类同理,开辟自己的名称空间,减少代码的耦合性,更一步说,操作数据就是操作内存中的数据,其实在内存中有什么函数,类和对象吗?以我现在的知识觉得应该没有,内存中就是一堆冷冰冰的数据,那么除了产生新的对象(可变不可变),其实内存中的值得内存地址都没有变,只是一一个指向引用关系,其实python中也有指针概念的,只是没有c那样需要自己维护罢了,python的变量名和变量名指向的对象的关系就是房子和门牌号的关系,有名字便于找到房子,那么没有名字的房子不像现实生活中还可以存在,没有名字对该房子的引用,那么python的内存管理机制就会把该房子摧毁以便建下一个房子. 在python中的类和该类产生的对象是如何保存的呢? 类以及类中的方法在内存中只有一份,而通过类创建的每一个对象都需要在内存中保存一份,那么对象保存的是什么呢?其实就只保存了房子的地址(也就是类对象指针),该值指向当前对象的类. 当通过对象执行方法时,过程如下: 根据当前对象中的类对象指针,找到类中的方法; 将对象当做参数传给方法的第一个参数(self),这个self就是高度封装的一个对象(和类的特性封装不一样),一个self骑士可以容纳万物,只要内存可以装得下. python的面向对象里面的封装思想太厉害了.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的名称空间]]></title>
    <url>%2F2018%2F10%2F23%2Fpython%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[最开始对名称空间的了解是在学习函数的时候,那时候知道了作用域的查找顺序,以及全局名称空间和局部名称空间,产生疑惑的时候为学递归的时候,那时候还没有名称空间这个概念,只知道递归有个最大深度,那时候以后递归产生的名称空间是一层套一层的,以及类里面的名称空间,所以产生了深究名称空间的想法,这才诞生了这篇博客,本篇博客借鉴了python的命名空间的内容,本人对里面的例子都试验了并发现了一个错误,在类中定义的列表生成式产生的命名空间也可以访问到类属性. 例子12345678910111213141516171819# a.pylis = ['musibii', 'thales']print('lis1', id(name))class A: def __init__(self): pass def func(self): global lis lis.append('maffia') print('lis', id(lis)) return lis print('lis2', lis)# b.pyfrom a import Aprint('b', A) 执行 b 文件的结果为: 123lis1 4421146632lis2 ['musibii', 'thales']b &lt;class 'a.A'&gt; 可以发现,虽然 b 只是导入了 a 中的 class A, 但导入这个过程执行了整个 a 文件,那么是否能够在 b 中访问 a 中的全局变量 lis 呢? 使用 from a import A 的形式只是把 A 产生的名称空间复制了一份到 b 产生的名称空间中. Python的一些基本概念对象在Python 中一切皆对象,那么对象到底代表什么呢?我的理解是在执行 py 文件时产生的一切变量都称为对象,如果把内存比作一座超大的房子的话,那么对象就是这座房子里的租客,那么这个租客随身携带的东西就是这个对象的一切了,对象都具有唯一的 id( 内存地址),类型( python3中统一了类和类型的概念),以及对象的值,对象一旦建立, id 便不会改变, id 就是对象在内存中的地址. 用常见的对象来类比一下这三个概念: 常量 123456789NAME = 'musibii'print(id(NAME))print(type(NAME))print(globals()) # 查看全局名称空间# 运行结果4374978776&lt;class 'str'&gt;&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x104c45fd0&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': '/Users/jingxing/PycharmProjects/python全栈/作业/day27/duixiang.py', '__cached__': None, 'NAME': 'musibii'&#125; 出来的结果分别是 id,类型以及字典里面最后一个键值对对应的就是 NAME 的值. 函数 1234567891011121314151617def func(): name = 'musibii' def inner(): age = 18 print('age', age) inner() print(locals()) # 想要查看函数里面的值,必须在函数内部查看,因为函数执行完成会释放内存资源print(id(func))print(type(func))func()# 运行结果4529634840&lt;class 'function'&gt;age 18&#123;'inner': &lt;function func.&lt;locals&gt;.inner at 0x10e1cac80&gt;, 'name': 'musibii'&#125; id 和类型不必多说,函数对应的属性值里面不包括嵌套函数里面的属性(说明:名称空间是相互独立的) 类 123456789101112131415161718class Cls: school = 'hashangda' def __init__(self, name, age): self.name = name self.age = age def tell_info(self): print('%s : %s' % (self.name, self.age))print(id(Cls))print(type(Cls))print(Cla.__dict__)# 运行结果140390381504248&lt;class 'type'&gt;&#123;'__module__': '__main__', 'school': 'hashangda', '__init__': &lt;function Cls.__init__ at 0x10648eae8&gt;, 'tell_info': &lt;function Cls.tell_info at 0x10648ebf8&gt;, '__dict__': &lt;attribute '__dict__' of 'Cls' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Cls' objects&gt;, '__doc__': None&#125; 类的 id 为内存地址,类型为type类型,在 type 里面 type 就是类型的意思,所以说 python 里所有的类的类型都是类型,而类里面的属性就是类的值了. python 里面所有的对象都具有的并且根确定身份有关的值为 id, 类型和值了.名称不是对象的属性,名称只是指向对象,因为可以多个名称指向同一个对象. 标识符在对象里把变量名叫为名称其实是不准确的,这些名称都有一个共同的名字: identifier(和 id 是两个意思),中文名为’标识符’. 标识符:在 Python中,各类对象的名称,比如函数名,方法名,类名,变量名.常量名都称为标识符. 在 Python 中赋值并不会直接复制数据,而只是将名称绑定到对象,对象本身不需要知道和关心自己的标识符叫什么,一个对象甚至可以指向不同的标识符.真正管理这些标识符的事物是’名称空间’. 名称空间名称空间(NameSpace):名字(标识符)到对象的映射. 简单来说,名称空间可以理解为记录对象和对象名字对应关系的空间,在对象那里查看的对象的值就是名称空间,这是一个字典,一个命名空间就是名字到对象的映射,标识符是键,对象则是值. 作用域与名称空间相对的一个概念就是’作用域’,作用域本质是一块文本区域, Python 通过该文本区域可以直接访问相应的名称空间. Python 中不加 . 的访问为直接访问,反之为属性访问. 因此可以简单的将作用域理解为直接访问名称空间的一种实现,具体而言: 作用域内相应的名称空间可以被直接访问; 只有作用域内的名称空间才可以被直接访问(因此并不是所有的名称空间都可以被直接访问). LEGBLEGB 名称空间这四类名称空间可以简记为 LEGB: 局部名称空间( local): 指的是一个函数或者一个类所定义的名称空间:包括函数的参数,局部变量,类的属性等; 闭包名称空间(enclosing function):闭包函数的名称空间( python3引入); 全局名称空间( global):读入一个模块(也即一个. py 文件)后产生的名称空间; 内建名称空间(builtin):Python 解释器启动时自动载入__builtin__ 模块后形成的名称空间;像 str/list/dict… 等内置对象的名称就处于这里. 举例: 123456789# test.pyv1 = 'global var'def func(v1): v2 = 'local var' def inner(): v3 = v2 + v return v3 return inner 内建的反正每次都一样,在这里的三个名称空间里面的名称为: ‘v1’ 为全局变量 v1 的名字,其所处的名称空间为全局名称空间;需要注意的是全局名称空间包括 ‘func’ 但不包括 func 的参数和内部变量; func 包括 ‘v’, ‘v2’, 和 ‘inner’名称的局部名称空间; 执行 func 后, func 的作用域释放,并返回绑定了 v 和 v2变量的闭包函数 inner, 此时闭包函数的名称空间即为闭包名称空间,因此局部名称空间和闭包名称空间是相对而言的,对于父函数 func 而言,两者具有产生时间上的差异. LEGB 访问规则通过上面的例子,发现 LEGB 四类名称空间本身具有明显的内外层级概念,而这种层级概念正是构建作用域的前提:作用域依据这种层级概念将不同类型的名称空间组织起来并划归到不同层级的作用域,然后定义好不同层级作用域之间的访问规则,从而实现名称空间的直接访问. LEGB 的访问规则:**同样的标识符在各层名称空间可以被重复使用而不会发生冲突,但 Python 寻找一个标识符的过程总是从当前层开始逐层网上找,直到首次找到这个标识符为止. 123456789101112131415# main.pyv1 = 1v2 = 3def func(): v1 = 2 print(v1) print(v2) func()print(v1)# 运行结果231 全局变量和函数 func 都定义了变量 v1,在函数内部会优先选择自己局部名称空间内的变量 v1,对于 func 中未定义的变量 v2,Python 会向上查找全局名称空间,读取全局变量后打印输出. global 和 nonlocal 语句global 和 nonlocal 的作用对于上层名称空间里的变量, python 允许直接读取,但是不可以在内层作用域直接改写上层变量,在这方面很明显的区别就是在闭包函数里. 1234567891011# e.pygv = ['a', 'global', 'var']def func(v): gv = ['gv'] + gv lv = [] def inner(): lv = lv + [v] gv.insert(1, lv[0]) return return inner 实际调用 func 函数后,上面两处对 gv 和 lv 进行赋值的操作都会发生UnboundLocalError:因为 python 在执行函数前,会首先生成各层名称空间和作用域,因此 python 会在执行赋值前将 func 内的 gv 和 lv 写入局部名称空间和闭包名称空间,当 python 执行赋值语句的时候,会发现在局部作用域,闭包作用域内发现局部名称空间和闭包名称空间内已经具有 gv 和 lv 标识符,但是这两个非全局标识符在赋值语句执行之前并没有被赋值,也即没有对象与标识符关联,因此无法参与赋值运算,从而触发在引用之前未赋值的错误;但这段程序的本意是为了让全局变量 gv 和局部变量 lv 参与运算,为了避免类似的情况发生,Python 引入了global和nonlocal语句来说明局部名称空间和闭包名称空间使用的标识符分别来自全局名称空间和局部名称空间,声明之后就可以在 func 和 inner 名称空间里直接改写上层名称空间内的gv和lv的值了. 123456789101112131415# f.pygv = ['a', 'global', 'var']def func(v): global gv gv = ['gv'] + gv lv = [] print(id(lv)) def inner(): nonlocal lv lv = lv + [v] print(id(lv)) gv.insert(1, lv[0]) return return inner 这样就可以正常修改了.原博客说 lv 的 id 都是一样的,在 mac 上版本为3..6.6测试发现不是一样的. 1234# 运行结果44166001364416615624# 确实是使用了上层名称空间的变量,但是重新赋值后, gv 和上层的 gv 已经不是同一个了, lv 也一样,所以内存地址都发生变化了. 借壳那么不用 global 和nonlocal 可以达到上面的目的吗? 12345678910111213# g.pygv = ['a', 'global', 'var']def func(v): gv.insert(0, 'gv') lv = [] print(id(lv)) def inner(): lv.append(v) print(id(lv)) gv.insert(1, lv[0]) return gv return inner 看作者的这个解释为借壳,感觉很形象,这个原因应该用列表式可变类型来解释比较好, insert 和 append 的操作并没有对列表进行赋值操作,而是对列表这个容器里面的东西修改了并不是修改列表,我们都知道电脑内的内存永远都不会改变,他就是个超大的容器,用来装东西的,假如现在有个列表,它的容量和内存一样大,那么是不是好理解点,我们在和内存一样的列表里操作会改变这个列表吗?不会. 在 global 和 nonlocal 的作用就是把上层有的标识符和对象复制一份到下层名称空间 为什么在下层作用域可以使用读取上层作用域的值而不可以使用它的值呢? 这是因为 python 的两个概念不同的原因,作用域和名称空间的区别导致的.标识符的查找顺序是从当前层一层层向外查找的,这是根据作用域来查找的,那么名称空间呢?作用域和名称空间的在执行 py 文件就已经产生了,其实可以理解这是一个东西,其实里面保存的信息(除了某些可能有特殊含义的值不一样外)都一样,不一样的是作用于里面只保存了标识符,而名称空间里不仅保存了标识符还保存了标识符对应的对象.查找值的顺序是根据作用域来的,使用值就只能使用自己名称空间里的值,名称空间里保存的是标识符和标识符对应的对象,只有本层名称空间里有这个标识符和标识符对应的对象才可以使用(读,使用). 那么现在很明白为什么不能直接在下层名称空间直接使用上层名称空间里的名称了. global 和 nonlocal 语句对标识符创建的不同影响需要注意的是: global 语句只是声明该标识符引用的变量来自于全局变量,但并不能直接在当前层创建该标识符;nonlocal 语句则会在子函数名称空间创建与父函数变量同名的标识符. 123456789101112131415# j.pygv = ['a global var']def func(): global lv = 'a local var' print(locals()) def inner(): nonlocal lv global gv print(locals()) return inner# 运行结果&#123;'lv': 'a local var'&#125;&#123;'lv': 'a local var'&#125; 运行 func 函数后 global 语句并未将 ‘ gv ‘变量引入局部名称空间,执行闭包函数后,’ local’语句将父函数变量’lv’引入闭包名称空间. 之所以 nonlocal 和 global 语句的处置不同,在于全局变量的作用域生存期很长,在模块内随时都可以访问,而父类函数的局部作用域在父函数执行完毕后便会直接释放,因此 nonlocal 语句必须将父函数变量的标识符写入闭包名称空间. 名称空间的生命周期创建规则还有一个重要的问题没有解决:’标识符不是一开始就存在名称空间的,名称空间也不是平白无故产生的,那么名称空间是在什么时候被创建?又是什么时候被删除的呢?’ 名称空间产生顺序: 内建名称空间在 Python 解释器启动时创建,之后会一直存在; 模块的全局名称空间在模块定义时被读入创建,通常模块名称空间也会保持到解释器退出; 函数调用时产生新的局部名称空间,函数返回结果,抛出异常时释放名称空间,每一次递归都产生一个名称空间; 标识符产生地点决定标识符所处的名称空间. 类的名称空间首次,函数和类执行时都会产生局部名称空间,但类的执行机制不同于函数; 123456789101112131415# i.pydef a(): print('function')class A(): print(1) class B(): print(2) class C(): print(3) # 运行结果123 如上,类就是一个可执行的代码块,只要该类被加载,就会被执行,这一点不同于函数. 类之所以这样设计的原因在于:类是创建其他实例(声称其他的类或者具体的对象)的对象,因此必须在实例之前被创建,而类又可能涉及到与其他类的继承,重载等一系列问题,故在代码加载时就被创建利于提高效率和降低逻辑复杂度. 其次,与函数不同的是,类的局部名称空间并非作用于; 123456class A(): a = 1 b = [a + i for i in range(3)] # 运行结果NameError: name 'a' is not defined 执行上段代码,可以发现类 A 内列表推导式无法调取 a 的值,但函数可以. 123456def func(): a = 1 b = [a + i for i in range(3)] print(b)func() #[1, 2, 3] 因此, A 中的 a 不同于 func 中的 a 在局部名称空间可以被任意读取,之所以说是’不可以被任意’读取而不是’不可被读取’,原因在于在类 A 的局部名称空间内, a 其实在一定程度上可以被读取的: 123456class A(): a = 1 c = a + 2# 运行结果3 而上例中 b 的赋值操作不能被执行,原因在于列表推导式会创建自己的局部名称空间,因此难以访问到 a??????? 为什么访问不到 a??? 编译与局部名称空间Python 是动态语言,很多行为是动态发生的,但 Python 自身也在不断进步,比如为了提高效率,有些行为会在编译时候完成,局部变量的创建就是如此. 123456def func(): a = 1 def inner(): print(a) # error a = 2 # error inner() 上段程序还未执行,就提示存在语法错误,原因在于 Python 解释器发现 inner 内存在自身的 a 变量,但在声明之前就被 print 了. 总结1、为什么 b.py 只是导入 a.py 中的 class A,却执行了整个 a.py 文件?答：因为 Python 并不知道 class A 在 a.py 文档的何处，为了能够找到 class A，Python 需要执行整个文档。2、为什么 b.py 的导入执行了整个 a.py 文档，却在 b 中难以调用 a 的全局变量 va？答：Python 的全局变量指的是模块全局，因此不可以跨文档，因此 global 语句也是不可以跨文档的。另外， b 只是导入了 a 的 class A，因此并不会导入 a 中所有的标识符，所以 类似a.va 这样的调用也是不起作用的。 关于命名空间：1、赋值、定义类和函数都会产生新的标识符；2、全局变量的标识符不能跨文档；3、各级命名空间相互独立互不影响；4、Python 总是从当前层逐渐向上寻找标识符；5、内层作用域若想直接修改上层变量，需要通过 global nonlocal 语句先声明；6、单纯的 global 语句并不能为所在层级创建相应标识符，但 nonlocal 语句可以在闭包空间中创建相应标识符；7、类的局部命名空间不是作用域。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>NameSpace</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类的三大特性之继承]]></title>
    <url>%2F2018%2F10%2F23%2F%E7%B1%BB%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[一 初识继承一 什么是继承?继承是一种创建新类的方式,新建的类可以继承一个或多个父类(python支持多继承),父类又可成为基类或超类,新建的类称为派生类或子类. 子类会继承父类的属性,从而解决代码重用问题. python中类的继承分为:单继承和多继承 1234567891011class Parent1: passclass Parent2: passclass Sub1(Parent1): # 单继承,基类是Parent1,派生类是Sub passclass Sub2(Parent1,Parent2): # 多继承,用逗号分隔开多个继承的类 pass 查看继承 1print(sub2.__bases__) # __base__只查看继承的第一个子类,__bases__则是查看所有继承的父类 经典类与新式类 只有在python2中才分新式类和经典类,python3统一都是新式类 在python2中,没有显式的继承object类的类,类与该类的子类,都是经典类 在python2中,显式的声明继承object的类,类与该类的子类,都是新式类 在python3中,无论是否继承object,都默认继承object,即python3中所有的类均为新式类 python3中如果没有指定基类,python的类会默认继承object类,object类是所有python类的基类,它内置了一些方法. 二 继承与抽象继承描述的是子类与父类的继承关系,想要找出这种关系,必须先抽象再继承. 抽象:即抽取类似或者相似的部分 继承:是基于抽象的结果,通过编程语言去实现它,肯定是先经历抽象这个过程,才能通过继承的方式去表达出抽象的结构 二 继承的使用场景三 继承与重用性在开发程序的过程中,如果我们首先定义了一个A类,然后又想新建一个B类,但是B类的大部分内容与A类代码相同时,可以通过继承的方法来实现代码重用. B继承A会获得A的所有属性(数据属性与函数属性),所以B中没有而A中具有的属性可以被B用来使用,而B中有的就使用自己的: 12345678910111213141516171819202122232425class A: a = 123 print(a) def func1(self): print('A, func1') def func2(self): print('A, func2') self.func1() class B(A): a = 134 def func1(self): print('B, func1') b = B()print(b.a)b.func2()# 运行结果123 # A为B的父类,在继承的时候会首先执行A类中的代码134A, func2B, func1 四 派生类虽然子类是继承了父类的的属性,但是子类也可以添加自己新的属性或者对子类生成的对象定义自己的属性(不会影响到父类),需要注意的是,一旦重新定义了自己的属性且与父类同名时,那么调用新的属性时以子类的为准. 123456789101112131415161718class A: a = 123 print(a) def func1(self): print('A, func1') def func2(self): print('A, func2') self.func1() class B(A): a = 134 def func1(self): print('B, func1') def func3(self): print('B, func3') B定义了自己新的属性func3,而且该函数和A类没有关系. 五 组合与重用性软件重用的重要方式除了继承之外还有另外一种方式,即:组合 组合指的是,在一个类中以另外一个类的对象作为数据属性,称为类的组合 12345678910111213class Equip: #武器装备类 def fire(self): print('release Fire skill') class Riven: #英雄Riven的类,一个英雄需要有装备,因而需要组合Equip类 camp='Noxus' def __init__(self,nickname): self.nickname=nickname self.equip=Equip() #用Equip类产生一个装备,赋值给实例的equip属性 r1=Riven('锐雯雯')r1.equip.fire() #可以使用组合的类产生的对象所持有的方法# 运行结果release Fire skill 组合与继承都是有效的利用已有类的资源的重要方式.但是二者的概念和使用场景皆不同. 继承的方式 通过继承建立了派生类和父类之间的关系,它是一种从属关系. 当类之间有很多相同的功能,提取这些共同的功能做成基类,用继承比较好 组合的方式 用组合的方式建立了类与组合的类之间的关系,它是一种附带关系. 六 抽象类 什么是抽象类? 与java一样,python也有抽象类的概念但是同样需要借助模块实现,抽象类是一个特殊的类,它的特殊之处在于只能被继承,不能被实例化. 为什么要有抽象类? 如果说类是从一堆对象中抽取相同的内容得来的,那么抽象类就是从一堆类中抽取相同的内容而来的,内容包括数据属性和函数属性. 从设计角度看,抽象类与普通类的不同之处在于:抽象类中只能抽象方法(没有实现功能),该类不能被实例化,只能被继承,且子类必须实现抽象方法. 三 继承实现的原理一 继承顺序在python中可以同时继承多个父类,如A(B,C,D) 如果继承关系为非菱形结构,则会按照先找B这一条分支,然后再找C这一条分支,最后找D这一条分支的顺序直到找到要找的属性,找完了还没有的话会报属性不存在的错误. 如果继承关系为菱形结构,那么属性的查找方式有两种,分别是:深度优先和广度优先. 12345678910111213141516171819202122232425262728293031class A(object): def test(self): print('from A')class B(A): def test(self): print('from B')class C(A): def test(self): print('from C')class D(B): def test(self): print('from D')class E(C): def test(self): print('from E')class F(D,E): # def test(self): # print('from F') passf1=F()f1.test()print(F.__mro__) #只有新式才有这个属性可以查看线性列表，经典类没有这个属性#新式类继承顺序:F-&gt;D-&gt;B-&gt;E-&gt;C-&gt;A#经典类继承顺序:F-&gt;D-&gt;B-&gt;A-&gt;E-&gt;C#python3中统一都是新式类#pyhon2中才分新式类与经典类 二 继承原理python是如何实现继承并查找属性的,对于你定义的每一个类,python会计算出一个方法解析顺序(MRO)列表,这个MRO列表就是一个简单的所有基类的线性顺序列表. 为了实现继承,python会在MRO列表中从左到右开始查找基类,直到找到第一个匹配这个属性的类为止.而这个MRO列表的构造是通过一个C3线性化算法来实现的.它实际上就是合并所有父类的MRO列表并遵循如下三条准则: 子类会先于父类被检查 多个父类会根据它们在列表中的顺序被检查 如果对下一个类存在两个合法的选择,选择第一个父类 查找属性时,即使没有直接继承关系,也会按照MRO列表继续往后查找,当使用super()函数时,python会在MRO列表上继续搜索下一个类.只要每个重定义的方法统一使用super()并只调用它一次,那么控制流最终会遍历完整个MRO列表,每个方法也只会被调用一次 注意:使用super调用的所有属性,都是从MRO列表当前的位置往后找,不要在意继承关系,看MRO列表就好 三 super的使用BaseTher类的创建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# coding: utf-8# @Time : 2018/10/23 11:40 PM# @Author : MUSIBII# @Email : shaozuanzuan@gmail.com# @File : father_type.pyimport os, sysimport pickleimport hashlibsys.path.append(os.path.dirname(os.path.dirname(__file__)))import db_file''' 11、抽象老师类与学生类得到父类，用继承的方式减少代码冗余'''import timeclass BaseTher: def __init__(self, name, age, gender): self.name = name self.age = age self.gender = gender self.time = time.time() # self.id_hash = self.create_id() # 创建唯一的id def create_id(self): # timenow = str(time.time()).split('.')[0] key = self.name + str(self.age) + self.gender + str(self.time) m = hashlib.md5(key.encode('utf-8')) self.id_hash = m.hexdigest() # print(m.hexdigest()) # return m.hexdigest() def tell_info(self): data = self.get_obj_by_id() for item in data: print('%-10s: %-20s' % (item, data[item])) # print(data) # 将信息序列化后保存到文件 def save(self): user_data = &#123;'name': self.name, 'age': self.age, 'gender': self.gender, 'id_hash': self.id_hash&#125; with open('db_file/%s' % self.id_hash, 'wb') as f: pickle.dump(user_data, f) # 通过id反序列化信息 def get_obj_by_id(self): with open('db_file/%s' % self.id_hash, 'rb') as f: return pickle.load(f) 子类通过super().init(*args)使用父类的init方法 1234567891011121314151617181920212223242526272829303132class Teacher(BaseTher): def __init__(self, name, age, gender, level, salary): super().__init__(name, age, gender) self.level = level self.salary = salary # self.id_hash = self.create_id() # 创建唯一的id def create_id(self): # timenow = str(time.time()).split('.')[0] key = self.name + str(self.age) + self.gender + str(self.level) + str(self.salary) m = hashlib.md5(key.encode('utf-8')) self.id_hash = m.hexdigest() # print(m.hexdigest()) # return m.hexdigest() # def tell_info(self): # data = self.get_obj_by_id() # for item in data: # print('%-10s: %-20s' % (item, data[item])) # # print(data) # 将老师信息序列化后保存到文件 def save(self): user_data = &#123;'name': self.name, 'age': self.age, 'gender': self.gender, 'level': self.level, 'salary': self.salary, 'id_hash': self.id_hash&#125; with open('db_file/%s'%self.id_hash, 'wb') as f: pickle.dump(user_data, f) # # 通过id反序列化老师信息 # def get_obj_by_id(self): # with open('db_file/%s'%self.id_hash, 'rb') as f: # return pickle.load(f) 在Python3中,super()括号里面可以为空,不过也可以写成super(本类的名字,self) 像上面的super().init(name, age, gender), 可以写成super(Teacher,self).init(name, age, gender) 四 组合的使用 什么是组合? 一个对象的属性是来自另外一个类的对象,称之为组合 为何用组合? 组合也是用来解决类与类代码冗余的问题 组合的用法如下代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# coding: utf-8# @Time : 2018/10/24 10:27 AM# @Author : MUSIBII# @Email : shaozuanzuan@gmail.com# @File : zuhe.pyclass OldboyPeople: school = 'Oldboy' def __init__(self, name, age, gender): self.name = name self.age = age self.gender = genderclass OldboyStudent(OldboyPeople): def __init__(self, name, age, gender): super().__init__(name, age, gender) def choose_course(self): print('%s is choosing course' % self.name)class OldboyTeacher(OldboyPeople): def __init__(self, name, age, gender, level, salary): OldboyPeople.__init__(self, name, age, gender) self.level = level self.salary = salary def score(self, stu, num): stu.num = num print('老师%s给学生%s打分%s' % (self.name, stu.name, num))class Course: def __init__(self, course_name, course_price, course_period): self.course_name = course_name self.course_price = course_price self.course_period = course_period def tell_course(self): print('课程名:&lt;%s&gt; 价钱:[%s] 周期:[%s]' % (self.course_name, self.course_price, self.course_period))course = Course('python', 3000, '5months')stu1 = OldboyStudent('musibii', 18, 'male')stu1.course = courseprint(stu1)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据类型与类的总结]]></title>
    <url>%2F2018%2F10%2F23%2Fpython%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象编程]]></title>
    <url>%2F2018%2F10%2F22%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一 面向对象编程与面向过程编程1 面向过程编程思想该思想核心是过程，指的是解决问题的步骤，即先干什么然后干什么，就像流水线一样，必须一步一步来，基于面向过程编程的是一种机械化的思维方式。 优点： 复杂问题流程化，简单化； 缺点：可扩展性较差。 应用场景：一旦完成几乎不会改变，像Linux内核、git以及Apache HTTP Server等 2 面向对象编程思想随着硬件的快速发展，业务需求越来越复杂，以及编程应用领域越来越广泛，面向过程编程已经不能满足需求了，于是另一种编程思想开始兴起，就是面向对象编程。 该思想核心是对象，对象是特征与技能的结合体，基于面向对象设计程序就好比自己是造物主一样，想要创造什么就创造什么，与面向过程机械式的思维方式形成鲜明对比，面向对象更加注重对现实世界的抽象化。 优点：解决了程序的扩展性。对某一个对象单独修改，会立刻反应到整个体系中。 缺点：1. 编程的复杂度高于面向过程编程，不了解面向对象而立即上手基于对象设计程序，容易出现过度设计的问题。一些扩展性要求低的场景使用面向对象会增加编程难度。 无法向面向过程的程序设计流水式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题。 应用场景：需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等 面向对象的程序设计并不是全部。对于一个软件质量来说，面向对象的程序设计只是用来解决扩展性。 一个好的应用软件应包括的特性： 二 类与对象一 类的定义类即类别、种类，是面向对象设计最重要的概念，对象是特征与技能的结合体，而类则是一系列具有相似特征与技能的抽象概念。 在现实中是先出现对象，然后根据一系列具有相同特征的对象定义不同的类，对象是具体的存在，而类仅仅只是一个概念，并不真实存在。 在程序中是先定义类，然后根据类产生对象，这与函数的使用是类似的，先定义函数，类同理，在程序中需要先定义类，后调用类，与函数不一样的是，调用函数会执行函数体代码返回的是函数的执行结果，而调用类会产生并返回一个对象。 在程序中，务必保证，先定义类，后使用对象。 在程序中特征使用变量标识，技能使用函数标识。 因而类中最常见的是：变量和函数的定义。 1234567891011# 定义一个类class something: school = 'hashangda' def learn(self): print('something is learning') def eat(self): print('something is eating') def sleep(self): print('something is sleeping') 注意: 类中可以为任意python代码,这些代码在类定义阶段便会执行; 因而会产生新的名称空间,用来存放类的变量名与函数名,可以通过something.dict查看; 对于经典类来说可以通过该字典操作类名称空间的名字(新式类有限制),但python为我们提供了专门的语法进行访问; 点事访问属性的语法,类中定义的名字,都是类的属性(变量和函数). 二 程序中类的用法在程序中用.来访问类的属性,本质操作为dict 1234something.school # 等于经典类 something.__dict__['school']something.school = 'oldboy' # 等于经典类 something.__dict__['school'] = 'oldboy'something.name = 'musibii' # 等于经典类 something.__dict__['name'] = 'musibii'del something.name # 等于经典类 something.__dict__.pop('name') 在程序中调用类(实例化对象),产生并返回一个对象,产生的对象会具有类里面的属性,并且可以通过句点法进行访问. 总结: 类本质是一个名称空间,或者说是一个用来存放变量与函数的容器; 类的用途之一就是当做名称空间从其内部取出名字来使用; 类的主要用途是调用类产生对象. 三 对象的使用通过调用类产生的对象成为类的实例化,调用类的返回值称之为类的一个对象/实例. 123some = something() # 产生一个实例对象,对象可以通过句点法访问类中的属性()print(some.school)# 结果 hashangda 类中定义的属性是由该类产生的所有对象共有的属性,那么每个对象自己特有的属性应该怎么定义的? 1234567class something: school = 'hashangda' def __init__(self, name, age, gender): self.name = name self.age = age self.gender = gender 类中的init方法是用来初始化一个实例对象的,并且会执行下面的代码,所以这时候要实例化对象是需要传入后面的参数. 123some1 = something('musibii', 18, 'male')some2 = something('thales', 20, 'female')some3 = something('maffia', 22, 'male') 这样实例化出来的对象除了school属性值一样,其他都是自己独有的属性值. 调用类产生了 先产生一个空对象some1,然后返回; 触发类中函数init的执行,将对象联通调用类括号内指定的参数一同传入init. 总结:init的功能,在实例化时为对象初始化自己独有的特征(不能有返回值) 四 属性查找属性查找和之前学的名称空间查找顺序逻辑一样,首先在对象的名称空间里面查找,没有的话去类名称空间查找,但是不会去全局名称空间查找对象的属性. 类中定义的变量是所有对象共享的,对象可以使用,类也可以使用,类一旦改变自己的属性的值,所有的对象也会随之改变. 五 绑定方法类中定义的变量是类的数据属性,类和对象都可以使用,并且属性的值都指向一个内存地址; 类中定义的函数是类的函数属性,类和对象都可以调用,类来调用的就是一个普通的函数,但类中定义的函数都是用来给对象用的,而且是绑定给对象的. 类的函数:该传几个参数就传几个 绑定方法,指向类的函数:特殊之处是绑定给哪个对象就应该由哪个对象来调用,调用的时候就会把对象本身当做第一个参数自动传入. 六 一切皆对象在python3中统一了类和类型的概念,就是说一个类等于一种类型,比如python中的数据类型,我们也可以定义属于自己的类 12345class muSibii: passmusibii = muSibii()print(type(musibii))# 结果 &lt;class '__main__.muSibii'&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一首沉下来特别好听的歌]]></title>
    <url>%2F2018%2F10%2F19%2F%E4%B8%80%E9%A6%96%E6%B2%89%E4%B8%8B%E6%9D%A5%E7%89%B9%E5%88%AB%E5%A5%BD%E5%90%AC%E7%9A%84%E6%AD%8C%2F</url>
    <content type="text"><![CDATA[最近一直在单曲循环 腰乐队的《一个短篇》 《一个短篇》 作词：刘弢 作曲：杨绍昆 旋转 跳跃喔 他感到每条路都在头痛 新鲜的帕特里克满脑子 都是开拓的自慰器 那些男人爱的男人爱市政 市政爱市民 市民爱流连 旋转 跳跃喔 他感到飞鸟们也在头痛 冒牌的帕特里克满脑子 都是稳妥的独角戏 那些男孩爱的男人爱机器 机器爱法律 法律是你 深夜里辛蒂蕾拉们倒下的地方 促成整片血红的高楼 在搞与不搞之间泛起淡淡的哀伤 他的来头已经腐朽 别担心没有哪一首歌能够 把这个现实唱到地狱去 当你还能享有这种静默我的老爷 这烂摊就不会收场 旋转 跳跃吧 他感到连晚风也在头痛 狗娘养的帕特里克满脑子 关于体态的滑翔机 他说过那些女人爱的男人爱萝莉 萝莉爱包包 包包爱货币 他在高级堡垒的方针里走出 带来大会的消息 在幼犬和地皮商的征程里 他是发达的肯定句 等他和他们 他们和所有人之间 都搞不来信任的时候 只要冬和她的姨妈 从没有熄灯的窗口 无声眺望 这夜派对 就要散场 这夜派对 就要散场 这夜派对 就要散场 这夜派对 就要散场 幽暗的最高频道还在 为全城遮盖下一百年的昂贵谜底 他倚靠在令人害羞的礼品堆里 冉冉睡去 幽暗的最高频道还在 为全城遮盖下一百年的昂贵谜底 他依靠在令人害羞的礼品堆里 冉冉睡去 幽暗的最高频道还在 为全城遮盖下一百年的昂贵谜底 他依靠在令人害羞的礼品堆里 冉冉睡去]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>呐喊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机硬件基础]]></title>
    <url>%2F2018%2F10%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一 计算机基本组成目前市面上的计算机几乎都是冯诺依曼体系计算机，冯·诺依曼计算机使用冯诺依曼体系机构的电子数字计算机。1945年6月，冯·诺依曼提出了在数字计算机内部的存储器中存放程序的概念，这是所有现代电子计算机的末班，被称为“冯·诺依曼结构”，按照这种结构构造的电脑称为存储程序计算机，又称为通用计算机。 冯·诺依曼体系的计算机的特点是：程序以二进制代码的形式存放在存储器中；所有的指令都是由操作码和地址码组成；指令在其存储过程中按照执行的顺序进行存储；以运算器和控制器作为计算机结构的中心等。冯诺依曼计算机广泛应用于数据的处理和控制方面。 冯诺依曼理论的要点是：数字计算机的数制采用二进制；计算机应该按照程序顺序执行。 根据冯诺依曼体系结构组成的计算机，必须具有如下功能： 把需要的程序和数据送至计算机中。 必须具有长期记忆程序、数据、中间结果及最终运算结果的能力。 能够完成各种算术、逻辑运算和数据传送等数据加工处理的能力。 能够根据需要控制程序走向，并能根据指令控制机器的各部件协调操作。 能够按照要求将处理结果输出给用户。 为了完成以上功能，计算机必须具备以下五大基本组成部件： 控制器：计算机的指挥系统。控制器通过数据地址来访问存储器，从存储器中取出指令，经过编译器编译或解释器解释后，根据结果得出相应的操作信号并作用于其他部件，使得各部件在控制器的严格控制下互相协调的工作。 运算器：实现算术运算和逻辑运算的部件。 存储器：计算机用来存储所有数据和程序的记忆部件。它的基本功能是按照指定的存储地址存（写）入或取（读）出数据。 输入设备：是向计算机中输入信息（程序、数据、声音、文字、图形、图像等）的设备。常见的输入设备有：键盘、鼠标、图形扫描仪、触摸屏等。 输出设备：主要有显示器、打印机和绘图仪等。 现代计算机将上述五大部分分为三大核心部件： CPU（控制单元+算数逻辑单元） 主存储器 输入输出设备 这几个部件的相关性如下： 二 编程与计算机硬件的关系为了使计算机能够理解人的意图，人类就必须将需要解决的问题的思路、方法和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人与计算机体系之间交流的过程就是编程。 编写的程序经过译码器分析后得到的是一大堆的二进制指令，这些指令通过CPU读取从而产生相应的操作控制信号作用于其他的硬件上，从而完成相应的功能。 三 内存容量单位的换算1Byte=8bit 1KB=1024Bytes 1MB=1024KB 1GB=1024MB 有的生产厂家的换算单位为1000。 四 CPU位数关系现在市面上的计算机主要分为32位和64位两种规格，他们之间的区别主要为以下四点： 处理数据能力不同 支持的内存不同（寻址不同） 架构不同 对配置的要求不同 五 操作系统基础 操作系统是什么？ 操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在‘裸机’上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是一个协调\管理\控制计算机硬件资源与软件资源的一个控制程序。 为什么要有操作系统？ 操作系统是用户和计算机硬件的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，改善人机界面，为其他应用软件提供支持，让计算机系统所有资源最大限度的发挥作用，提供各种形式的用户界面，使用户有一个好的工作环境，为其他软件的开发提供必要的服务和相应的接口等。实际上，用户是不用接触操作系统的，操作系统管理着计算机的硬件资源，同时按照应用程序的资源请求来分配资源，如：划分CPU时间、内存空间的开辟、调用打印机等。 操作系统就是为了让使用者更加方便的使用计算机硬件资源和软件资源的一个工具。]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python模块之re]]></title>
    <url>%2F2018%2F10%2F19%2Fpython%E6%A8%A1%E5%9D%97%E4%B9%8Bre%2F</url>
    <content type="text"><![CDATA[re 模块在 Python 中，我们可以使用内置的 re 模块来使用正则表达式。 有一点需要特别注意的是，正则表达式使用 \ 对特殊字符进行转义，比如，为了匹配字符串 ‘python.org’，我们需要使用正则表达式 &#39;python\.org&#39;，而 Python 的字符串本身也用 \ 转义，所以上面的正则表达式在 Python 中应该写成 &#39;python\\.org&#39;，这会很容易陷入 \ 的困扰中，因此，我们建议使用 Python 的原始字符串，只需加一个 r 前缀，上面的正则表达式可以写成： 1r&apos;python\.org&apos; re 模块提供了不少有用的函数，用以匹配字符串，比如： compile 函数 match 函数 search 函数 findall 函数 finditer 函数 split 函数 sub 函数 subn 函数 re 模块的一般使用步骤如下： 使用 compile 函数将正则表达式的字符串形式编译为一个 Pattern 对象 通过 Pattern 对象提供的一系列方法对文本进行匹配查找，获得匹配结果（一个 Match 对象） 最后使用 Match 对象提供的属性和方法获得信息，根据需要进行其他的操作 compile 函数compile 函数用于编译正则表达式，生成一个 Pattern 对象，它的一般使用形式如下： 1re.compile(pattern[, flag]) 其中，pattern 是一个字符串形式的正则表达式，flag 是一个可选参数，表示匹配模式，比如忽略大小写，多行模式等。 下面，让我们看看例子。 1234import re# 将正则表达式编译成 Pattern 对象 pattern = re.compile(r'\d+') 在上面，我们已将一个正则表达式编译成 Pattern 对象，接下来，我们就可以利用 pattern 的一系列方法对文本进行匹配查找了。Pattern 对象的一些常用方法主要有： match 方法 search 方法 findall 方法 finditer 方法 split 方法 sub 方法 subn 方法 match 方法match 方法用于查找字符串的头部（也可以指定起始位置），它是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果。它的一般使用形式如下： 1match(string[, pos[, endpos]]) 其中，string 是待匹配的字符串，pos 和 endpos 是可选参数，指定字符串的起始和终点位置，默认值分别是 0 和 len (字符串长度)。因此，当你不指定 pos 和 endpos 时，match 方法默认匹配字符串的头部。 当匹配成功时，返回一个 Match 对象，如果没有匹配上，则返回 None。 看看例子。 12345678910111213141516171819&gt;&gt;&gt; import re&gt;&gt;&gt; pattern = re.compile(r'\d+') # 用于匹配至少一个数字&gt;&gt;&gt; m = pattern.match('one12twothree34four') # 查找头部，没有匹配&gt;&gt;&gt; print mNone&gt;&gt;&gt; m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配&gt;&gt;&gt; print mNone&gt;&gt;&gt; m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配&gt;&gt;&gt; print m # 返回一个 Match 对象&lt;_sre.SRE_Match object at 0x10a42aac0&gt;&gt;&gt;&gt; m.group(0) # 可省略 0'12'&gt;&gt;&gt; m.start(0) # 可省略 03&gt;&gt;&gt; m.end(0) # 可省略 05&gt;&gt;&gt; m.span(0) # 可省略 0(3, 5) 在上面，当匹配成功时返回一个 Match 对象，其中： group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)； start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0； end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0； span([group]) 方法返回 (start(group), end(group))。 再看看一个例子： 1234567891011121314151617181920212223&gt;&gt;&gt; import re&gt;&gt;&gt; pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I) # re.I 表示忽略大小写&gt;&gt;&gt; m = pattern.match('Hello World Wide Web')&gt;&gt;&gt; print m # 匹配成功，返回一个 Match 对象&lt;_sre.SRE_Match object at 0x10bea83e8&gt;&gt;&gt;&gt; m.group(0) # 返回匹配成功的整个子串'Hello World'&gt;&gt;&gt; m.span(0) # 返回匹配成功的整个子串的索引(0, 11)&gt;&gt;&gt; m.group(1) # 返回第一个分组匹配成功的子串'Hello'&gt;&gt;&gt; m.span(1) # 返回第一个分组匹配成功的子串的索引(0, 5)&gt;&gt;&gt; m.group(2) # 返回第二个分组匹配成功的子串'World'&gt;&gt;&gt; m.span(2) # 返回第二个分组匹配成功的子串(6, 11)&gt;&gt;&gt; m.groups() # 等价于 (m.group(1), m.group(2), ...)('Hello', 'World')&gt;&gt;&gt; m.group(3) # 不存在第三个分组Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: no such group search 方法search 方法用于查找字符串的任何位置，它也是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果，它的一般使用形式如下： 1search(string[, pos[, endpos]]) 其中，string 是待匹配的字符串，pos 和 endpos 是可选参数，指定字符串的起始和终点位置，默认值分别是 0 和 len (字符串长度)。 当匹配成功时，返回一个 Match 对象，如果没有匹配上，则返回 None。 让我们看看例子： 1234567891011121314&gt;&gt;&gt; import re&gt;&gt;&gt; pattern = re.compile('\d+')&gt;&gt;&gt; m = pattern.search('one12twothree34four') # 这里如果使用 match 方法则不匹配&gt;&gt;&gt; m&lt;_sre.SRE_Match object at 0x10cc03ac0&gt;&gt;&gt;&gt; m.group()'12'&gt;&gt;&gt; m = pattern.search('one12twothree34four', 10, 30) # 指定字符串区间&gt;&gt;&gt; m&lt;_sre.SRE_Match object at 0x10cc03b28&gt;&gt;&gt;&gt; m.group()'34'&gt;&gt;&gt; m.span()(13, 15) 再来看一个例子： 123456789101112131415# -*- coding: utf-8 -*-import re# 将正则表达式编译成 Pattern 对象pattern = re.compile(r'\d+') # 使用 search() 查找匹配的子串，不存在匹配的子串时将返回 None # 这里使用 match() 无法成功匹配 m = pattern.search('hello 123456 789') if m: # 使用 Match 获得分组信息 print 'matching string:',m.group() print 'position:',m.span() 执行结果： 12matching string: 123456position: (6, 12) findall 方法上面的 match 和 search 方法都是一次匹配，只要找到了一个匹配的结果就返回。然而，在大多数时候，我们需要搜索整个字符串，获得所有匹配的结果。 findall 方法的使用形式如下： 1findall(string[, pos[, endpos]]) 其中，string 是待匹配的字符串，pos 和 endpos 是可选参数，指定字符串的起始和终点位置，默认值分别是 0 和 len (字符串长度)。 findall 以列表形式返回全部能匹配的子串，如果没有匹配，则返回一个空列表。 看看例子： 12345678import repattern = re.compile(r'\d+') # 查找数字result1 = pattern.findall('hello 123456 789')result2 = pattern.findall('one1two2three3four4', 0, 10)print result1print result2 执行结果： 12[&apos;123456&apos;, &apos;789&apos;][&apos;1&apos;, &apos;2&apos;] finditer 方法finditer 方法的行为跟 findall 的行为类似，也是搜索整个字符串，获得所有匹配的结果。但它返回一个顺序访问每一个匹配结果（Match 对象）的迭代器。 看看例子： 12345678910111213141516171819# -*- coding: utf-8 -*-import repattern = re.compile(r'\d+')result_iter1 = pattern.finditer('hello 123456 789')result_iter2 = pattern.finditer('one1two2three3four4', 0, 10)print type(result_iter1)print type(result_iter2)print 'result1...'for m1 in result_iter1: # m1 是 Match 对象 print 'matching string: &#123;&#125;, position: &#123;&#125;'.format(m1.group(), m1.span())print 'result2...'for m2 in result_iter2: print 'matching string: &#123;&#125;, position: &#123;&#125;'.format(m2.group(), m2.span()) 执行结果： 12345678&lt;type &apos;callable-iterator&apos;&gt;&lt;type &apos;callable-iterator&apos;&gt;result1...matching string: 123456, position: (6, 12)matching string: 789, position: (13, 16)result2...matching string: 1, position: (3, 4)matching string: 2, position: (7, 8) split 方法split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： 1split(string[, maxsplit]) 其中，maxsplit 用于指定最大分割次数，不指定将全部分割。 看看例子： 1234import rep = re.compile(r'[\s\,\;]+')print p.split('a,b;; c d') 执行结果： 1[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;] sub 方法sub 方法用于替换。它的使用形式如下： 1sub(repl, string[, count]) 其中，repl 可以是字符串也可以是一个函数： 如果 repl 是字符串，则会使用 repl 去替换字符串每一个匹配的子串，并返回替换后的字符串，另外，repl 还可以使用 \id 的形式来引用分组，但不能使用编号 0； 如果 repl 是函数，这个方法应当只接受一个参数（Match 对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。 count 用于指定最多替换次数，不指定时全部替换。 看看例子： 123456789101112import rep = re.compile(r'(\w+) (\w+)')s = 'hello 123, hello 456'def func(m): return 'hi' + ' ' + m.group(2)print p.sub(r'hello world', s) # 使用 'hello world' 替换 'hello 123' 和 'hello 456'print p.sub(r'\2 \1', s) # 引用分组print p.sub(func, s)print p.sub(func, s, 1) # 最多替换一次 执行结果： 1234hello world, hello world123 hello, 456 hellohi 123, hi 456hi 123, hello 456 subn 方法subn 方法跟 sub 方法的行为类似，也用于替换。它的使用形式如下： 1subn(repl, string[, count]) 它返回一个元组： 1(sub(repl, string[, count]), 替换次数) 元组有两个元素，第一个元素是使用 sub 方法的结果，第二个元素返回原字符串被替换的次数。 看看例子： 123456789101112import rep = re.compile(r&apos;(\w+) (\w+)&apos;)s = &apos;hello 123, hello 456&apos;def func(m): return &apos;hi&apos; + &apos; &apos; + m.group(2)print p.subn(r&apos;hello world&apos;, s)print p.subn(r&apos;\2 \1&apos;, s)print p.subn(func, s)print p.subn(func, s, 1) 执行结果： 1234(&apos;hello world, hello world&apos;, 2)(&apos;123 hello, 456 hello&apos;, 2)(&apos;hi 123, hi 456&apos;, 2)(&apos;hi 123, hello 456&apos;, 1) 其他函数事实上，使用 compile 函数生成的 Pattern 对象的一系列方法跟 re 模块的多数函数是对应的，但在使用上有细微差别。 match 函数match 函数的使用形式如下： 1re.match(pattern, string[, flags]): 其中，pattern 是正则表达式的字符串形式，比如 \d+, [a-z]+。 而 Pattern 对象的 match 方法使用形式是： 1match(string[, pos[, endpos]]) 可以看到，match 函数不能指定字符串的区间，它只能搜索头部，看看例子： 12345678910111213import rem1 = re.match(r'\d+', 'One12twothree34four')if m1: print 'matching string:',m1.group()else: print 'm1 is:',m1m2 = re.match(r'\d+', '12twothree34four')if m2: print 'matching string:', m2.group()else: print 'm2 is:',m2 执行结果： 12m1 is: Nonematching string: 12 search 函数search 函数的使用形式如下： 1re.search(pattern, string[, flags]) search 函数不能指定字符串的搜索区间，用法跟 Pattern 对象的 search 方法类似。 findall 函数findall 函数的使用形式如下： 1re.findall(pattern, string[, flags]) findall 函数不能指定字符串的搜索区间，用法跟 Pattern 对象的 findall 方法类似。 看看例子： 123456import reprint re.findall(r'\d+', 'hello 12345 789')# 输出['12345', '789'] finditer 函数finditer 函数的使用方法跟 Pattern 的 finditer 方法类似，形式如下： 1re.finditer(pattern, string[, flags]) split 函数split 函数的使用形式如下： 1re.split(pattern, string[, maxsplit]) sub 函数sub 函数的使用形式如下： 1re.sub(pattern, repl, string[, count]) subn 函数subn 函数的使用形式如下： 1re.subn(pattern, repl, string[, count]) 到底用哪种方式从上文可以看到，使用 re 模块有两种方式： 使用 re.compile 函数生成一个 Pattern 对象，然后使用 Pattern 对象的一系列方法对文本进行匹配查找； 直接使用 re.match, re.search 和 re.findall 等函数直接对文本匹配查找； 下面，我们用一个例子展示这两种方法。 先看第 1 种用法： 12345678import re# 将正则表达式先编译成 Pattern 对象pattern = re.compile(r'\d+')print pattern.match('123, 123')print pattern.search('234, 234')print pattern.findall('345, 345') 再看第 2 种用法： 12345import reprint re.match(r'\d+', '123, 123')print re.search(r'\d+', '234, 234')print re.findall(r'\d+', '345, 345') 如果一个正则表达式需要用到多次（比如上面的 \d+），在多种场合经常需要被用到，出于效率的考虑，我们应该预先编译该正则表达式，生成一个 Pattern 对象，再使用该对象的一系列方法对需要匹配的文件进行匹配；而如果直接使用 re.match, re.search 等函数，每次传入一个正则表达式，它都会被编译一次，效率就会大打折扣。 因此，我们推荐使用第 1 种用法。 匹配中文在某些情况下，我们想匹配文本中的汉字，有一点需要注意的是，中文的 unicode 编码范围 主要在 [\u4e00-\u9fa5]，这里说主要是因为这个范围并不完整，比如没有包括全角（中文）标点，不过，在大部分情况下，应该是够用的。 假设现在想把字符串 title = u&#39;你好，hello，世界&#39; 中的中文提取出来，可以这么做： 123456789# -*- coding: utf-8 -*-import retitle = u'你好，hello，世界'pattern = re.compile(ur'[\u4e00-\u9fa5]+')result = pattern.findall(title)print result 注意到，我们在正则表达式前面加上了两个前缀 ur，其中 r 表示使用原始字符串，u 表示是 unicode 字符串。 执行结果: 1[u&apos;\u4f60\u597d&apos;, u&apos;\u4e16\u754c&apos;] 贪婪匹配在 Python 中，正则匹配默认是贪婪匹配（在少数语言中可能是非贪婪），也就是匹配尽可能多的字符。 比如，我们想找出字符串中的所有 div 块： 1234567import recontent = 'aa&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;cc'pattern = re.compile(r'&lt;div&gt;.*&lt;/div&gt;')result = pattern.findall(content)print result 执行结果： 1[&apos;&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;&apos;] 由于正则匹配是贪婪匹配，也就是尽可能多的匹配，因此，在成功匹配到第一个 &lt;/div&gt; 时，它还会向右尝试匹配，查看是否还有更长的可以成功匹配的子串。 如果我们想非贪婪匹配，可以加一个 ?，如下： 1234567import recontent = 'aa&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;cc'pattern = re.compile(r'&lt;div&gt;.*?&lt;/div&gt;') # 加上 ?result = pattern.findall(content)print result 结果： 1[&apos;&lt;div&gt;test1&lt;/div&gt;&apos;, &apos;&lt;div&gt;test2&lt;/div&gt;&apos;] 小结 re 模块的一般使用步骤如下： 使用 compile 函数将正则表达式的字符串形式编译为一个 Pattern 对象； 通过 Pattern 对象提供的一系列方法对文本进行匹配查找，获得匹配结果（一个 Match 对象）； 最后使用 Match 对象提供的属性和方法获得信息，根据需要进行其他的操作； Python 的正则匹配默认是贪婪匹配。 参考资料 re模块]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之hashlib]]></title>
    <url>%2F2018%2F10%2F19%2Fpython%E6%A8%A1%E5%9D%97%E4%B9%8Bhashlib%2F</url>
    <content type="text"><![CDATA[一 什么是hashlib模块？hashlib模块是python用来加密的一个模块，hash是一种算法，可以提供SHA1、SHA224、SHA256、SHA384、SHA512、MD%算法，该算法接收传入的内容，经过运算得到一串hash值。 hash是一种算法，是将一个任意长度的数据，根据计算，得到一个固定长度的hash值。 经过hash算法会得到一串hash值，hash值得特点如下： 只要传入的内容一样，得到的hash值必然一样 —》》要用明文传输密码文件完整性校验 按理来说不能有hash值返解回原内容，但是破解md5使用撞库原理也变得不安全起来 只要使用的hash算法不变，无论校验的内容有多大，得到的hash值长度是固定的 hash算法就像一座工厂，工厂接收你送来的原材料，（可以使用m.update()为工厂增加材料），经过加工返回的产品就是hash值。 二 使用场景 密码验证 校验数据包 提升密码的复杂度 三 hashlib模块的使用 md5使用 123import hashlibm = hashlib.md5('musibii'.encode('utf-8'))print(m.hexdigest()) 12# 运行结果02797a3eebd7ef3054cd5c0e3a8c3199 其他几种加密 12345678910import hashlibh1 = hashlib.sha512("musibii".encode("utf-8"))h2 = hashlib.sha3_512("musibii".encode("utf-8"))# print(len(h.hexdigest()))print(h1.hexdigest())print(h2.hexdigest())# 运行结果458c46307cbe022bcd948462b2160c33f0821ea7c1d4ad0a9eb473a6448a850879c23075d6898f86f0093531ee33bde7565f0321ad516894071b73a5dc77626abfb5d77e45e99c5280bc1167113fe1e3666e350c6eac9475e66edb91c247e56fb014475c92f8140e601c2238f165a5cc14d5192ae5147acee4185476b65f613e 加盐 123456import hashlibm = hashlib.md5('musibii'.encode('utf-8'))m.update('thales'.encode('utf-8'))print(m.hexdigest())# 运行结果b2bb467965df30aaa14f677c3b3358d1 hmac加密 和MD5等算法没什么区别,主要的区别是必须加盐. 123456import hmach = hmac.new('musibii'.encode('utf-8'))h.update('thales'.encode('utf-8'))print(h.hexdigest())# 运行结果e26b77208fb858f7f8f78965f8ea4f47]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之logging]]></title>
    <url>%2F2018%2F10%2F19%2Fpython%E6%A8%A1%E5%9D%97%E4%B9%8Blogging%2F</url>
    <content type="text"><![CDATA[一 日志记录的重要性​ 在开发过程中，如果程序运行出现了问题，通常可以经过debug来检测到底是哪一步出现了问题，如果出现了问题的话，是比较容易排查出问题的。但是程序开发完成之后，部署到生产环境中去，这时候代码相当于是在一个黑盒环境下运行的，我们只能看到其运行的效果，是不能直接看到代码运行过程中的每一步状态的。在生产环境既不能通过debug来排查问题，更不能将生产环境下线来排查问题，所以这时候记录日志就很重要了。 ​ 如果我们现在只能得知当前问题的现象，而没有其他任何信息的话，如果想要解决掉这个问题的话，只能通过问题出现的形式来尝试重现bug，然后在一步一步的调试，这恐怕是难的，这样很大的概率是无法精准的复现这个问题的，而且debug的过程中也会耗费巨多的时间，这样如果在生产环境上出现了问题的话，修复bug就会变得非常棘手。但是如果有日志记录的话，不论是正常运行还是报错，都有相关的时间记录、状态记录、错误记录等，那么这样我们就可以方便的追踪到在当时的运行过程中出现了怎样的状况，从而可以快速的排查问题。 ​ 因此，作为开发者记录生产环境中代码运行的日志是很有必要的，因此学好怎么记录日志过程是一门必修课。 二 日志记录的流程框架在python中，怎样才能算做一个比较标准的日志记录呢？像我之前都是使用控制台查看结果或者debug查看运行状态的，对于一个小项目来说，debug已经足够了，但是对于一个大项目来说一步一步调试费时费力，而且得到的消息也不一定全面，如果自己可以定义输出的调试信息那么对于调试来讲是件很节省时间的事。 在python中专门有一个用来记录日志的模块logging，可以用它来进行标注的日志记录，利用它我们可以更方便的进行日志记录，同时还可以做更方便的级别区分以及一些额外的日志信息的记录，如时间、运行模块信息等。 那么完整的日志记录流程框架是什么样呢？ 如图所示，整个日志记录的框架可以分为这么几个部分： Logger：即Logger Main Class，是我们进行日志记录是创建的对象，可以调用Logger的方法传入日志模板和信息，来生成一条条日志记录，称作Log Record。 Log Record：就代指生成的一条条日志记录。 Handler：即用来处理日志记录的类，它可以将Log Record输出到我们指定的日志位置和存储形式等，如我们可以指定输入到具体的文件、或者可以指定将日志通过FTP协议记录到远程的服务器上，Handler就会帮我们完成这些事情。 Formatter：实际上生成的Log Record也是一个个对象，那么我们想要把它们保存成一条条我们想要的日志文本的话，就需要有一个格式化的过程，那么这个过程就有Formatter来完成，返回的就是日志字符串，然后传回给Handler来处理。 Filter：另外保存日志的时候我们可能不需要全部保存，只需要保存我们想要的部分就可以了，所以在保存的时候需要进一步过滤，留下想要的日志信息，如只保存某个级别的日志，那么这个过滤过程就可以交给Filter来完成。 Parent Handler：Handler之间可以存在分层关系，以使得不同Handler之间共享想通功能的代码。 这些就是整个logging模块的基本架构和对象功能。 三 日志记录的相关用法logging模块有如下几个优点： 可以在logging模块中设置日志等级，在不同的版本（如开发环境、生产环境）上通过设置不同的输出等级来记录相应的日志。 logging模块不仅可以把输出信息输出到控制台，还可以设置输出到任意位置，如写入文件、写入远程服务器等。 logging模块具有灵活的配置和格式化功能，如配置输出当前模块信息、运行时间等，相比print的字符串格式化更加方便易用。 四 日志记录的相关用法一 日志级别日志级别分为五个级别： 等级 数值 CRITICAL 50 FATAL 50 ERROR 40 WARNING 30 WARN 30 INFO 20 DEBUG 10 NOTSET 0 这里最高的等级是 CRITICAL 和 FATAL，两个对应的数值都是 50，另外对于 WARNING 还提供了简写形式 WARN，两个对应的数值都是 30。 我们设置了输出 level，系统便只会输出 level 数值大于或等于该 level 的的日志结果，例如我们设置了输出日志 level 为 INFO，那么输出级别大于等于 INFO 的日志，如 WARNING、ERROR 等，DEBUG 和 NOSET 级别的不会输出。 在logging模块中有对应的常量用来标识级别，默认情况下，默认的log级别是warning（30），默认输出到控制台。 二 自定义日志的配置12345678# test.pyimport logginglogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')logger = logging.getLogger(__name__)logger.info('log info')logger.debug('log debug')logger.warning('log warning')logger.critical('log critical') 在这里首先导入logging模块，然后进行了一下基本的配置，通过basicConfig配置了level级别和format格式化信息，level配置为INFO级别，只输出大于等于INFO级别的信息，format格式的字符串，包括asctime、name、levelname、message四个内容，分别代表运行时间、模块名称、日志级别、日志内容，这样输出内容便为这四个内容的信息了，这就是logging全局配置。 接下来声明了一个Logger对象，是日志输出的主类，调用对象的info()方法可以输出INFO级别的日志信息，调用debug()方法就可以输出DEBUG级别的日志信息，其他级别的日志信息同理可以输出。初始化logger时传入了name来代替传入模块的名称，如果直接运行该脚本则值为main,如果作为模块被import的话，则就是被导入模块的名称为test.py，因为在不同的模块中该值不同，所以直接使用name代替，然后输出了四条日志信息，其中有一条INFO信息，一条DEBUG信息，一条WARNING信息，一条CRITICAL信息，因为设置的level为INFO，所以低于INFO的级别日志会被过滤，所以DEBUG日志信息会被过滤。 三 basicConfig的具体参数basicConfig是用作全局的日志配置，basicConfig的参数有： filename：日志输出的文件名，如果指定了这个信息之后，不会使用默认的StreamHandler，会使用FileHandler来将日志信息输入到指定的文件中。 filemode：该参数为指定日志文件的写入方式，有两种形式，一种为w，一种为a，分别代表覆盖写入和追加写入。 format：指定日志信息的输出格式，即上文示例所示的参数，部分参数如下： %(levelno)s：打印日志级别的值； %(levelname)s：打印日志级别的名称； %(pathname)s：打印当前执行程序的路径，其实就是sys.argv[0]； %(filenam)s：打印当前执行程序名； %(funcName)s：打印日志的当前函数； %(lineno)s：打印日志的当前行号； %(asctime)s：打印日志的时间； %(thread)s：打印线程id； %(threadName)s：打印线程名称； %(process)s：打印进程id； %(processName)s：打印进程名称； %(module)s：打印模块名称； %(message)s：打印日志信息。 datefmt：指定时间的输出格式。 style：如果format参数制定了，这个参数就可以指定格式化时的占位符风格，如%、{、$等。 level：指定日志输出的类别，程序会输出大于等于此级别的信息。 stream：在没有指定filename的时候会默认使用StreamHandler，这时stream可以指定初始化的文件流。 handlers：可以指定日志处理时所使用的Handlers，必须是可迭代的。 四 Formatter配置在进行日志格式化输出的时候，我们可以不借助于basicConfig来全局配置格式化输出内容，可以借助Formatter来完成 Formatter用法： 123456789101112131415import logginglogger = logging.getLogger(__name__)logger.setLevel(level=logging.WARN)formatter = logging.Formatter(fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s', datefmt='%Y/%m/%d %H:%M:%S')handler = logging.StreamHandler()handler.setFormatter(formatter)logger.addHandler(handler)#loglogger.debug('debug')logger.critical('critical')logger.error('error')logger.warning('warning')logger.info('info') 在这里指定了一个Formatter，并传入fmt和datefmt参数，这样就指定了日志结果的输出格式和时间格式，然后Handler通过setFormatter()方法设置此Formatter对象即可，输出结果如下： 1232018/10/20 00:26:25 - __main__ - CRITICAL - critical2018/10/20 00:26:25 - __main__ - ERROR - error2018/10/20 00:26:25 - __main__ - WARNING - warning 这样可以为每个Handler单独配置输出的格式。 五 捕获Tracback异常信息遇到错误的时候，希望报错时出现详细的Tracback信息，便于我们调试，利用logging模块可以非常方便的实现这种需求。 1234567891011121314151617181920212223import logginglogger = logging.getLogger(__name__)logger.serLevel(level=logging.DEBUG)formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')file_handler = logging.FileHandler('test.log')file_handler.setFormatter(formatter)logger.addHandler(file_handler)stream_handler = logging.StreamHandler()stream_handler.setFormatter(formatter)logger.addHandler(stream_handler)logger.info('INFO')logger.warning('WARNING')try: num = 1/0except Exception: logger.error('something wrong', exc_info=True) logger.info('end') 这里在error()方法中添加了一个参数，将exc_info设置为True，这样就可以输出执行过程中的信息了，即可以输出完整的Tracback信息。 运行结果如下： 123456782018-10-20 00:36:38,007 - __main__ - INFO - INFO2018-10-20 00:36:38,007 - __main__ - WARNING - WARNING2018-10-20 00:36:38,007 - __main__ - ERROR - something wrongTraceback (most recent call last): File "/Users/jingxing/PycharmProjects/python全栈/day22/log_test.py", line 58, in &lt;module&gt; num = 1 / 0ZeroDivisionError: division by zero2018-10-20 00:36:38,007 - __main__ - INFO - end 这样可以详细的记录报错的信息，一旦出现了错误，可以及时的定位到出现问题的代码。 六 配置共享在写项目的时候，肯定会有许多的配置信息，如果每个文件都来配置logging的话非常麻烦，而且几乎很多地方的配置几乎差不多的，因为此原因，logging模块提供了父子模块共享配置的机制，会根据Logger的名称来自动加载父模块的配置。 定义一个main.py文件： 12345678910111213141516# main.pyimport loggingimport corelogger = logging.getLogger('main')logger.setLevel(level=logging.DEBUG)handler = logging.FileHandler('test.log')handler.setLevel(logging.INFO)formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - % (message)s')handler.setFormatter(formatter)logger.addHandler(handler)logging.info('main info')logging.debug('main debug')logging.error('main error')core.run() 在执行文件配置了日志的输出格式和文件路径，同时定义了Logger的名称为main，然后引入了另外一个模块core，最后调用了core的run()方法。 接下来定义core.py，内容如下： 12345678import logginglogger = logging.getLogger('main.core')def run(): logger.info('core info') logger.debug('core debug') logger.error('core error') 在core.py文件里定义了Logger的名称为main.core，因为之前在main.py文件里定义的Logger名称为main，所以core.py里面的Logger就会复用main.py里面的Logger配置，而不用重新为core配置日志了。 运行之后test.log结果如下： 1234562018-10-20 10:15:37,575 - main - INFO 2018-10-20 10:15:37,575 - main - DEBUG 2018-10-20 10:15:37,575 - main - ERROR 2018-10-20 10:15:37,575 - main.core - INFO 2018-10-20 10:15:37,575 - main.core - DEBUG 2018-10-20 10:15:37,575 - main.core - ERROR 可以看出main和core模块都是用了同样的输出配置。所以只要在入口文件里定义好logging模块的输出配置，子模块只需要在定义Logger对象时使用父模块的名称开头就可以共享配置，实际上直接使用父模块的名字就可以，但是为了增加辨识度，可以在父模块名字后加上后缀。 查看getLogger源码可得，后面的名字可以自定义，然后getLogger里面会自动帮你创建以该名字命名的日志生成器，具体解释如下： 1获取具有指定名称（通道名称）的记录器，如果它尚不存在则创建它。 此名称是以点分隔的分层名称，例如“a”，“a.b”，“a.b.c”或类似名称。如果指定名称存在PlaceHolder [即 loggerdid不存在，但它的子节点已经存在]，用createdlogger替换它，并修复指向占位符的父/子引用，现在指向记录器。 七 文件配置虽然可以再入口文件中定义好配置信息，然后子模块也可以使用很方便，但是因为配置文件大部分都是不需要更改的，只是某些需要更改，像这种信息可以把配置写入配置文件里，然后运行时读取配置文件里面的配置，这样更易维护和使用。 项目结构如下： 123456789# bin/start.pyimport os,syssys.path.append(os.path.dirname(os.path.dirname(__file__)))import core.shopdef run(): print("welcome to here") core.shop.shopping()run() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# conf/settingsstandard_format = "%(name)s %(asctime)s %(levelname)s %(module)s %(funcName)s %(lineno)s %(message)s"simple_format = "%(name)s %(asctime)s %(module)s %(message)s"complete_format = "%(asctime)s %(levelname)s %(funcName)s %(lineno)s %(thread)s %(process)s %(message)s"logfile_path = r"/Users/jingxing/PycharmProjects/python全栈/day23/log/d.log"LOGGING_DIC = &#123; 'version': 1, 'formatters': &#123; 'standard': &#123; 'format': standard_format &#125;, 'simple': &#123; 'format': simple_format &#125;, "complete":&#123; "format": complete_format &#125; &#125;, 'filters': &#123;&#125;, 'handlers': &#123; 'console': &#123; 'level': 'DEBUG', 'class': 'logging.StreamHandler', 'formatter': 'simple' &#125;, 'default': &#123; 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', 'formatter': 'standard', 'filename': logfile_path, # 'maxBytes': 1024 * 1024 * 5, # 日志文件的最大大小为5M 超出后 换文件 'backupCount': 5, # 最多留五个日志文件 'encoding': 'utf-8', &#125;, &#125;, 'loggers': &#123; # 在getLogger的时候 如果指定的名称 不存在 或者不给名称 用的就是默认的 # 在这里如果key为空 它就是默认的 # 你可以自己定义生成器的名称 并且他们还能使用相同的默认配置 '': &#123; 'handlers': ['default', 'console'], 'level': 'DEBUG', 'propagate': False, &#125;, &#125;,&#125; 1234567# core/shop.pyimport lib.commonlogger = lib.common.get_logger()def shopping(): print("开始购物") logger.debug("购物成功") 1234567# lib/common.pyimport conf.settingsimport logging.configdef get_logger(): logging.config.dictConfig(conf.settings.LOGGING_DIC) return logging.getLogger("main") 在代码运行后，在shop.py模块中导入了lib.common模块，在common.py模块中导入了conf.settings模块，来获取具体的日志配置，因为getLogger(‘main’)里面的main在settings里面没有，所以使用默认的日志配置，如下： 123456789'loggers': &#123; # 在getLogger的时候 如果指定的名称 不存在 或者不给名称 用的就是默认的 # 在这里如果key为空 它就是默认的 # 你可以自己定义生成器的名称 并且他们还能使用相同的默认配置 '': &#123; 'handlers': ['default', 'console'], 'level': 'DEBUG', 'propagate': False, &#125; 然后首先进行level=’DEBUG’的过滤，因为shopping中的日志信息级别为debug，所以会通过进入handlers里面进行第二次过滤，在handlers里面有两个配置，一个为default配置，一个味console配置，在default配置中，具体配置如下： 123456789'default': &#123; 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', 'formatter': 'standard', 'filename': logfile_path, # 'maxBytes': 1024 * 1024 * 5, # 日志文件的最大大小为5M 超出后 换文件 'backupCount': 5, # 最多留五个日志文件 'encoding': 'utf-8', &#125; 发现日志级别为DEBUG，所以仍然不会过滤，接下来就是格式化输出到指定文件了，formatter为standard模式，filename之前都已经定义好了，同理console同理输出到控制台。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之xml]]></title>
    <url>%2F2018%2F10%2F18%2Fpython%E6%A8%A1%E5%9D%97%E4%B9%8Bxml%2F</url>
    <content type="text"><![CDATA[xml模块 xml结构 xml是种实现不同语言或程序之间进行数据交换的协议，跟json差不多，但没json使用简单。但是因为历史遗留问题，至今很多行业依然使用xml这种数据格式。 xml的格式如下，是通过&lt;&gt;节点来区别数据结构的。 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;friendsinfo&gt; &lt;frd age="22" name="任盼晨"&gt; &lt;info qq="1114893928" wechat="Dmgwood" /&gt; &lt;/frd&gt; &lt;frd age="22" name="袁靖"&gt; &lt;info qq="2410152779" wechat="wxid_2vykc0sjoiie21" /&gt; &lt;/frd&gt; &lt;frd age="22" name="卫一帆"&gt; &lt;info qq="97280940" wechat="oOC" /&gt; &lt;/frd&gt; &lt;frd age="22" name="胡文涛"&gt; &lt;info qq="2522864970" wechat="hu2522864970" /&gt; &lt;/frd&gt;&lt;/friendsinfo&gt; 语法结构 任何的起始标签都必须有一个结束标签。 &lt;&gt; &lt;/&gt; 可以采用另一种简化语法，可以在一个标签中同时表示起始和结束标签。这种语法是在大于号之前紧跟一个斜杠(/)，例如，解析器会将其翻译成 标签必须按合适的顺序进行嵌套，所以结束标签必须按镜像顺序匹配起始标签。这好比将起始和结束标签看作是数学中的左右罗浩：在没有关闭所有的内部括号之前，是不能关闭外面括号的。 所有的特性都必须有值。 所有的特性都必须在值得周围加上双引号。 一个标签的组成部分包括：标签名、属性名以及属性值、还有文本内容（可以没有） 双标签的写法： 1&lt;tagename '属性名称'="属性值"&gt;文本内容&lt;/tagname&gt; 单标签的写法： 1&lt;tagename 属性名称="属性值"/&gt; 总结：xml也是一种中间格式，也属于序列化方式之一，与json比较，同样的数据json会更小，效率更高；xml需要根据文档结构手动解析，而json直接可以转为python数据对象。 xml模块用法 1234567891011121314151617181920212223# d.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;studentinfo&gt; &lt;stu age="20" name="张三"&gt; &lt;girlfriend age="19" name="张三的女朋友" /&gt; &lt;/stu&gt; &lt;stu age="20" name="李四"&gt; &lt;girlfriend age="19" name="李四的女朋友" /&gt; &lt;/stu&gt; &lt;age num="1"&gt; &lt;age num="2"&gt; &lt;age num="3"&gt; &lt;/age&gt; &lt;/age&gt; &lt;/age&gt; &lt;age&gt; &lt;/age&gt;&lt;/studentinfo&gt; 1234567891011121314151617181920212223242526import xml.etree.ElementTree as ElementTreetree = ElementTree.parse('d.xml')rootTree = tree.getroot()# 三种获取标签的方式# 1. 获取所有人的年龄，iter用于在全文范围获取标签for item in rootTree.iter('age'): # 一个标签三个组成部分 print(item.tag) # 标签名称 print(item.attrib) # 标签的属性 print(item.text) # 文本内容# 2. 从当前标签的子标签中找到一个名称为age的标签，如果有多个，找到的是第一个print(rootTree.find('age').attrib)# 3. 从当前标签的子标签中找到所有名称为age的标签print(rootTree.findall('age'))# 获取单个属性stu = rootTree.find('stu')print(stu.get("age"))print(stu.get("name"))# 删除子标签rootTree.remove(stu)# 添加子标签newTag = ElementTree.Element('这是新标签', &#123;'一个属性': '值'&#125;)rootTree.append(newTag)# 写入文件tree.write('f.xml', encoding='utf-8')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之configparser模块]]></title>
    <url>%2F2018%2F10%2F18%2Fpython%E4%B9%8Bconfigparser%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[一 什么是configparser？configparser是用于解析配置文件的模块。什么是配置文件呢？包含配置程序信息的文件就称为配置文件。什么样的数据应该作为配置信息呢？需要修改但是不经常改的信息就可以作为配置信息，比如数据文件的路径。 二 什么是配置文件？配置文件中只有两种内容： section，分区 option，选项，是键值对的形式 三 configparser的使用wiki12345678910# useinfo.cfg[user]name1 = musibiiname2 = thalesname3 = ddd[password]password1 = woshinibabapassword2 = 123456password3 = 123 1234567891011121314151617181920212223242526import configparser# 创建一个解析器config = configparser.ConfigParser()# 读取并解析cfg文件config.read('useinfo.cfg', encoding='utf-8')# 获取所有sectionprint(config.sections())# 获取某个分区下所有optionprint(config.options('user'))# 获取某个选项具体的值print(config.get('user', 'name1'))# get返回的都是字符串类型，如果需要转换类型，直接使用get+对应的类型(bool，int，float)print(config.getint('password', 'password1'))# 是否有某个选项，返回布尔值config.has_option()# 是否有某个分区config.has_section()# 不常用的一些方法# 添加分区(必须先添加分区才可以修改分区下面的值)config.add_section('server')config.set('server', 'usr', '192.168.1.1')# 删除选项config.remove_option('user', 'name1')# 写入文件with open('useinfo.cfg', 'wt', encoding='ust-8') as f: config.write(f) 使用例子: 1234# admin.cfg[admin]name=maffiapassword=woshinibaba 1234567891011121314# test.pyimport configparserconfig = configparser.ConfigParser()# 获取账号和密码信息def load_admin(): admin_info = [] config.read(admin.cfg, encoding='utf-8') sections = config.sections() for item in sections: user_dic = &#123;'name': config.get(item, 'name'), 'password': config.get(item, 'password')&#125; admin_info.append(user_dic) return admin_info]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之pickle、shelve、json]]></title>
    <url>%2F2018%2F10%2F17%2Fpython%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[一 什么是序列化序列化指的是将内存中的数据结构转化为一种中间格式，并存储到硬盘上。 （反序列化：将硬盘上存储的中间格式数据再还原为内存中的数据结构） 二 为什么要序列化 持久保持状态 需知一个软件/程序的运行就是处理一系列状态的变化，在编程语言中，‘状态‘会以各种有结构的数据类型(也可以称之为变量)的形式保存在内存中。 内存是无法永久保存数据的，当程序运行了一段时间，我们断电或者重启程序，内存中关于这个程序之前一段时间的数据都会被清空。 在断电或重启程序之前将程序当前运行的数据保存下来，便于下次程序执行能够从文件中载入之前的数据，然后继续执行，这就是序列化。 数据跨平台交互 序列化数据之后，不仅可以把序列化后的内容写入硬盘，还可以通过网络传输到别的机器上，如果收发的双方约定都使用一种序列化的格式，那么便打破了平台和语言带来的限制，实现了跨平台交互。 反过来，把变量内从从序列化的对象重新读到内存里称之为反序列化，即unpicking。 三 序列化数据的三个模块一 pickle模块pickle模块时python内置的用来序列化python数据格式的模块，支持序列化python中所有的数据类型，主要方法有四个； dumps 12345678import picklename = 'musibii'age = 18height = 1.7user = &#123;'name': name, 'age': age, 'height': height&#125;with open('userinfo.pkl', 'ab') as f: userbytes = pickle.dumps(user) f.write(userbytes) loads 12345import picklewith open('userinfo.pkl', 'rb') as f: userbytes = f.read() user = pickle.loads(userbytes) print(user) 与dumps和loads对应的两个方法更简单。 dump 123import picklewith open('userinfo.pkl', 'ab') as f: pickle.dump(user, f) load 1234import picklewith open('userinfo.pkl', 'rb') as f: user = pickle.load(f) print(user) 二 shelve模块shevlve模块也用于序列化，它和pickle模块不同的地方在于，不需要关心文件模式，直接把数据当成字典来看待。而且shelve模块可以直接对数据进行修改，而不用覆盖之前的数据，但pickle要想修改的话只能使用wb模式覆盖 shelve只有一个方法open，所以使用起来也很方便。同样的，shelve也支持python中所有的数据格式。 12345import shelveuser = &#123;'name': 'musibii'&#125;s = shelve.open('userdb.shv')s['user'] = users.close() 三 json模块1 json是什么JSON是Java script object notation的缩写，翻译过来就是js对象标识法。 对于开发者而言，json是一种通用的数据格式，任何语言都能解析，所以每种语言都会有处理json格式数据的需求。 json语法 js 中的数据类型 python数据类型 的对应关系 {} 字典 [] list string “” str int/float int/float true/false True/False null None json格式的语法规范 最外层通常是一个字典或列表 {}or[]，如果想定义json格式的数据，那么最外层直接写{}，而且json中的字符串必须是双引号，json理论上可以嵌套任意多的层次。 2 为什么用json虽然之前的pickle和shelve都很强大，而且使用也非常方便，那么为什么还出来json呢？这是因为pickle和shevle序列化之后的数据只有python才能解析出来，而通常在实际生产开发中，都是需要数据可以跨平台使用的。 3 json的使用json模块的核心方法 dump dumps load loads 不带s的直接封装了write和read方法。 dump 1234567891011121314import jsonjsontext = """&#123; "users": [&#123; "name": "musibii", "age": 18 &#125;, &#123; "name": "thales", "age": 23 &#125; ]&#125;"""with open('a.json', 'wt', encoding='utf-8') as f: json.dump(jsontext, f) dumps 1234567891011121314import jsonjsontext = """&#123; "users": [&#123; "name": "musibii", "age": 18 &#125;, &#123; "name": "thales", "age": 23 &#125; ]&#125;"""with open('a.json', 'wt', encoding='utf-8') as f: f.write(json.dumps(jsontext)) load 123import jsonwith open('a.json', 'rt', encoding='utf-8') as f: print(json.load(f)) loads 1234import jsonwith open('a.json', 'rt', encoding='utf-8') as f: res = json.loads(f.read()) print(res)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之shutil]]></title>
    <url>%2F2018%2F10%2F17%2Fpython%E6%A8%A1%E5%9D%97%E4%B9%8Bshutil%2F</url>
    <content type="text"><![CDATA[shutil是一个用于简化文件操作的模块。 复制文件（传入源文件对象和目标文件对象） 1234import shutilf1 = open(r'/Users/jingxing/PycharmProjects/day20/test.py', 'rb')f2 = open(r'/Users/jingxing/PycharmProjects/day20/test_test.py', 'rb')shutil.copyfileobj(f1, f2) 压缩文件 123import shutilshutil.make_archive('myzip', 'zip', r'/Users/jingxing/PycharmProjects/day20')shutil.make_archive('mytar', 'tar', r'/Users/jingxing/PycharmProjects/day20') 解压文件 123import shutilshutil.unpack_archive(r'/Users/jingxing/PycharmProjects/day20/myzip.zip')shutil.unpack_archive(r'/Users/jingxing/PycharmProjects/day20/mytar.tar') 其他两个用于解压的模块 zipfile从名字可以看出来是解压zip压缩文件的模块。 解压 1234import zipfilez = zipfile.ZipFile(r'/Users/jingxing/PycharmProjects/day20/myzip.zip', 'r')z.extractall(path=r'/Users/jingxing/PycharmProjects/day20')z.close() 往压缩包中添加文件 12345import zipfilez = zipfile.ZipFile(r"/Users/jingxing/PycharmProjects/python全栈/day20/代码/my压缩.tar","w")z.write("1.昨日回顾")z.write("2.今日内容")z.close() tarfile 解压 1234import tarfilet = tarfile.open(r"/Users/jingxing/PycharmProjects/python全栈/day20/代码/my压缩.tar","w")t.extractall(r"/Users/jingxing/PycharmProjects/python全栈/day19")t.close() 往压缩包中添加文件 12345port tarfilet = tarfile.open(r"/Users/jingxing/PycharmProjects/python全栈/day20/代码/my压缩.tar","w")t.add("1.昨日回顾")t.add("2.今日内容")t.close()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之random]]></title>
    <url>%2F2018%2F10%2F17%2Fpython%E6%A8%A1%E5%9D%97%E4%B9%8Brandom%2F</url>
    <content type="text"><![CDATA[python的随机数模块为random模块，可以产生随机的整数或浮点数。但是这是伪随机数，python解释器会维护一些种子数，然后根据算法算出随机数。linux维护了一个熵池，这个熵池收集噪音的信息，更接近真随机数。 random 随机产生0-1的浮点数，不包括1 123import randomprint(random.random())# 运行结果 0.8517652068795716 随机产生a-b的整数，包括a和b 12345import randoma = 1b = 10print(random.randint(a, b))# 运行结果 4 随机产生a-b，不包括a和b的整数 12345import randoma = 1b = 10print(random.randrange(a, b))# 运行结果 7 指定一个范围并指定需要产生的随机个数 123import randomprint(random.sample(['aa', ['a', 'b'], 3, 4, 5], 2))# 运行结果 [['a', 'b'], 5] 打乱列表的顺序（返回None） 12345import randomls = [1, 2, 3, 4, 5, 9, 11]random.shuffle(ls)print(ls)# 运行结果 [1, 9, 2, 5, 4, 11, 3] 从给定的序列中随机选一个 123import randomprint(random.choice([1,2,3,4,5,6]))# 运行结果 2 从给定的序列中随机选多个（包括1个，返回一个列表） 123import randomprint(random.choices((1,2,3,4,5,6,7), k=3))# 运行结果 [6, 5, 5] 制作随机验证码 12345678910import randomdef get_verifycode(length): res = '' for i in range(length): a = random.randint(0, 9) b = chr(random.randint(65, 90)) c = chr(random.randint(97, 122)) s = random.choice([a, b, c]) res += s return res]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之sys与os]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E4%B9%8Bsys%E4%B8%8Eos%2F</url>
    <content type="text"><![CDATA[python常用模块系列（二）：sys模块与os模块 sys模块是python解释器和环境有关的一个模块； os是python用来和操作系统进行交互的一个模块。 一 sys 查看当前环境变量 查看已经加载的模块 可以看出sys.modules是一个字典，key为加载模块的名字，values为加载模块的路径。 获取终端调用时的参数 终端输入的参数为argv[1]，默认当前文件名为第一个参数。 获取解释器的版本信息 获取当前运行平台名称（windows为nt，macOS为darwin） 退出信号 123import syssys.exit(0) # 正常退出sys.exit(1) # 错误退出 接口版本 123import sysprint(sys.api_version)# 运行结果 1013 了解 123456import sysprint(sys.maxsize)print(sys.maxunicode)# 运行结果# 9223372036854775807# 1114111 二 os 获取当前的工作目录 123import osprint(os.getcwd())# 运行结果 /Users/jingxing/PycharmProjects/python全栈/day20/代码 切换工作目录 1234import osprint(os.chdir('/Users/jingxing/PycharmProjects/python全栈'))print(os.getcwd())# 运行结果 /Users/jingxing/PycharmProjects/python全栈 获取当前目录 123import osprint(os.curdir)# 运行结果 . 获取上级目录 123import os print(os.pardir)# 运行结果 .. 获取系统的环境变量 123import osprint(os.environ)# environ(&#123;'PATH': '/Users/jingxing/.nvm/versions/node/v4.9.1/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/python_study/mongodb/bin://Volumes/python_study/mongodb/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/VMware Fusion.app/Contents/Public:/python_study/Applications/mongodb-osx-x86_64-3.6.3/bin::/usr/local/mysql/bin', 'COMMAND_MODE': 'unix2003', 'VERSIONER_PYTHON_VERSION': '2.7', 'LS_OPTIONS': '--color=auto', 'LOGNAME': 'jingxing', 'XPC_SERVICE_NAME': 'com.apple.xpc.launchd.oneshot.0x10000004.pycharm', 'PWD': '/Users/jingxing/PycharmProjects/python全栈/day20/代码', 'PYCHARM_HOSTED': '1', 'NODE_PATH': '/Users/jingxing/.nvm/versions/node/v4.9.1/lib/node_modules', 'PYCHARM_MATPLOTLIB_PORT': '49379', 'PYTHONPATH': '/Applications/PyCharm.app/Contents/helpers/pycharm_matplotlib_backend:/Users/jingxing/PycharmProjects/python全栈', 'NVM_CD_FLAGS': '', 'NVM_DIR': '/Users/jingxing/.nvm', 'SHELL': '/bin/bash', 'LSCOLORS': 'CxfxcxdxbxegedabagGxGx', 'PYTHONIOENCODING': 'UTF-8', 'SECURITYSESSIONID': '186a7', 'VERSIONER_PYTHON_PREFER_32_BIT': 'no', 'USER': 'jingxing', 'CLICOLOR': 'Yes', 'TMPDIR': '/var/folders/yl/3drd7wf93f90sfkgpc2zg9cr0000gn/T/', 'SSH_AUTH_SOCK': '/private/tmp/com.apple.launchd.bIB1b2eyOD/Listeners', 'XPC_FLAGS': '0x0', 'PYTHONUNBUFFERED': '1', '__CF_USER_TEXT_ENCODING': '0x1F5:0x19:0x34', 'Apple_PubSub_Socket_Render': '/private/tmp/com.apple.launchd.bHuC64fYdd/Render', 'LC_CTYPE': 'zh_CN.UTF-8', 'NVM_BIN': '/Users/jingxing/.nvm/versions/node/v4.9.1/bin', 'HOME': '/Users/jingxing', '__PYVENV_LAUNCHER__': '/Library/Frameworks/Python.framework/Versions/3.6/bin/python3'&#125;) 创建多级目录 123import osos.makedirs('a/b/c')# 会在当前文件路径创建多级目录 创建一个目录 123import osos.mkdir('aa')# 能且仅能创建一个目录 递归删除 123import osos.removedirs('a/b/c')# 递归删除，只能删除空目录 删除一个目录 123import osos.rmdir('aa')# 删除一个目录 删除文件 123import osos.remove(r'/Users/jingxing/PycharmProjects/python全栈')# 删除文件 列出当前目录所有的文件及文件夹 12import osprint(os.listdir(r'/Users/jingxing/PycharmProjects/python全栈')) 获取当前平台路径分隔符 123import osprint(os.seq)# 运行结果 / 获取当前平台换行符 12import osprint(os.lineseq, end='') 三 os下的path模块 返回绝对路径 123from os import pathprint(path.abspath('a/b/c'))# 运行结果 /Users/jingxing/PycharmProjects/python全栈/day20/代码/a/b/c 将路径拆分为文件夹路径和文件名（返回元祖） 123from os import pathprint(path.split('/Users/jingxing/PycharmProjects/python全栈/day20/代码/5.os下path模块.py'))# 运行结果 ('/Users/jingxing/PycharmProjects/python全栈/day20/代码', '5.os下path模块.py') 获取路径中的上一级 123from os import pathprint(path.dirname(__file__))# 运行结果 /Users/jingxing/PycharmProjects/python全栈/day20/代码 获取路径的最后一级名称 123from os import pathprint(path.basename(r'/Users/jingxing/PycharmProjects/python全栈/day20/代码/5.os下path模块.py'))# 运行结果 5.os下path模块.py 判断路径是否存在（返回布尔值） 123from os import pathprint path.exists(r'/Users/jingxing/PycharmProjects/python全栈/day20/代码/5.os下path模块.py')# 运行结果 True 判断是否为绝对路径（返回布尔值） 123from os import pathprint(path.isabs(r'/Users/jingxing/PycharmProjects/python全栈/day20/代码/5.os下path模块.py'))# 运行结果 True 路径拼接 123from os import pathprint(path.join('/Users/jingxing/PycharmProjects/', 'day20'))# 运行结果 /Users/jingxing/PycharmProjects/day20 获取文件的大小 12from os import pathprint(path.getsize(r'/Users/jingxing/PycharmProjects/python全栈')) 大写变小写，斜杠根据当前平台修改 123from os import pathprint(path.normcase(r'a/\b/\c'))# 运行结果 a/\b/\c 斜杠会修改为当前平台的分隔符，执行..来返回上一级 123from os import pathprint(path.normpath('a/b/c/../c'))# 运行结果 a/b/c]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python模块之time与datetime]]></title>
    <url>%2F2018%2F10%2F16%2FPython%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E4%B9%8Btime%E4%B8%8Edatetime%2F</url>
    <content type="text"><![CDATA[python常用模块系列（一）：time模块与datetime time模块是python内置查看当前时间戳的一个模块； datetime模块是用来对日期和时间进行操作的一个模块。 一 time1 获得时间戳时间戳：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行‘’type(time.time())‘’，返回的是float类型。 123import timeprint(time.time())# 运行结果 1539678307.779871 2 结构化时间字符串123import timeprint(time.localtime()) # 返回一个元祖对象，里面是每个时间的值(东八区)# 运行结果 time.struct_time(tm_year=2018, tm_mon=10, tm_mday=16, tm_hour=16, tm_min=48, tm_sec=4, tm_wday=1, tm_yday=289, tm_isdst=0) 123import timeprint(time.localtime().tm_year) # 单独获取某个时间属性# 运行结果 2018 123import timeprint(time.gmtime()) # 世界统一时间，比北京时间晚8小时# 运行结果 time.struct_time(tm_year=2018, tm_mon=10, tm_mday=16, tm_hour=8, tm_min=51, tm_sec=16, tm_wday=1, tm_yday=289, tm_isdst=0) 3 格式化的字符串时间123456import time print(time.strftime('%Y-%m-%d %H:%M:%S %p'))print(time.strftime('%Y-%m-%d %X %p'))# 运行结果 # 2018-10-16 16:54:56 PM# 2018-10-16 16:54:56 PM 4 三种格式之间的相互转换 时间戳转为结构化 123import timeprint(time.localtime(time.time()))# 运行结果 time.struct_time(tm_year=2018, tm_mon=10, tm_mday=16, tm_hour=16, tm_min=57, tm_sec=18, tm_wday=1, tm_yday=289, tm_isdst=0) 结构化转字符串 123import timeprint(time.strftime("%Y-%m-%d",time.localtime(time.time())))# 运行结果 2018-10-16 字符串转结构化 123import timeprint(time.strftime('2018-10-16', '%Y-%m-%d'))# 运行结果 time.struct_time(tm_year=2018, tm_mon=10, tm_mday=15, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=288, tm_isdst=-1) 结构化转时间戳 123import timeprint(time.mktime(time.strptime('2018-10-15', '%Y-%m-%d')))# 运行结果 1539532800.0 格林威治时间 123456import timeprint(time.asctime(time.localtime()))print(time.ctime())# 运行结果# Tue Oct 16 17:12:34 2018# Fri Jan 2 08:00:00 1970 二 datetimedatetime是一个包，里面包含对时间的处理和日期的处理 获取当前详细时间 123import datetimeprint(datetime.datetime.now())# 运行结果 2018-10-16 17:25:16.186114 获取时间的某一部分 123import datetimeprint(datetime.datetime.now().hour) # 分钟、年份等同理# 运行结果 17 替换时间的某一部分 12345import datetimet1 = date.datetime.now()t1 = t1.replace(year=2019)print(t1)# 运行结果 2019-10-16 18:36:42.166986 时间差对象 12345import datetimet2 = datetime.timedelta(weeks=1)t3 = datetime.datetime.now()print(t2 + t3)# 运行结果 2018-10-23 18:40:10.481854]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>内置模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件目录规范]]></title>
    <url>%2F2018%2F10%2F15%2F%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[随着功能的增多，代码逻辑也会越来越多，导致代码逻辑混乱不便于管理项目。为了解决这个问题，可以将相同功能的代码集合在一个文件夹，设置一个入口函数，一些设置文件放在一个文件，主要逻辑代码放一个文件夹。。。 这样对于整个业务有很好的可读性和扩展性。 对于之前的ATM+购物车项目最开始所有的逻辑代码都在一个文件，当我们需要修改某些函数时，遇到了一点困难，就是整个项目有600+行代码，而且什么都在里面，对于想快速具体的找到想修改的地方确实需要花费一些时间，效率低下。所以重新修改后，将具体功能代码放在一起，很明显逻辑清晰了，而且看的也很舒服。 如下为我的项目结构中的bin文件夹： bin目录下的start.py文件为启动函数，首先在启动函数里面导入os和sys模块，目的是为了将当前项目的根路径加入环境变量，接着导入相关函数和变量。该py文件仅仅作为程序的入口，里面没有逻辑代码。 如下为conf文件夹： conf是configuration的缩写，为配置的意思，里面只有settings文件，可以看出里面都是定义的一些变量，（在这里的变量其实应该使用大写的） 接下来是主要业务逻辑代码文件夹core（核心）： 里面有三个py文件，因为项目有三个主要功能，分别是ATM、SHOPP、USER，所以分了三个，里面的代码大同小异。 接下来是记录用户消费流水的文件夹，（db）里面也包括了用户信息，比如账号名、密码、余额、状态等信息。 这些信息文件在每一个账户登录时，会根据登录名创建一个文件，模式为追加，当退出时将数据刷入文件并关闭文件。 接下来为lib，lib是library的缩写，表示库的意思。里面只有common文件（里面可以放共用的一些功能代码或者第三方库） common文件里面是几个通用的功能函数，比如日志装饰器、读取用户所有信息的函数、、、 接下来为log文件夹，记录日志，哪个用户登陆了，做了什么事情都会记录下来（仔细想来，生活中我们在某些应用中做的事情是不是也会记录下来？答案是肯定的） 最后一个是README.md文件，通常是用来给用户看的，说明程序怎么使用，叫做帮助文档。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>包、文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块与包]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%2F</url>
    <content type="text"><![CDATA[一 什么是模块模块就是一组功能的集合体，可以通过导入模块来复用模块的功能。 比如我在同一个文件夹定义两个.py文件，分别命名为A.py和B.py，那么可以通过在A文件里通过import B来使用B文件里的名称空间。 python中，模块的使用方式都是一样的，可以分为四个通用类别： 使用python编写的.py文件 已被编译为共享库或DLL的C或C++扩展 把一系列模块组织到一起的文件夹（注：文件夹下有一个init.py文件，该文件夹称之为包） 使用C编写并链接到python解释器的内置模块 二 为何要使用模块 从文件级别组织程序，便于管理 随着需求的增多，功能也会越来越多，为了方便管理，通常将程序分成多个文件，这样项目的结构会更加清晰，方便管理。这时不仅仅可以把这些文件当做脚本去执行，还可以把他们当做模块来导入到其他的模块中，实现功能复用。 使用别人写好的模块，提高开发效率 使用别人已经写好的轮子，在自己的项目中使用，可以极大地提高开发效率。 注意：当退出python解释器的时候，重新进入那么之前定义的函数和变量都会丢失，因此通常将程序写到文件中以便永久保存，需要时可以在命令行通过python *.py方法执行。 1234567891011121314# test1.pyprint('from test1')money = 10def func1(): print('test1模块:', money) def func2(): print('test1模块') func1() def change(): global money money = 100 123# test2.pyimport test1test1.func1() 123# 运行结果from test1test1模块: 10 当在tes2t导入的时候会执行test1中的代码，所以首先会打印from test1接着执行test1中的func1函数。 三 使用模块之import1 import的使用模块可以包含可执行的语句和函数的定义，这些语句的目的是初始化模块，它们只在模块名第一次导入时才会执行（import语句可以在程序中的任意位置使用的，且针对同一个模块可以import多次，python为了防止重复导入，当第一次导入模块时就将模块的名称空间加载到内存了，后续的import语句仅是对已经加载到内存中的模块对象增加了一次引用，并不会重复执行模块内的语句） 12# test3print('from test3') 12345# test4import test3import test3import test3import test3 12# 运行结果from test3 ps:可以导入sys模块，调用sys.module查看当前加载到内存中的模块，sys.module是一个字典，内部包含模块名和模块名路径的对应关系。该字典决定了导入模块时是否需要重新导入。 2 导入模块时发生了什么运行py文件导入一个模块时，解释器做了三件事： 在执行文件中为被导入文件创建新的名称空间，在被导入模块中定义的函数和方法若是使用到了global时访问的就是这个名称空间。 在新创建的名称空间中执行模块中的包含的代码。函数定义也是‘’被执行‘’的语句，模块级别函数定义的执行将函数名放入模块全局名称空间表，可以用globals()可以查看。 在执行文件的名称空间创建被导入模块的名称来引用该名称空间。 这个名字和变量名没什么区别，都是‘’第一类‘’的，且使用句点表示法可以访问被导入模块的名称空间，导入的模块与被导入的模块是独立的两个名称空间。 3 被导入模块有独立的名称空间每个模块都是一个独立的名称空间，定义在这个模块中的函数，把这个模块的名称空间当做全局名称空间，这样就不用担心定义在不同的模块中全局变量在导入时与使用者的全局变量冲突。 测试1 1234# test5.pyimport test1money = 100print(test1.money) 123# 运行结果from test110 测试2 123456# test6import test1def func1(): print('from test6 func1')test1.func1()func1() 12345# 运行结果from test1test1模块: 10from test6 func1# 这说明 test6中的函数和test1中的函数不冲突 测试3 12345# test7import test1money = 1test1.change()print(money) 12345# 运行结果from test1test1模块: 101# 这说明test1中的change函数只是修改了test1中的全局变量，对test7中的变量没有操作权限 四 使用模块之from…import…1 from…import…与import …的区别区别就是：使用from…import…是将被导入模块中的名字直接导入到当前的名称空间中，所以在当前名称空间中，直接使用名字就可以了，不需要在前面加上模块名前缀。 from…import…导入方式的优缺点： 好处：使用方便 坏处：容易与当前执行文件的名字冲突 2 验证 验证1：当前位置直接使用test1中的函数名，执行时仍然以test1.py文件为全局名称空间 12345# 导入的函数func1，执行时仍然回到test1.py中寻找全局变量money# test8from test1 import func1money = 50func1() 123# 运行结果from test1test1模块: 10 123456# 导入的函数func2，执行时需要调用func1，仍然回到test1.py中找func1#test9.pyfrom test1 import func2def func1(): print('-----')func2() 1234# 运行结果from test1test1模块test1模块: 10 验证2：如果当前名称空间和被导入的模块中的名字重合，那么会覆盖掉前面的名字 123456# 导入的函数fun1,被当前位置定义的func1覆盖掉了# test10from test1 import func1def func1(): print('======')func1() 1234# 运行结果from test1======# 这说明func1把被导入名字func1覆盖掉了 123456# 当前位置定义的func1导入func1# test11def func1(): print('======')from test1 import func1func1() 1234# 运行结果from test1test1模块: 10# 这说明在后面导入的话会覆盖掉前面的 验证3：被导入的方法执行时，始终以源文件为准 12345# test12from test1 import money,func1money=100 #将当前位置的名字money绑定到了100print(money) #打印当前的名字func1() #读取spam.py中的名字money,仍然为1000 12345# 运行结果from the test100test1模块: 10# 可以看出运行func1的时候依然从原名称空间查找的 3 from … import *from … import * 是把被导入文件中所有不是以下划线(_)开头的名字都导入到当前名称空间。 大部分情况下不应该以这种导入方式，因为不知道被导入包中的名字是否会和当前名称空间中的名字重合造成名字覆盖。 解决方法是在被导入文件中使用all = []来控制被导入的名字，只有在all里面的才会被导入。 4 模块循环导入问题模块循环/嵌套导入抛出异常的根本原因是由于在python中模块被导入一次之后，就不会重新导入。 1234# test1.pyprint('正在导入1')from test2 import yx = '1' 1234# test2.pyprint('正在导入2')from test1 import xy = '2' 12# run.pyimport test1 1234567891011# 运行结果正在导入1正在导入2Traceback (most recent call last): File "/Users/jingxing/PycharmProjects/python全栈/day18/pack/run.py", line 6, in &lt;module&gt; import test1 File "/Users/jingxing/PycharmProjects/python全栈/day18/pack/test1.py", line 7, in &lt;module&gt; from test2 import y File "/Users/jingxing/PycharmProjects/python全栈/day18/pack/test2.py", line 8, in &lt;module&gt; from test1 import xImportError: cannot import name 'x' 分析：在run文件中执行导入test1，运行test1的代码，打印并且从test2中导入y，回到test2，打印并且从test1中导入，因为已经导入test1了（没导入完全，因为代码没执行完），所以直接找’x’，但因为在test1中的代码执行不下去，所以报错。执行文件不等于就完全导入文件了。 解决方法1：导入语句放在最后 解决方法2：导入语句放在函数中（因为在导入模块时，函数内的代码并不会执行，只会判断语法错误，所以这时候导入模块可以完全导入） 5 模块的重载考虑到性能的原因，每个模块只被导入一次，放入字典sys.module中，如果你改变了模块的内容，必须重启程序（python不支持重新加载或卸载之前导入的模块） 就算在修改已经导入的模块里面的代码对运行结果也没影响。 6 py文件区分两种用途：模块与脚本 脚本，一个文件就是整个程序，用来被执行 模块，文件中存放着一堆功能，用来被导入使用 python内置了全局变量name, 当文件被当做脚本执行时：name等于’main‘ 当文件被当做模块导入时：name等于模块名 作用：用来控制.py文件在不同的应用场景下执行不同的逻辑 12if __name__ == '__main__': pass 7 模块搜索路径模块的查找顺序是：内存中已经加载的模块–》内置模块–》sys.path路径中包含的模块 详细：在第一次导入某个模块式，会先检查该模块是否已经被加载到内存中（当前执行文件的名称空对应的内存），如果有则直接引用； ps:python解释器会在启动时自动加载一些模块到内存中，可以使用sys.module查看。 如果在内存中没有，解释器会查找同名的内建模块； 如果还没有则去sys.path给出的目录列表中查找。 了解：sys.path的初始化的值来自于： The directory containing the input script (or the current diretory whrn no files is specified). PYTHONPATH (a list of directory names, with the same syntax as the shell variable PATH). The installation-dependent default. 在初始化后，python程序可以修改sys.path，路径放在前面的优于标准库被加载。 搜索时按照sys.path中从左到右的顺序查找，位于前面的优先被查找，sys.path中还可能包含.zip归档文件和.egg文件，python会把.zip归档文件当成一个目录去处理。 .egg文件是setuptools创建的包，这是按照第三方python库和扩展时使用的一种常见格式，.egg文件实际上只是添加了额外元数据（如版本号，依赖项等）的.zip文件。 只能从.zip文件中导入.py，.pyc等文件。使用C编写的共享库和扩展块无法直接从.zip文件中加载（此时setuptools等打包系统有时能提供一种规避方法），且从.zip中加载文件不会创建.pyc或者.pyo文件，因此一定要事先创建他们，来避免加载模块是性能下降。 8 编译python文件为了提高加载模块的速度，强调强调强调：提高的是加载速度而绝非运行速度。python解释器会在pycache目录中下缓存每个模块编译后的版本，格式为：module.version.pyc。通常会包含python的版本号。例如，在CPython3.3版本下，spam.py模块会被缓存成pycache/spam.cpython-33.pyc。这种命名规范保证了编译后的结果多版本共存。 Python检查源文件的修改时间与编译的版本进行对比，如果过期就需要重新编译。这是完全自动的过程。并且编译的模块是平台独立的，所以相同的库可以在不同的架构的系统之间共享，即pyc使一种跨平台的字节码，类似于JAVA火.NET,是由python虚拟机来执行的，但是pyc的内容跟python的版本相关，不同的版本编译后的pyc文件不同，2.5编译的pyc文件不能到3.5上执行，并且pyc文件是可以反编译的，因而它的出现仅仅是用来提升模块的加载速度的，不是用来加密的。 五 包1 什么是包？包是一种通过’.模块名’来组织python模块名称的方式。 具体的：包就是一个包含有init.py文件的文件夹，所以其实我们创建包的目的就是为了用文件夹将文件/模块组织起来。 2 为何使用包？包的本质就是一个文件夹，文件夹的功能就是将同类型的文件组织起来。 其实使用包的原因和使用模块的原因是一样的，都是为了提高程序的结构性和可维护性。 3 注意事项 关于包相关的导入语句也分为import和from … import …两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入时带点的，点的左边都必须是一个包，否则非法。可以带有一连串的点，但都必须遵循这个原则。但对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。 import导入文件时，产生名称空间中的名字来源于文件，import 包，产生的名称空间的名字同样来源于文件，即包下的init.py，导入包本质就是在导入该文件 包A和包B下如果有同名模块也不会冲突，因为他们的名称空间是独立的。 4 绝对导入和相对导入包是写给别人用的，然而在包的内部也会有彼此之间互相导入的需求，这时候就有绝对导入和相对导入两种方式： 绝对导入：以包作为起点 相对导入：以.或..的方式作为起点（只能在一个包中使用，不能用于不同目录内） **包以及包所包含的模块都是用来被导入的，而不是直接执行的。而环境变量都是以执行文件为准。 5 绝对导入与相对导入总结12345678910111213绝对导入与相对导入# 绝对导入: 以执行文件的sys.path为起始点开始导入,称之为绝对导入# 优点: 执行文件与被导入的模块中都可以使用# 缺点: 所有导入都是以sys.path为起始点,导入麻烦# 相对导入: 参照当前所在文件的文件夹为起始开始查找,称之为相对导入# 符号: .代表当前所在文件的文件加,..代表上一级文件夹,...代表上一级的上一级文件夹# 优点: 导入更加简单# 缺点: 只能在导入包中的模块时才能使用 #注意: 1. 相对导入只能用于包内部模块之间的相互导入,导入者与被导入者都必须存在于一个包内 2. attempted relative import beyond top-level package # 试图在顶级包之外使用相对导入是错误的,言外之意,必须在顶级包内使用相对导入,每增加一个.代表跳到上一级文件夹,而上一级不应该超出顶级包]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名函数python内置高阶函数以及递归]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0python%E5%86%85%E7%BD%AE%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[匿名函数python定义一个函数通常使用def关键词，后面跟函数名，然后是注释、代码块等。 123def func(): '''注释''' print('from func') 这样就在全局命名空间定义了一个叫func的函数，func表示函数体的内存地址，因为func指向函数体内存地址，所以可以通过func来调用函数。 那么匿名函数呢？从名字就可看出，匿名。想想就有点像以前小时候的佚名一样，带点说不清楚的神秘色彩，现在想来之所以感觉神秘可能是因为那时候不认识‘’佚‘’这个字。。。 1234强调: 匿名函数的定义就相当于只产生一个变量在值,而没有绑定任何名字, 所以会在定义完之后就被回收,无法重复使用,只能在定义时使用一次应用:当某一个功能仅使用一次就没有再重复使用的必要了,就应该定义成匿名函数 言归正传，匿名和佚名一样没有名字或者不需要知道名字，对就是这么酷。 定义一个匿名函数使用lambda关键词，和def比较的话会发现其实定义逻辑很像。 1lambda x: x**2 定义的匿名函数的意思是参数为x，返回x的平方，返回？怎么没看到return？因为lambd引号后面的值默认返回，所以没必要加return了，但是我一定要加呢？就是这么不讲道理。那么解释器只好报错了，因为你不认同我的语法，那我也没必要惯着你了。就是这么拽。 匿名函数的使用场景通常为使用一次就结束了，不会频繁的使用。而且匿名函数通常和python里面自带的高阶函数结合使用，在某些应用场景下会达到事倍功半的效果哦。 高阶函数mapmap的意思是地图的意思，由此引申出映射表示一一对应。 翻译过来的意思是：创建一个迭代器，使用每个迭代的参数计算函数。 当最短的可迭代用尽时停止。 map函数有两个参数，第一个为某种规则的函数，第二个位多个可迭代对象。 12345def func(x): return x * 2lis = [1, 2, 3, 4, 5, 6]print(type(map(func, lis)))print(list(map(func, lis))) map函数把可迭代对象中的元素自动传给func，通过func的加工，得到一个生成器对象，通过list函数转化为一个列表。 当然，map函数可以接收多个可迭代对象，比如 123456def func(x, y): return x + ylis1 = [1,2,3,4,5,6]lis2 = [2,3,4,5,6,7,8,9,10,11]print(list(map(func, lis1,lis2)))# 结果为[3, 5, 7, 9, 11, 13] map函数会把后面迭代器对象中的元素迭代出来经过func加工，当最短的可迭代用尽是停止，所以只进行到6+7就结束了。 reducereduce是减少、合并的意思，会把可迭代对象中的元素经过函数的加工进而产生新的结果。 翻译过来就是：从左到右累加两个参数的函数到序列的项目，以便将序列减少为单个值。例如，reduce（lambda x，y：x + y，[1,2,3] ，4,5]计算（（（（（1 + 2）+3）+4）+5）。如果存在初始值，则将其放置在计算中序列的项之前，并在序列为空时用作默认值。 reduce函数有三个参数，函数和序列都是必须参数，初始值为可选参数。 应用：比如求1-100的和 12345from functools import reducedef func(x, y): return x+yprint(reduce(func, [i for i in range(1,101)]))# 结果为 5050 filterfilter的意思为过滤，通过函数的返回值对序列进行过滤。 翻译过来：返回一个迭代器，产生函数（item）为真的迭代项。 如果函数为None，则返回结果为真的项。 12345def func(x): return x.isdigit()lis = ['12', 'ad', '34', 'bc', '46']print(list(filter(func, lis)))# 结果为 ['12', '34', '46'] filter过滤结果为真的值放进迭代器中。 高阶函数和匿名函数map和匿名函数在之前map函数中的func参数都是定义了一个有名参数，然后用函数名传入map函数的，有了匿名函数就不用这么麻烦了。 123lis = [1, 2, 3, 4, 5, 6]print(list(map(lambda x: x*2, lis)))# 结果为 [2, 4, 6, 8, 10, 12] reduce和匿名函数12print(reduce(lambda x, y: x + y, [i for i in range(101)], 100))# 输出结果为 5050 filter和匿名函数12345678sala = &#123; 'MAC': 30000, 'iPhone': 9000, 'lenovo': 10000, 'xiaomi': 3000&#125;print(list(filter(lambda x: sala[x] &gt; 5000, sala)))# 输出结果为 [‘iPhone', 'lenovo'] 匿名函数的使用场景较为单一，一次性使用，随用随时定义。在某些场景下和高阶函数结合会提升效率，同时使代码更加简洁。 递归一 递归调用的定义递归调用时函数嵌套调用的一种特殊形式，函数在调用时，直接或间接地调用了自身，就是递归调用。 1234567891011121314151617181920# 直接调用自身def f1(): print('from f1') f1()f1()# 间接调用自身def f1(): print('from f1') f2()def f2(): print('from f1') f1()f2()# 调用函数会产生局部的名称空间，占用内存，因为上述这种调用会无限调用自身，python解释器的内存管理机制为了防止无限占用内存，对函数的递归调用做了层级限制，可以通过代码修改最大层级限制。import syssys.setrecursionlimit(100000) 二 递归调用的两个阶段递归调用包含两个明确的阶段：回溯，递推 回溯就是从外向里一层一层递归调用下去，回溯阶段必须要有一个明确的结束条件（不然会成为死循环），每进入下一次递归时，问题的规模都应该有所减少。 递推就是从里向外一层层结束递归。 递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈实现的，每当进入一个函数调用，在栈下面会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以递归调用次数过多，会导致栈溢出） 三 二分法从一个排序的数字列表中找到指定的数字，使用遍历的效率太低，使用二分法可以极大地缩小问题规模。 实现in的效果 123456789101112131415nums = [1,5,12,23,34,46,59,99,443]def fucn(num, nums): if len(nums) == 0: return mid_index = len(nums) // 2 if num &gt; nums[mid_index]: nums = nums[mid_index+1:] fucn(num, nums) elif num &lt; nums[mid_index]: nums = nums[:mid_index] fucn(num,nums) else: print('not exis') 实现index的效果 1234567891011121314151617181920212223nums = [1, 13, 15, 23, 27, 31, 33, 57, 73, 81, 93, 94, 97, 101] # 从小到大排列的数字列表def binary_search(find_num,nums): print(nums) if len(nums) == 0: print('not exists') return # 功能 mid_index = len(nums) // 2 if find_num &gt; nums[mid_index]: # in the right nums=nums[mid_index+1:] # 重新运行功能,传入新列表 binary_search(find_num,nums) elif find_num &lt; nums[mid_index]: # in the left nums=nums[:mid_index] # 重新运行功能,传入新列表 binary_search(find_num,nums) else: print('find it') binary_search(95,nums)]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符编码]]></title>
    <url>%2F2018%2F10%2F08%2F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[本来都以为自己完全弄懂字符编码了，昨天一个小问题给难倒了，思考了很久才得出答案，惭愧 字符编码的简介字符编码可以说每一种编程语言都会遇到的问题，为什么会有这么多的问题呢，就是因为计算机发展速度太快了，不仅计算机的诞生国要使用，第三世界国家也要使用，所以人和计算机的交流方式就变得复杂起来。像英语国家最简单，直接用一个字节也就是7bit，总共128种状态就可以满足交流需求；但是像中国等不以英语为第一母语的国家就会出很多问题了，但中文就有60000+个，那么很显然，7bit满足不了需求，所以为了满足需求，中国出了gb2312编码，不过gb2312也不能满足需求，所以又出来了gbk编码，可以表示60000+汉子。 虽然可以通过自己国家去规定本国的字符编码方式，可是这么多国家，每个国家都有自己的编码方式，那么跨过交流会变得困难起来。为了解决这种问题，在1990年开始起草unicode码，简称万国码。里面是一张超级大的对照表，包含了所有的编码集，比如：utf-8、shiftjis、gbk、iso-8859-1。既然包含这么多的对照表，那么每个国家都继续用自己的编码操作文件，但是在内存中都用unicode码，存的时候又根据unicode对照映射成自己国家的编码方式存储不就可以解决跨国交流的问题了嘛。 文本编辑器打开文件文本编辑器打开文件通常分为三步： 首先启动文本编辑器 文本编辑器将存储在硬盘中的文件读入内存 文本编辑器识别内存中文件的编码方式进而解码 第一步不用多解释了，重要在第二步和第三步。 硬盘中的文件会有一种编码方式，如下图 可以看出来有ASCII和UTF-8两种编码方式，所以当文本编辑器将它们读入内存中时，需要按照ASCII和UTF-8分别解码成unicode码（内存中默认编码都为unicode），第三步需要在显示屏上显示出来，那么需要将内存中的unicode码解码出来，那么这时候按照什么解码方式呢？如果我们没指定的话按照当前环境的编码方式，比如windows系统默认编码方式为gbk，类linux系统默认编码方式为utf-8。所以这就会出现问题了，假如在windows系统中读取utf-8编码方式的文件时 在windows下使用python2进行试验，定义了一个变量，并且是unicode编码的，当我分别是用utf-8和gbk对unicode编码时，然后打印发现utf-8码乱码了，这就说明在打印的时候会根据当前环境的编码方式进行解码，这和windows默认编码为gbk是相符的。 python中的编码在python中有两种编码：分别为文件编码以及运行代码时定义字符串的编码 第一种在前面解释了，总的来说一个文本编辑器从硬盘中读入文件时，第一步按照文件存储的编码解码为unicode码存入内存，然后根据文件头声明的编码解码（如果有文件头声明编码方式的话），否则就按照环境默认编码进行解码。 而python2和python3有很大的不同，python2默认编码为ascii，python3默认编码为utf-8，即python2编写的文件默认为ASCII编码，python3编写的文件默认为utf-8编码，但是读入内存中都需要解码为unicode。 第二种的话，在上幅图中为了演示，把字符串定义为unicode码，那么字符串前面不加’u’呢？ 按照我们之前的认识，ASCII识别不了中文，所以在print(a)时应该会报错才对啊，为什么不报错呢？这个应该是python2做的改变，当识别不了中文时，使用当前系统默认编码进行编码和解码，来证明一下，我使用linux做个试验就知道了。 真相大白了，python2这个改进不得不说挺机智的，因为历史遗留问题才导致python2的编码问题经过这样算是一种比较完美的解决方式。而完美的python3会有这种问题吗？怎么可能。python3是完美的。]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ssh免钥登陆github]]></title>
    <url>%2F2018%2F10%2F01%2Fgit-ssh%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[设置Git的user name和emai：（如果是第一次的话）$ git config --global user.name &#39;musibii&#39;$ git config --global user.email &#39;shaozuanzuan@gmail.com&#39; 生成秘钥$ ssh-keygen -t rsa -C &#39;shaozuanzuan@gmail.com&#39;从图上可以看到生成秘钥保存的地址，通常都会默认保存在家目录下面的.ssh下，前面加点表示是个隐藏目录。 添加秘钥到ssh-agentssh-agent是一个帮助程序，用于跟踪用户的身份密钥及其密码。 然后，代理可以使用密钥登录其他服务器，而无需用户再次键入密码或密码.运行ssh-agent之后，使用ssh-agent将私钥交给ssh-agent保管，其他程序需要身份验证的时候就可以将验证申请交给ssh-agent来完成整个认证过程。添加生成的ssh key到ssh-agent$ ssh-add ~/.ssh/id_rsa 登录github，添加ssh秘钥可以看到我有两个密钥，一个是macOS的，一个是Ubuntu的。 测试是否成功$ ssh -T git@github.com万万没想到，报错了。。。报错原因居然是没联网。。。靠北！！！重新联网成功了。。]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mac下配置github个人博客]]></title>
    <url>%2F2018%2F09%2F29%2FMac%E4%BD%BF%E7%94%A8Hexo%E9%85%8D%E7%BD%AEGItHub%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一 前言本来一直用博客园写博客的，奈何博客园界面惨不忍睹，而且自带的markdown编辑器更是烂的可以，于是在室友makeupstories的建议下开始尝试搭建自己的github博客，真是一路心酸啊！不过成就感也是大大滴。 二 准备工作创建Github域名和放博客的库 首先需要注册一个Github账号。 注册之后需要新建一个库(repository)来存储网站，点击首页任意位置出现的New repository按钮创建仓库，注意这个仓库名不能随便写。例如我的Github账号为musibii，那么库名为musibii.github.io。 安装Git、Nodejs和HexoHexo可以说是最流行的博客框架了，基于Nodejs，想要搭建好，需要安装Git、Nodejs和Hexo。 安装Git可以直接在命令行使用brew来安装Git$ brew install git 因为我之前已经安装了Git，所以这次给我安装了两个扩展包。 安装Nodejs为了便于管理Nodejs版本，首先安装nvm，这是Nodejs版本管理器，可以实现Nodejs多版本切换。$ curl -o- [https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh](https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh) | bash安装完成后，重启终端并执行下列命令即可安装Node.js$ nvm install \d后面跟的是Node.js的版本，今天就是被这个给坑了，应该安装较新的版本，之前安装的为 4，然后一直报错。$ nvm install 8安装后在终端输入$ nvm use node就会使用最新的nodejs版本了。 安装Hexo$ sudo npm install hexo-cli -g注意需要sudo权限，不然会出错 配置博客接下来需要使用Hexo来初始化一个博客，然后根据自己的需求更改一些自定义配置，比如字体、动画效果、主题等等。 创建博客为自己的博客创建一个文件夹，然后cd 文件夹，并执行下面的代码。$ hexo init username.github.io 更改主题 基础配置然后需要的就是在_config.yml里面修改个人信息，比如博客的主题、作者还有语言以及修改的主题名，最重要的是要和你的github仓库关联起来。其他的可以根据自己的需求酌情更改，比如我就增加了页面的动画效果Next主题动画效果 你的第一篇博客 $ hexo new &#39;你的博客名字&#39;执行完后会在‘username.github.io/source/_posts/‘目录下出现你的博客名字 博客使用markdown格式，编写完后执行$ hexo server如果出现下面的页面 在浏览器页面输入http://localhost:4000我的界面会和你们的不一样，出现了 Hello就说明成功了。 安装hexo-deployer-git –save自动部署发布工具$ npm install hexo-deployer-git --save 发布博客$ hexo deploy结束后进入博客就可以看见了！]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Hello,my name is musibii! Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
