<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面向对象编程]]></title>
    <url>%2F2018%2F10%2F22%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一 面向对象编程与面向过程编程1 面向过程编程思想该思想核心是过程，指的是解决问题的步骤，即先干什么然后干什么，就像流水线一样，必须一步一步来，基于面向过程编程的是一种机械化的思维方式。 优点： 复杂问题流程化，简单化； 缺点：可扩展性较差。 应用场景：一旦完成几乎不会改变，像Linux内核、git以及Apache HTTP Server等 2 面向对象编程思想随着硬件的快速发展，业务需求越来越复杂，以及编程应用领域越来越广泛，面向过程编程已经不能满足需求了，于是另一种编程思想开始兴起，就是面向对象编程。 该思想核心是对象，对象是特征与技能的结合体，基于面向对象设计程序就好比自己是造物主一样，想要创造什么就创造什么，与面向过程机械式的思维方式形成鲜明对比，面向对象更加注重对现实世界的抽象化。 优点：解决了程序的扩展性。对某一个对象单独修改，会立刻反应到整个体系中。 缺点：1. 编程的复杂度高于面向过程编程，不了解面向对象而立即上手基于对象设计程序，容易出现过度设计的问题。一些扩展性要求低的场景使用面向对象会增加编程难度。 无法向面向过程的程序设计流水式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题。 应用场景：需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等 面向对象的程序设计并不是全部。对于一个软件质量来说，面向对象的程序设计只是用来解决扩展性。 一个好的应用软件应包括的特性： 二 类与对象一 类的定义类即类别、种类，是面向对象设计最重要的概念，对象是特征与技能的结合体，而类则是一系列具有相似特征与技能的抽象概念。 在现实中是先出现对象，然后根据一系列具有相同特征的对象定义不同的类，对象是具体的存在，而类仅仅只是一个概念，并不真实存在。 在程序中是先定义类，然后根据类产生对象，这与函数的使用是类似的，先定义函数，类同理，在程序中需要先定义类，后调用类，与函数不一样的是，调用函数会执行函数体代码返回的是函数的执行结果，而调用类会产生并返回一个对象。 在程序中，务必保证，先定义类，后使用对象。 在程序中特征使用变量标识，技能使用函数标识。 因而类中最常见的是：变量和函数的定义。 1234567891011# 定义一个类class something: school = 'hashangda' def learn(self): print('something is learning') def eat(self): print('something is eating') def sleep(self): print('something is sleeping') 注意: 类中可以为任意python代码,这些代码在类定义阶段便会执行; 因而会产生新的名称空间,用来存放类的变量名与函数名,可以通过something.dict查看; 对于经典类来说可以通过该字典操作类名称空间的名字(新式类有限制),但python为我们提供了专门的语法进行访问; 点事访问属性的语法,类中定义的名字,都是类的属性(变量和函数). 二 程序中类的用法在程序中用.来访问类的属性,本质操作为dict 1234something.school # 等于经典类 something.__dict__['school']something.school = 'oldboy' # 等于经典类 something.__dict__['school'] = 'oldboy'something.name = 'musibii' # 等于经典类 something.__dict__['name'] = 'musibii'del something.name # 等于经典类 something.__dict__.pop('name') 在程序中调用类(实例化对象),产生并返回一个对象,产生的对象会具有类里面的属性,并且可以通过句点法进行访问. 总结: 类本质是一个名称空间,或者说是一个用来存放变量与函数的容器; 类的用途之一就是当做名称空间从其内部取出名字来使用; 类的主要用途是调用类产生对象. 三 对象的使用通过调用类产生的对象成为类的实例化,调用类的返回值称之为类的一个对象/实例. 123some = something() # 产生一个实例对象,对象可以通过句点法访问类中的属性()print(some.school)# 结果 hashangda 类中定义的属性是由该类产生的所有对象共有的属性,那么每个对象自己特有的属性应该怎么定义的? 1234567class something: school = 'hashangda' def __init__(self, name, age, gender): self.name = name self.age = age self.gender = gender 类中的init方法是用来初始化一个实例对象的,并且会执行下面的代码,所以这时候要实例化对象是需要传入后面的参数. 123some1 = something('musibii', 18, 'male')some2 = something('thales', 20, 'female')some3 = something('maffia', 22, 'male') 这样实例化出来的对象除了school属性值一样,其他都是自己独有的属性值. 调用类产生了 先产生一个空对象some1,然后返回; 触发类中函数init的执行,将对象联通调用类括号内指定的参数一同传入init. 总结:init的功能,在实例化时为对象初始化自己独有的特征(不能有返回值) 四 属性查找属性查找和之前学的名称空间查找顺序逻辑一样,首先在对象的名称空间里面查找,没有的话去类名称空间查找,但是不会去全局名称空间查找对象的属性. 类中定义的变量是所有对象共享的,对象可以使用,类也可以使用,类一旦改变自己的属性的值,所有的对象也会随之改变. 五 绑定方法类中定义的变量是类的数据属性,类和对象都可以使用,并且属性的值都指向一个内存地址; 类中定义的函数是类的函数属性,类和对象都可以调用,类来调用的就是一个普通的函数,但类中定义的函数都是用来给对象用的,而且是绑定给对象的. 类的函数:该传几个参数就传几个 绑定方法,指向类的函数:特殊之处是绑定给哪个对象就应该由哪个对象来调用,调用的时候就会把对象本身当做第一个参数自动传入. 六 一切皆对象在python3中统一了类和类型的概念,就是说一个类等于一种类型,比如python中的数据类型,我们也可以定义属于自己的类 12345class muSibii: passmusibii = muSibii()print(type(musibii))# 结果 &lt;class '__main__.muSibii'&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一首沉下来特别好听的歌]]></title>
    <url>%2F2018%2F10%2F19%2F%E4%B8%80%E9%A6%96%E6%B2%89%E4%B8%8B%E6%9D%A5%E7%89%B9%E5%88%AB%E5%A5%BD%E5%90%AC%E7%9A%84%E6%AD%8C%2F</url>
    <content type="text"><![CDATA[最近一直在单曲循环 腰乐队的《一个短篇》 《一个短篇》 作词：刘弢 作曲：杨绍昆 旋转 跳跃喔 他感到每条路都在头痛 新鲜的帕特里克满脑子 都是开拓的自慰器 那些男人爱的男人爱市政 市政爱市民 市民爱流连 旋转 跳跃喔 他感到飞鸟们也在头痛 冒牌的帕特里克满脑子 都是稳妥的独角戏 那些男孩爱的男人爱机器 机器爱法律 法律是你 深夜里辛蒂蕾拉们倒下的地方 促成整片血红的高楼 在搞与不搞之间泛起淡淡的哀伤 他的来头已经腐朽 别担心没有哪一首歌能够 把这个现实唱到地狱去 当你还能享有这种静默我的老爷 这烂摊就不会收场 旋转 跳跃吧 他感到连晚风也在头痛 狗娘养的帕特里克满脑子 关于体态的滑翔机 他说过那些女人爱的男人爱萝莉 萝莉爱包包 包包爱货币 他在高级堡垒的方针里走出 带来大会的消息 在幼犬和地皮商的征程里 他是发达的肯定句 等他和他们 他们和所有人之间 都搞不来信任的时候 只要冬和她的姨妈 从没有熄灯的窗口 无声眺望 这夜派对 就要散场 这夜派对 就要散场 这夜派对 就要散场 这夜派对 就要散场 幽暗的最高频道还在 为全城遮盖下一百年的昂贵谜底 他倚靠在令人害羞的礼品堆里 冉冉睡去 幽暗的最高频道还在 为全城遮盖下一百年的昂贵谜底 他依靠在令人害羞的礼品堆里 冉冉睡去 幽暗的最高频道还在 为全城遮盖下一百年的昂贵谜底 他依靠在令人害羞的礼品堆里 冉冉睡去]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>呐喊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机硬件基础]]></title>
    <url>%2F2018%2F10%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一 计算机基本组成目前市面上的计算机几乎都是冯诺依曼体系计算机，冯·诺依曼计算机使用冯诺依曼体系机构的电子数字计算机。1945年6月，冯·诺依曼提出了在数字计算机内部的存储器中存放程序的概念，这是所有现代电子计算机的末班，被称为“冯·诺依曼结构”，按照这种结构构造的电脑称为存储程序计算机，又称为通用计算机。 冯·诺依曼体系的计算机的特点是：程序以二进制代码的形式存放在存储器中；所有的指令都是由操作码和地址码组成；指令在其存储过程中按照执行的顺序进行存储；以运算器和控制器作为计算机结构的中心等。冯诺依曼计算机广泛应用于数据的处理和控制方面。 冯诺依曼理论的要点是：数字计算机的数制采用二进制；计算机应该按照程序顺序执行。 根据冯诺依曼体系结构组成的计算机，必须具有如下功能： 把需要的程序和数据送至计算机中。 必须具有长期记忆程序、数据、中间结果及最终运算结果的能力。 能够完成各种算术、逻辑运算和数据传送等数据加工处理的能力。 能够根据需要控制程序走向，并能根据指令控制机器的各部件协调操作。 能够按照要求将处理结果输出给用户。 为了完成以上功能，计算机必须具备以下五大基本组成部件： 控制器：计算机的指挥系统。控制器通过数据地址来访问存储器，从存储器中取出指令，经过编译器编译或解释器解释后，根据结果得出相应的操作信号并作用于其他部件，使得各部件在控制器的严格控制下互相协调的工作。 运算器：实现算术运算和逻辑运算的部件。 存储器：计算机用来存储所有数据和程序的记忆部件。它的基本功能是按照指定的存储地址存（写）入或取（读）出数据。 输入设备：是向计算机中输入信息（程序、数据、声音、文字、图形、图像等）的设备。常见的输入设备有：键盘、鼠标、图形扫描仪、触摸屏等。 输出设备：主要有显示器、打印机和绘图仪等。 现代计算机将上述五大部分分为三大核心部件： CPU（控制单元+算数逻辑单元） 主存储器 输入输出设备 这几个部件的相关性如下： 二 编程与计算机硬件的关系为了使计算机能够理解人的意图，人类就必须将需要解决的问题的思路、方法和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人与计算机体系之间交流的过程就是编程。 编写的程序经过译码器分析后得到的是一大堆的二进制指令，这些指令通过CPU读取从而产生相应的操作控制信号作用于其他的硬件上，从而完成相应的功能。 三 内存容量单位的换算1Byte=8bit 1KB=1024Bytes 1MB=1024KB 1GB=1024MB 有的生产厂家的换算单位为1000。 四 CPU位数关系现在市面上的计算机主要分为32位和64位两种规格，他们之间的区别主要为以下四点： 处理数据能力不同 支持的内存不同（寻址不同） 架构不同 对配置的要求不同 五 操作系统基础 操作系统是什么？ 操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在‘裸机’上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是一个协调\管理\控制计算机硬件资源与软件资源的一个控制程序。 为什么要有操作系统？ 操作系统是用户和计算机硬件的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，改善人机界面，为其他应用软件提供支持，让计算机系统所有资源最大限度的发挥作用，提供各种形式的用户界面，使用户有一个好的工作环境，为其他软件的开发提供必要的服务和相应的接口等。实际上，用户是不用接触操作系统的，操作系统管理着计算机的硬件资源，同时按照应用程序的资源请求来分配资源，如：划分CPU时间、内存空间的开辟、调用打印机等。 操作系统就是为了让使用者更加方便的使用计算机硬件资源和软件资源的一个工具。]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python模块之re]]></title>
    <url>%2F2018%2F10%2F19%2Fpython%E6%A8%A1%E5%9D%97%E4%B9%8Bre%2F</url>
    <content type="text"></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之hashlib]]></title>
    <url>%2F2018%2F10%2F19%2Fpython%E6%A8%A1%E5%9D%97%E4%B9%8Bhashlib%2F</url>
    <content type="text"><![CDATA[一 什么是hashlib模块？hashlib模块是python用来加密的一个模块，hash是一种算法，可以提供SHA1、SHA224、SHA256、SHA384、SHA512、MD%算法，该算法接收传入的内容，经过运算得到一串hash值。 hash是一种算法，是将一个任意长度的数据，根据计算，得到一个固定长度的hash值。 经过hash算法会得到一串hash值，hash值得特点如下： 只要传入的内容一样，得到的hash值必然一样 —》》要用明文传输密码文件完整性校验 按理来说不能有hash值返解回原内容，但是破解md5使用撞库原理也变得不安全起来 只要使用的hash算法不变，无论校验的内容有多大，得到的hash值长度是固定的 hash算法就像一座工厂，工厂接收你送来的原材料，（可以使用m.update()为工厂增加材料），经过加工返回的产品就是hash值。 二 使用场景 密码验证 校验数据包 提升密码的复杂度 三 hashlib模块的使用 md5使用 123import hashlibm = hashlib.md5('musibii'.encode('utf-8'))print(m.hexdigest()) 12# 运行结果02797a3eebd7ef3054cd5c0e3a8c3199 其他几种加密 12345678910import hashlibh1 = hashlib.sha512("musibii".encode("utf-8"))h2 = hashlib.sha3_512("musibii".encode("utf-8"))# print(len(h.hexdigest()))print(h1.hexdigest())print(h2.hexdigest())# 运行结果458c46307cbe022bcd948462b2160c33f0821ea7c1d4ad0a9eb473a6448a850879c23075d6898f86f0093531ee33bde7565f0321ad516894071b73a5dc77626abfb5d77e45e99c5280bc1167113fe1e3666e350c6eac9475e66edb91c247e56fb014475c92f8140e601c2238f165a5cc14d5192ae5147acee4185476b65f613e 加盐 123456import hashlibm = hashlib.md5('musibii'.encode('utf-8'))m.update('thales'.encode('utf-8'))print(m.hexdigest())# 运行结果b2bb467965df30aaa14f677c3b3358d1 hmac加密 和MD5等算法没什么区别,主要的区别是必须加盐. 123456import hmach = hmac.new('musibii'.encode('utf-8'))h.update('thales'.encode('utf-8'))print(h.hexdigest())# 运行结果e26b77208fb858f7f8f78965f8ea4f47]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之logging]]></title>
    <url>%2F2018%2F10%2F19%2Fpython%E6%A8%A1%E5%9D%97%E4%B9%8Blogging%2F</url>
    <content type="text"><![CDATA[一 日志记录的重要性​ 在开发过程中，如果程序运行出现了问题，通常可以经过debug来检测到底是哪一步出现了问题，如果出现了问题的话，是比较容易排查出问题的。但是程序开发完成之后，部署到生产环境中去，这时候代码相当于是在一个黑盒环境下运行的，我们只能看到其运行的效果，是不能直接看到代码运行过程中的每一步状态的。在生产环境既不能通过debug来排查问题，更不能将生产环境下线来排查问题，所以这时候记录日志就很重要了。 ​ 如果我们现在只能得知当前问题的现象，而没有其他任何信息的话，如果想要解决掉这个问题的话，只能通过问题出现的形式来尝试重现bug，然后在一步一步的调试，这恐怕是难的，这样很大的概率是无法精准的复现这个问题的，而且debug的过程中也会耗费巨多的时间，这样如果在生产环境上出现了问题的话，修复bug就会变得非常棘手。但是如果有日志记录的话，不论是正常运行还是报错，都有相关的时间记录、状态记录、错误记录等，那么这样我们就可以方便的追踪到在当时的运行过程中出现了怎样的状况，从而可以快速的排查问题。 ​ 因此，作为开发者记录生产环境中代码运行的日志是很有必要的，因此学好怎么记录日志过程是一门必修课。 二 日志记录的流程框架在python中，怎样才能算做一个比较标准的日志记录呢？像我之前都是使用控制台查看结果或者debug查看运行状态的，对于一个小项目来说，debug已经足够了，但是对于一个大项目来说一步一步调试费时费力，而且得到的消息也不一定全面，如果自己可以定义输出的调试信息那么对于调试来讲是件很节省时间的事。 在python中专门有一个用来记录日志的模块logging，可以用它来进行标注的日志记录，利用它我们可以更方便的进行日志记录，同时还可以做更方便的级别区分以及一些额外的日志信息的记录，如时间、运行模块信息等。 那么完整的日志记录流程框架是什么样呢？ 如图所示，整个日志记录的框架可以分为这么几个部分： Logger：即Logger Main Class，是我们进行日志记录是创建的对象，可以调用Logger的方法传入日志模板和信息，来生成一条条日志记录，称作Log Record。 Log Record：就代指生成的一条条日志记录。 Handler：即用来处理日志记录的类，它可以将Log Record输出到我们指定的日志位置和存储形式等，如我们可以指定输入到具体的文件、或者可以指定将日志通过FTP协议记录到远程的服务器上，Handler就会帮我们完成这些事情。 Formatter：实际上生成的Log Record也是一个个对象，那么我们想要把它们保存成一条条我们想要的日志文本的话，就需要有一个格式化的过程，那么这个过程就有Formatter来完成，返回的就是日志字符串，然后传回给Handler来处理。 Filter：另外保存日志的时候我们可能不需要全部保存，只需要保存我们想要的部分就可以了，所以在保存的时候需要进一步过滤，留下想要的日志信息，如只保存某个级别的日志，那么这个过滤过程就可以交给Filter来完成。 Parent Handler：Handler之间可以存在分层关系，以使得不同Handler之间共享想通功能的代码。 这些就是整个logging模块的基本架构和对象功能。 三 日志记录的相关用法logging模块有如下几个优点： 可以在logging模块中设置日志等级，在不同的版本（如开发环境、生产环境）上通过设置不同的输出等级来记录相应的日志。 logging模块不仅可以把输出信息输出到控制台，还可以设置输出到任意位置，如写入文件、写入远程服务器等。 logging模块具有灵活的配置和格式化功能，如配置输出当前模块信息、运行时间等，相比print的字符串格式化更加方便易用。 四 日志记录的相关用法一 日志级别日志级别分为五个级别： 等级 数值 CRITICAL 50 FATAL 50 ERROR 40 WARNING 30 WARN 30 INFO 20 DEBUG 10 NOTSET 0 这里最高的等级是 CRITICAL 和 FATAL，两个对应的数值都是 50，另外对于 WARNING 还提供了简写形式 WARN，两个对应的数值都是 30。 我们设置了输出 level，系统便只会输出 level 数值大于或等于该 level 的的日志结果，例如我们设置了输出日志 level 为 INFO，那么输出级别大于等于 INFO 的日志，如 WARNING、ERROR 等，DEBUG 和 NOSET 级别的不会输出。 在logging模块中有对应的常量用来标识级别，默认情况下，默认的log级别是warning（30），默认输出到控制台。 二 自定义日志的配置12345678# test.pyimport logginglogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')logger = logging.getLogger(__name__)logger.info('log info')logger.debug('log debug')logger.warning('log warning')logger.critical('log critical') 在这里首先导入logging模块，然后进行了一下基本的配置，通过basicConfig配置了level级别和format格式化信息，level配置为INFO级别，只输出大于等于INFO级别的信息，format格式的字符串，包括asctime、name、levelname、message四个内容，分别代表运行时间、模块名称、日志级别、日志内容，这样输出内容便为这四个内容的信息了，这就是logging全局配置。 接下来声明了一个Logger对象，是日志输出的主类，调用对象的info()方法可以输出INFO级别的日志信息，调用debug()方法就可以输出DEBUG级别的日志信息，其他级别的日志信息同理可以输出。初始化logger时传入了name来代替传入模块的名称，如果直接运行该脚本则值为main,如果作为模块被import的话，则就是被导入模块的名称为test.py，因为在不同的模块中该值不同，所以直接使用name代替，然后输出了四条日志信息，其中有一条INFO信息，一条DEBUG信息，一条WARNING信息，一条CRITICAL信息，因为设置的level为INFO，所以低于INFO的级别日志会被过滤，所以DEBUG日志信息会被过滤。 三 basicConfig的具体参数basicConfig是用作全局的日志配置，basicConfig的参数有： filename：日志输出的文件名，如果指定了这个信息之后，不会使用默认的StreamHandler，会使用FileHandler来将日志信息输入到指定的文件中。 filemode：该参数为指定日志文件的写入方式，有两种形式，一种为w，一种为a，分别代表覆盖写入和追加写入。 format：指定日志信息的输出格式，即上文示例所示的参数，部分参数如下： %(levelno)s：打印日志级别的值； %(levelname)s：打印日志级别的名称； %(pathname)s：打印当前执行程序的路径，其实就是sys.argv[0]； %(filenam)s：打印当前执行程序名； %(funcName)s：打印日志的当前函数； %(lineno)s：打印日志的当前行号； %(asctime)s：打印日志的时间； %(thread)s：打印线程id； %(threadName)s：打印线程名称； %(process)s：打印进程id； %(processName)s：打印进程名称； %(module)s：打印模块名称； %(message)s：打印日志信息。 datefmt：指定时间的输出格式。 style：如果format参数制定了，这个参数就可以指定格式化时的占位符风格，如%、{、$等。 level：指定日志输出的类别，程序会输出大于等于此级别的信息。 stream：在没有指定filename的时候会默认使用StreamHandler，这时stream可以指定初始化的文件流。 handlers：可以指定日志处理时所使用的Handlers，必须是可迭代的。 四 Formatter配置在进行日志格式化输出的时候，我们可以不借助于basicConfig来全局配置格式化输出内容，可以借助Formatter来完成 Formatter用法： 123456789101112131415import logginglogger = logging.getLogger(__name__)logger.setLevel(level=logging.WARN)formatter = logging.Formatter(fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s', datefmt='%Y/%m/%d %H:%M:%S')handler = logging.StreamHandler()handler.setFormatter(formatter)logger.addHandler(handler)#loglogger.debug('debug')logger.critical('critical')logger.error('error')logger.warning('warning')logger.info('info') 在这里指定了一个Formatter，并传入fmt和datefmt参数，这样就指定了日志结果的输出格式和时间格式，然后Handler通过setFormatter()方法设置此Formatter对象即可，输出结果如下： 1232018/10/20 00:26:25 - __main__ - CRITICAL - critical2018/10/20 00:26:25 - __main__ - ERROR - error2018/10/20 00:26:25 - __main__ - WARNING - warning 这样可以为每个Handler单独配置输出的格式。 五 捕获Tracback异常信息遇到错误的时候，希望报错时出现详细的Tracback信息，便于我们调试，利用logging模块可以非常方便的实现这种需求。 1234567891011121314151617181920212223import logginglogger = logging.getLogger(__name__)logger.serLevel(level=logging.DEBUG)formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')file_handler = logging.FileHandler('test.log')file_handler.setFormatter(formatter)logger.addHandler(file_handler)stream_handler = logging.StreamHandler()stream_handler.setFormatter(formatter)logger.addHandler(stream_handler)logger.info('INFO')logger.warning('WARNING')try: num = 1/0except Exception: logger.error('something wrong', exc_info=True) logger.info('end') 这里在error()方法中添加了一个参数，将exc_info设置为True，这样就可以输出执行过程中的信息了，即可以输出完整的Tracback信息。 运行结果如下： 123456782018-10-20 00:36:38,007 - __main__ - INFO - INFO2018-10-20 00:36:38,007 - __main__ - WARNING - WARNING2018-10-20 00:36:38,007 - __main__ - ERROR - something wrongTraceback (most recent call last): File "/Users/jingxing/PycharmProjects/python全栈/day22/log_test.py", line 58, in &lt;module&gt; num = 1 / 0ZeroDivisionError: division by zero2018-10-20 00:36:38,007 - __main__ - INFO - end 这样可以详细的记录报错的信息，一旦出现了错误，可以及时的定位到出现问题的代码。 六 配置共享在写项目的时候，肯定会有许多的配置信息，如果每个文件都来配置logging的话非常麻烦，而且几乎很多地方的配置几乎差不多的，因为此原因，logging模块提供了父子模块共享配置的机制，会根据Logger的名称来自动加载父模块的配置。 定义一个main.py文件： 12345678910111213141516# main.pyimport loggingimport corelogger = logging.getLogger('main')logger.setLevel(level=logging.DEBUG)handler = logging.FileHandler('test.log')handler.setLevel(logging.INFO)formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - % (message)s')handler.setFormatter(formatter)logger.addHandler(handler)logging.info('main info')logging.debug('main debug')logging.error('main error')core.run() 在执行文件配置了日志的输出格式和文件路径，同时定义了Logger的名称为main，然后引入了另外一个模块core，最后调用了core的run()方法。 接下来定义core.py，内容如下： 12345678import logginglogger = logging.getLogger('main.core')def run(): logger.info('core info') logger.debug('core debug') logger.error('core error') 在core.py文件里定义了Logger的名称为main.core，因为之前在main.py文件里定义的Logger名称为main，所以core.py里面的Logger就会复用main.py里面的Logger配置，而不用重新为core配置日志了。 运行之后test.log结果如下： 1234562018-10-20 10:15:37,575 - main - INFO 2018-10-20 10:15:37,575 - main - DEBUG 2018-10-20 10:15:37,575 - main - ERROR 2018-10-20 10:15:37,575 - main.core - INFO 2018-10-20 10:15:37,575 - main.core - DEBUG 2018-10-20 10:15:37,575 - main.core - ERROR 可以看出main和core模块都是用了同样的输出配置。所以只要在入口文件里定义好logging模块的输出配置，子模块只需要在定义Logger对象时使用父模块的名称开头就可以共享配置，实际上直接使用父模块的名字就可以，但是为了增加辨识度，可以在父模块名字后加上后缀。 查看getLogger源码可得，后面的名字可以自定义，然后getLogger里面会自动帮你创建以该名字命名的日志生成器，具体解释如下： 1获取具有指定名称（通道名称）的记录器，如果它尚不存在则创建它。 此名称是以点分隔的分层名称，例如“a”，“a.b”，“a.b.c”或类似名称。如果指定名称存在PlaceHolder [即 loggerdid不存在，但它的子节点已经存在]，用createdlogger替换它，并修复指向占位符的父/子引用，现在指向记录器。 七 文件配置虽然可以再入口文件中定义好配置信息，然后子模块也可以使用很方便，但是因为配置文件大部分都是不需要更改的，只是某些需要更改，像这种信息可以把配置写入配置文件里，然后运行时读取配置文件里面的配置，这样更易维护和使用。 项目结构如下： 123456789# bin/start.pyimport os,syssys.path.append(os.path.dirname(os.path.dirname(__file__)))import core.shopdef run(): print("welcome to here") core.shop.shopping()run() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# conf/settingsstandard_format = "%(name)s %(asctime)s %(levelname)s %(module)s %(funcName)s %(lineno)s %(message)s"simple_format = "%(name)s %(asctime)s %(module)s %(message)s"complete_format = "%(asctime)s %(levelname)s %(funcName)s %(lineno)s %(thread)s %(process)s %(message)s"logfile_path = r"/Users/jingxing/PycharmProjects/python全栈/day23/log/d.log"LOGGING_DIC = &#123; 'version': 1, 'formatters': &#123; 'standard': &#123; 'format': standard_format &#125;, 'simple': &#123; 'format': simple_format &#125;, "complete":&#123; "format": complete_format &#125; &#125;, 'filters': &#123;&#125;, 'handlers': &#123; 'console': &#123; 'level': 'DEBUG', 'class': 'logging.StreamHandler', 'formatter': 'simple' &#125;, 'default': &#123; 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', 'formatter': 'standard', 'filename': logfile_path, # 'maxBytes': 1024 * 1024 * 5, # 日志文件的最大大小为5M 超出后 换文件 'backupCount': 5, # 最多留五个日志文件 'encoding': 'utf-8', &#125;, &#125;, 'loggers': &#123; # 在getLogger的时候 如果指定的名称 不存在 或者不给名称 用的就是默认的 # 在这里如果key为空 它就是默认的 # 你可以自己定义生成器的名称 并且他们还能使用相同的默认配置 '': &#123; 'handlers': ['default', 'console'], 'level': 'DEBUG', 'propagate': False, &#125;, &#125;,&#125; 1234567# core/shop.pyimport lib.commonlogger = lib.common.get_logger()def shopping(): print("开始购物") logger.debug("购物成功") 1234567# lib/common.pyimport conf.settingsimport logging.configdef get_logger(): logging.config.dictConfig(conf.settings.LOGGING_DIC) return logging.getLogger("main") 在代码运行后，在shop.py模块中导入了lib.common模块，在common.py模块中导入了conf.settings模块，来获取具体的日志配置，因为getLogger(‘main’)里面的main在settings里面没有，所以使用默认的日志配置，如下： 123456789'loggers': &#123; # 在getLogger的时候 如果指定的名称 不存在 或者不给名称 用的就是默认的 # 在这里如果key为空 它就是默认的 # 你可以自己定义生成器的名称 并且他们还能使用相同的默认配置 '': &#123; 'handlers': ['default', 'console'], 'level': 'DEBUG', 'propagate': False, &#125; 然后首先进行level=’DEBUG’的过滤，因为shopping中的日志信息级别为debug，所以会通过进入handlers里面进行第二次过滤，在handlers里面有两个配置，一个为default配置，一个味console配置，在default配置中，具体配置如下： 123456789'default': &#123; 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', 'formatter': 'standard', 'filename': logfile_path, # 'maxBytes': 1024 * 1024 * 5, # 日志文件的最大大小为5M 超出后 换文件 'backupCount': 5, # 最多留五个日志文件 'encoding': 'utf-8', &#125; 发现日志级别为DEBUG，所以仍然不会过滤，接下来就是格式化输出到指定文件了，formatter为standard模式，filename之前都已经定义好了，同理console同理输出到控制台。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之xml]]></title>
    <url>%2F2018%2F10%2F18%2Fpython%E6%A8%A1%E5%9D%97%E4%B9%8Bxml%2F</url>
    <content type="text"><![CDATA[xml模块 xml结构 xml是种实现不同语言或程序之间进行数据交换的协议，跟json差不多，但没json使用简单。但是因为历史遗留问题，至今很多行业依然使用xml这种数据格式。 xml的格式如下，是通过&lt;&gt;节点来区别数据结构的。 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;friendsinfo&gt; &lt;frd age="22" name="任盼晨"&gt; &lt;info qq="1114893928" wechat="Dmgwood" /&gt; &lt;/frd&gt; &lt;frd age="22" name="袁靖"&gt; &lt;info qq="2410152779" wechat="wxid_2vykc0sjoiie21" /&gt; &lt;/frd&gt; &lt;frd age="22" name="卫一帆"&gt; &lt;info qq="97280940" wechat="oOC" /&gt; &lt;/frd&gt; &lt;frd age="22" name="胡文涛"&gt; &lt;info qq="2522864970" wechat="hu2522864970" /&gt; &lt;/frd&gt;&lt;/friendsinfo&gt; 语法结构 任何的起始标签都必须有一个结束标签。 &lt;&gt; &lt;/&gt; 可以采用另一种简化语法，可以在一个标签中同时表示起始和结束标签。这种语法是在大于号之前紧跟一个斜杠(/)，例如，解析器会将其翻译成 标签必须按合适的顺序进行嵌套，所以结束标签必须按镜像顺序匹配起始标签。这好比将起始和结束标签看作是数学中的左右罗浩：在没有关闭所有的内部括号之前，是不能关闭外面括号的。 所有的特性都必须有值。 所有的特性都必须在值得周围加上双引号。 一个标签的组成部分包括：标签名、属性名以及属性值、还有文本内容（可以没有） 双标签的写法： 1&lt;tagename '属性名称'="属性值"&gt;文本内容&lt;/tagname&gt; 单标签的写法： 1&lt;tagename 属性名称="属性值"/&gt; 总结：xml也是一种中间格式，也属于序列化方式之一，与json比较，同样的数据json会更小，效率更高；xml需要根据文档结构手动解析，而json直接可以转为python数据对象。 xml模块用法 1234567891011121314151617181920212223# d.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;studentinfo&gt; &lt;stu age="20" name="张三"&gt; &lt;girlfriend age="19" name="张三的女朋友" /&gt; &lt;/stu&gt; &lt;stu age="20" name="李四"&gt; &lt;girlfriend age="19" name="李四的女朋友" /&gt; &lt;/stu&gt; &lt;age num="1"&gt; &lt;age num="2"&gt; &lt;age num="3"&gt; &lt;/age&gt; &lt;/age&gt; &lt;/age&gt; &lt;age&gt; &lt;/age&gt;&lt;/studentinfo&gt; 1234567891011121314151617181920212223242526import xml.etree.ElementTree as ElementTreetree = ElementTree.parse('d.xml')rootTree = tree.getroot()# 三种获取标签的方式# 1. 获取所有人的年龄，iter用于在全文范围获取标签for item in rootTree.iter('age'): # 一个标签三个组成部分 print(item.tag) # 标签名称 print(item.attrib) # 标签的属性 print(item.text) # 文本内容# 2. 从当前标签的子标签中找到一个名称为age的标签，如果有多个，找到的是第一个print(rootTree.find('age').attrib)# 3. 从当前标签的子标签中找到所有名称为age的标签print(rootTree.findall('age'))# 获取单个属性stu = rootTree.find('stu')print(stu.get("age"))print(stu.get("name"))# 删除子标签rootTree.remove(stu)# 添加子标签newTag = ElementTree.Element('这是新标签', &#123;'一个属性': '值'&#125;)rootTree.append(newTag)# 写入文件tree.write('f.xml', encoding='utf-8')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之configparser模块]]></title>
    <url>%2F2018%2F10%2F18%2Fpython%E4%B9%8Bconfigparser%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[一 什么是configparser？configparser是用于解析配置文件的模块。什么是配置文件呢？包含配置程序信息的文件就称为配置文件。什么样的数据应该作为配置信息呢？需要修改但是不经常改的信息就可以作为配置信息，比如数据文件的路径。 二 什么是配置文件？配置文件中只有两种内容： section，分区 option，选项，是键值对的形式 三 configparser的使用wiki12345678910# useinfo.cfg[user]name1 = musibiiname2 = thalesname3 = ddd[password]password1 = woshinibabapassword2 = 123456password3 = 123 1234567891011121314151617181920212223242526import configparser# 创建一个解析器config = configparser.ConfigParser()# 读取并解析cfg文件config.read('useinfo.cfg', encoding='utf-8')# 获取所有sectionprint(config.sections())# 获取某个分区下所有optionprint(config.options('user'))# 获取某个选项具体的值print(config.get('user', 'name1'))# get返回的都是字符串类型，如果需要转换类型，直接使用get+对应的类型(bool，int，float)print(config.getint('password', 'password1'))# 是否有某个选项，返回布尔值config.has_option()# 是否有某个分区config.has_section()# 不常用的一些方法# 添加分区(必须先添加分区才可以修改分区下面的值)config.add_section('server')config.set('server', 'usr', '192.168.1.1')# 删除选项config.remove_option('user', 'name1')# 写入文件with open('useinfo.cfg', 'wt', encoding='ust-8') as f: config.write(f)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之pickle、shelve、json]]></title>
    <url>%2F2018%2F10%2F17%2Fpython%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[一 什么是序列化序列化指的是将内存中的数据结构转化为一种中间格式，并存储到硬盘上。 （反序列化：将硬盘上存储的中间格式数据再还原为内存中的数据结构） 二 为什么要序列化 持久保持状态 需知一个软件/程序的运行就是处理一系列状态的变化，在编程语言中，‘状态‘会以各种有结构的数据类型(也可以称之为变量)的形式保存在内存中。 内存是无法永久保存数据的，当程序运行了一段时间，我们断电或者重启程序，内存中关于这个程序之前一段时间的数据都会被清空。 在断电或重启程序之前将程序当前运行的数据保存下来，便于下次程序执行能够从文件中载入之前的数据，然后继续执行，这就是序列化。 数据跨平台交互 序列化数据之后，不仅可以把序列化后的内容写入硬盘，还可以通过网络传输到别的机器上，如果收发的双方约定都使用一种序列化的格式，那么便打破了平台和语言带来的限制，实现了跨平台交互。 反过来，把变量内从从序列化的对象重新读到内存里称之为反序列化，即unpicking。 三 序列化数据的三个模块一 pickle模块pickle模块时python内置的用来序列化python数据格式的模块，支持序列化python中所有的数据类型，主要方法有四个； dumps 12345678import picklename = 'musibii'age = 18height = 1.7user = &#123;'name': name, 'age': age, 'height': height&#125;with open('userinfo.pkl', 'ab') as f: userbytes = pickle.dumps(user) f.write(userbytes) loads 12345import picklewith open('userinfo.pkl', 'rb') as f: userbytes = f.read() user = pickle.loads(userbytes) print(user) 与dumps和loads对应的两个方法更简单。 dump 123import picklewith open('userinfo.pkl', 'ab') as f: pickle.dump(user, f) load 1234import picklewith open('userinfo.pkl', 'rb') as f: user = pickle.load(f) print(user) 二 shelve模块shevlve模块也用于序列化，它和pickle模块不同的地方在于，不需要关心文件模式，直接把数据当成字典来看待。而且shelve模块可以直接对数据进行修改，而不用覆盖之前的数据，但pickle要想修改的话只能使用wb模式覆盖 shelve只有一个方法open，所以使用起来也很方便。同样的，shelve也支持python中所有的数据格式。 12345import shelveuser = &#123;'name': 'musibii'&#125;s = shelve.open('userdb.shv')s['user'] = users.close() 三 json模块1 json是什么JSON是Java script object notation的缩写，翻译过来就是js对象标识法。 对于开发者而言，json是一种通用的数据格式，任何语言都能解析，所以每种语言都会有处理json格式数据的需求。 json语法 js 中的数据类型 python数据类型 的对应关系 {} 字典 [] list string “” str int/float int/float true/false True/False null None json格式的语法规范 最外层通常是一个字典或列表 {}or[]，如果想定义json格式的数据，那么最外层直接写{}，而且json中的字符串必须是双引号，json理论上可以嵌套任意多的层次。 2 为什么用json虽然之前的pickle和shelve都很强大，而且使用也非常方便，那么为什么还出来json呢？这是因为pickle和shevle序列化之后的数据只有python才能解析出来，而通常在实际生产开发中，都是需要数据可以跨平台使用的。 3 json的使用json模块的核心方法 dump dumps load loads 不带s的直接封装了write和read方法。 dump 1234567891011121314import jsonjsontext = """&#123; "users": [&#123; "name": "musibii", "age": 18 &#125;, &#123; "name": "thales", "age": 23 &#125; ]&#125;"""with open('a.json', 'wt', encoding='utf-8') as f: json.dump(jsontext, f) dumps 1234567891011121314import jsonjsontext = """&#123; "users": [&#123; "name": "musibii", "age": 18 &#125;, &#123; "name": "thales", "age": 23 &#125; ]&#125;"""with open('a.json', 'wt', encoding='utf-8') as f: f.write(json.dumps(jsontext)) load 123import jsonwith open('a.json', 'rt', encoding='utf-8') as f: print(json.load(f)) loads 1234import jsonwith open('a.json', 'rt', encoding='utf-8') as f: res = json.loads(f.read()) print(res)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之shutil]]></title>
    <url>%2F2018%2F10%2F17%2Fpython%E6%A8%A1%E5%9D%97%E4%B9%8Bshutil%2F</url>
    <content type="text"><![CDATA[shutil是一个用于简化文件操作的模块。 复制文件（传入源文件对象和目标文件对象） 1234import shutilf1 = open(r'/Users/jingxing/PycharmProjects/day20/test.py', 'rb')f2 = open(r'/Users/jingxing/PycharmProjects/day20/test_test.py', 'rb')shutil.copyfileobj(f1, f2) 压缩文件 123import shutilshutil.make_archive('myzip', 'zip', r'/Users/jingxing/PycharmProjects/day20')shutil.make_archive('mytar', 'tar', r'/Users/jingxing/PycharmProjects/day20') 解压文件 123import shutilshutil.unpack_archive(r'/Users/jingxing/PycharmProjects/day20/myzip.zip')shutil.unpack_archive(r'/Users/jingxing/PycharmProjects/day20/mytar.tar') 其他两个用于解压的模块 zipfile从名字可以看出来是解压zip压缩文件的模块。 解压 1234import zipfilez = zipfile.ZipFile(r'/Users/jingxing/PycharmProjects/day20/myzip.zip', 'r')z.extractall(path=r'/Users/jingxing/PycharmProjects/day20')z.close() 往压缩包中添加文件 12345import zipfilez = zipfile.ZipFile(r"/Users/jingxing/PycharmProjects/python全栈/day20/代码/my压缩.tar","w")z.write("1.昨日回顾")z.write("2.今日内容")z.close() tarfile 解压 1234import tarfilet = tarfile.open(r"/Users/jingxing/PycharmProjects/python全栈/day20/代码/my压缩.tar","w")t.extractall(r"/Users/jingxing/PycharmProjects/python全栈/day19")t.close() 往压缩包中添加文件 12345port tarfilet = tarfile.open(r"/Users/jingxing/PycharmProjects/python全栈/day20/代码/my压缩.tar","w")t.add("1.昨日回顾")t.add("2.今日内容")t.close()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之random]]></title>
    <url>%2F2018%2F10%2F17%2Fpython%E6%A8%A1%E5%9D%97%E4%B9%8Brandom%2F</url>
    <content type="text"><![CDATA[python的随机数模块为random模块，可以产生随机的整数或浮点数。但是这是伪随机数，python解释器会维护一些种子数，然后根据算法算出随机数。linux维护了一个熵池，这个熵池收集噪音的信息，更接近真随机数。 random 随机产生0-1的浮点数，不包括1 123import randomprint(random.random())# 运行结果 0.8517652068795716 随机产生a-b的整数，包括a和b 12345import randoma = 1b = 10print(random.randint(a, b))# 运行结果 4 随机产生a-b，不包括a和b的整数 12345import randoma = 1b = 10print(random.randrange(a, b))# 运行结果 7 指定一个范围并指定需要产生的随机个数 123import randomprint(random.sample(['aa', ['a', 'b'], 3, 4, 5], 2))# 运行结果 [['a', 'b'], 5] 打乱列表的顺序（返回None） 12345import randomls = [1, 2, 3, 4, 5, 9, 11]random.shuffle(ls)print(ls)# 运行结果 [1, 9, 2, 5, 4, 11, 3] 从给定的序列中随机选一个 123import randomprint(random.choice([1,2,3,4,5,6]))# 运行结果 2 从给定的序列中随机选多个（包括1个，返回一个列表） 123import randomprint(random.choices((1,2,3,4,5,6,7), k=3))# 运行结果 [6, 5, 5] 制作随机验证码 12345678910import randomdef get_verifycode(length): res = '' for i in range(length): a = random.randint(0, 9) b = chr(random.randint(65, 90)) c = chr(random.randint(97, 122)) s = random.choice([a, b, c]) res += s return res]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块之sys与os]]></title>
    <url>%2F2018%2F10%2F17%2FPython%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E4%B9%8Bsys%E4%B8%8Eos%2F</url>
    <content type="text"><![CDATA[python常用模块系列（二）：sys模块与os模块 sys模块是python解释器和环境有关的一个模块； os是python用来和操作系统进行交互的一个模块。 一 sys 查看当前环境变量 查看已经加载的模块 可以看出sys.modules是一个字典，key为加载模块的名字，values为加载模块的路径。 获取终端调用时的参数 终端输入的参数为argv[1]，默认当前文件名为第一个参数。 获取解释器的版本信息 获取当前运行平台名称（windows为nt，macOS为darwin） 退出信号 123import syssys.exit(0) # 正常退出sys.exit(1) # 错误退出 接口版本 123import sysprint(sys.api_version)# 运行结果 1013 了解 123456import sysprint(sys.maxsize)print(sys.maxunicode)# 运行结果# 9223372036854775807# 1114111 二 os 获取当前的工作目录 123import osprint(os.getcwd())# 运行结果 /Users/jingxing/PycharmProjects/python全栈/day20/代码 切换工作目录 1234import osprint(os.chdir('/Users/jingxing/PycharmProjects/python全栈'))print(os.getcwd())# 运行结果 /Users/jingxing/PycharmProjects/python全栈 获取当前目录 123import osprint(os.curdir)# 运行结果 . 获取上级目录 123import os print(os.pardir)# 运行结果 .. 获取系统的环境变量 123import osprint(os.environ)# environ(&#123;'PATH': '/Users/jingxing/.nvm/versions/node/v4.9.1/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/python_study/mongodb/bin://Volumes/python_study/mongodb/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/VMware Fusion.app/Contents/Public:/python_study/Applications/mongodb-osx-x86_64-3.6.3/bin::/usr/local/mysql/bin', 'COMMAND_MODE': 'unix2003', 'VERSIONER_PYTHON_VERSION': '2.7', 'LS_OPTIONS': '--color=auto', 'LOGNAME': 'jingxing', 'XPC_SERVICE_NAME': 'com.apple.xpc.launchd.oneshot.0x10000004.pycharm', 'PWD': '/Users/jingxing/PycharmProjects/python全栈/day20/代码', 'PYCHARM_HOSTED': '1', 'NODE_PATH': '/Users/jingxing/.nvm/versions/node/v4.9.1/lib/node_modules', 'PYCHARM_MATPLOTLIB_PORT': '49379', 'PYTHONPATH': '/Applications/PyCharm.app/Contents/helpers/pycharm_matplotlib_backend:/Users/jingxing/PycharmProjects/python全栈', 'NVM_CD_FLAGS': '', 'NVM_DIR': '/Users/jingxing/.nvm', 'SHELL': '/bin/bash', 'LSCOLORS': 'CxfxcxdxbxegedabagGxGx', 'PYTHONIOENCODING': 'UTF-8', 'SECURITYSESSIONID': '186a7', 'VERSIONER_PYTHON_PREFER_32_BIT': 'no', 'USER': 'jingxing', 'CLICOLOR': 'Yes', 'TMPDIR': '/var/folders/yl/3drd7wf93f90sfkgpc2zg9cr0000gn/T/', 'SSH_AUTH_SOCK': '/private/tmp/com.apple.launchd.bIB1b2eyOD/Listeners', 'XPC_FLAGS': '0x0', 'PYTHONUNBUFFERED': '1', '__CF_USER_TEXT_ENCODING': '0x1F5:0x19:0x34', 'Apple_PubSub_Socket_Render': '/private/tmp/com.apple.launchd.bHuC64fYdd/Render', 'LC_CTYPE': 'zh_CN.UTF-8', 'NVM_BIN': '/Users/jingxing/.nvm/versions/node/v4.9.1/bin', 'HOME': '/Users/jingxing', '__PYVENV_LAUNCHER__': '/Library/Frameworks/Python.framework/Versions/3.6/bin/python3'&#125;) 创建多级目录 123import osos.makedirs('a/b/c')# 会在当前文件路径创建多级目录 创建一个目录 123import osos.mkdir('aa')# 能且仅能创建一个目录 递归删除 123import osos.removedirs('a/b/c')# 递归删除，只能删除空目录 删除一个目录 123import osos.rmdir('aa')# 删除一个目录 删除文件 123import osos.remove(r'/Users/jingxing/PycharmProjects/python全栈')# 删除文件 列出当前目录所有的文件及文件夹 12import osprint(os.listdir(r'/Users/jingxing/PycharmProjects/python全栈')) 获取当前平台路径分隔符 123import osprint(os.seq)# 运行结果 / 获取当前平台换行符 12import osprint(os.lineseq, end='') 三 os下的path模块 返回绝对路径 123from os import pathprint(path.abspath('a/b/c'))# 运行结果 /Users/jingxing/PycharmProjects/python全栈/day20/代码/a/b/c 将路径拆分为文件夹路径和文件名（返回元祖） 123from os import pathprint(path.split('/Users/jingxing/PycharmProjects/python全栈/day20/代码/5.os下path模块.py'))# 运行结果 ('/Users/jingxing/PycharmProjects/python全栈/day20/代码', '5.os下path模块.py') 获取路径中的上一级 123from os import pathprint(path.dirname(__file__))# 运行结果 /Users/jingxing/PycharmProjects/python全栈/day20/代码 获取路径的最后一级名称 123from os import pathprint(path.basename(r'/Users/jingxing/PycharmProjects/python全栈/day20/代码/5.os下path模块.py'))# 运行结果 5.os下path模块.py 判断路径是否存在（返回布尔值） 123from os import pathprint path.exists(r'/Users/jingxing/PycharmProjects/python全栈/day20/代码/5.os下path模块.py')# 运行结果 True 判断是否为绝对路径（返回布尔值） 123from os import pathprint(path.isabs(r'/Users/jingxing/PycharmProjects/python全栈/day20/代码/5.os下path模块.py'))# 运行结果 True 路径拼接 123from os import pathprint(path.join('/Users/jingxing/PycharmProjects/', 'day20'))# 运行结果 /Users/jingxing/PycharmProjects/day20 获取文件的大小 12from os import pathprint(path.getsize(r'/Users/jingxing/PycharmProjects/python全栈')) 大写变小写，斜杠根据当前平台修改 123from os import pathprint(path.normcase(r'a/\b/\c'))# 运行结果 a/\b/\c 斜杠会修改为当前平台的分隔符，执行..来返回上一级 123from os import pathprint(path.normpath('a/b/c/../c'))# 运行结果 a/b/c]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python模块之time与datetime]]></title>
    <url>%2F2018%2F10%2F16%2FPython%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E4%B9%8Btime%E4%B8%8Edatetime%2F</url>
    <content type="text"><![CDATA[python常用模块系列（一）：time模块与datetime time模块是python内置查看当前时间戳的一个模块； datetime模块是用来对日期和时间进行操作的一个模块。 一 time1 获得时间戳时间戳：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行‘’type(time.time())‘’，返回的是float类型。 123import timeprint(time.time())# 运行结果 1539678307.779871 2 结构化时间字符串123import timeprint(time.localtime()) # 返回一个元祖对象，里面是每个时间的值(东八区)# 运行结果 time.struct_time(tm_year=2018, tm_mon=10, tm_mday=16, tm_hour=16, tm_min=48, tm_sec=4, tm_wday=1, tm_yday=289, tm_isdst=0) 123import timeprint(time.localtime().tm_year) # 单独获取某个时间属性# 运行结果 2018 123import timeprint(time.gmtime()) # 世界统一时间，比北京时间晚8小时# 运行结果 time.struct_time(tm_year=2018, tm_mon=10, tm_mday=16, tm_hour=8, tm_min=51, tm_sec=16, tm_wday=1, tm_yday=289, tm_isdst=0) 3 格式化的字符串时间123456import time print(time.strftime('%Y-%m-%d %H:%M:%S %p'))print(time.strftime('%Y-%m-%d %X %p'))# 运行结果 # 2018-10-16 16:54:56 PM# 2018-10-16 16:54:56 PM 4 三种格式之间的相互转换 时间戳转为结构化 123import timeprint(time.localtime(time.time()))# 运行结果 time.struct_time(tm_year=2018, tm_mon=10, tm_mday=16, tm_hour=16, tm_min=57, tm_sec=18, tm_wday=1, tm_yday=289, tm_isdst=0) 结构化转字符串 123import timeprint(time.strftime("%Y-%m-%d",time.localtime(time.time())))# 运行结果 2018-10-16 字符串转结构化 123import timeprint(time.strftime('2018-10-16', '%Y-%m-%d'))# 运行结果 time.struct_time(tm_year=2018, tm_mon=10, tm_mday=15, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=288, tm_isdst=-1) 结构化转时间戳 123import timeprint(time.mktime(time.strptime('2018-10-15', '%Y-%m-%d')))# 运行结果 1539532800.0 格林威治时间 123456import timeprint(time.asctime(time.localtime()))print(time.ctime())# 运行结果# Tue Oct 16 17:12:34 2018# Fri Jan 2 08:00:00 1970 二 datetimedatetime是一个包，里面包含对时间的处理和日期的处理 获取当前详细时间 123import datetimeprint(datetime.datetime.now())# 运行结果 2018-10-16 17:25:16.186114 获取时间的某一部分 123import datetimeprint(datetime.datetime.now().hour) # 分钟、年份等同理# 运行结果 17 替换时间的某一部分 12345import datetimet1 = date.datetime.now()t1 = t1.replace(year=2019)print(t1)# 运行结果 2019-10-16 18:36:42.166986 时间差对象 12345import datetimet2 = datetime.timedelta(weeks=1)t3 = datetime.datetime.now()print(t2 + t3)# 运行结果 2018-10-23 18:40:10.481854]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>内置模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件目录规范]]></title>
    <url>%2F2018%2F10%2F15%2F%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[随着功能的增多，代码逻辑也会越来越多，导致代码逻辑混乱不便于管理项目。为了解决这个问题，可以将相同功能的代码集合在一个文件夹，设置一个入口函数，一些设置文件放在一个文件，主要逻辑代码放一个文件夹。。。 这样对于整个业务有很好的可读性和扩展性。 对于之前的ATM+购物车项目最开始所有的逻辑代码都在一个文件，当我们需要修改某些函数时，遇到了一点困难，就是整个项目有600+行代码，而且什么都在里面，对于想快速具体的找到想修改的地方确实需要花费一些时间，效率低下。所以重新修改后，将具体功能代码放在一起，很明显逻辑清晰了，而且看的也很舒服。 如下为我的项目结构中的bin文件夹： bin目录下的start.py文件为启动函数，首先在启动函数里面导入os和sys模块，目的是为了将当前项目的根路径加入环境变量，接着导入相关函数和变量。该py文件仅仅作为程序的入口，里面没有逻辑代码。 如下为conf文件夹： conf是configuration的缩写，为配置的意思，里面只有settings文件，可以看出里面都是定义的一些变量，（在这里的变量其实应该使用大写的） 接下来是主要业务逻辑代码文件夹core（核心）： 里面有三个py文件，因为项目有三个主要功能，分别是ATM、SHOPP、USER，所以分了三个，里面的代码大同小异。 接下来是记录用户消费流水的文件夹，（db）里面也包括了用户信息，比如账号名、密码、余额、状态等信息。 这些信息文件在每一个账户登录时，会根据登录名创建一个文件，模式为追加，当退出时将数据刷入文件并关闭文件。 接下来为lib，lib是library的缩写，表示库的意思。里面只有common文件（里面可以放共用的一些功能代码或者第三方库） common文件里面是几个通用的功能函数，比如日志装饰器、读取用户所有信息的函数、、、 接下来为log文件夹，记录日志，哪个用户登陆了，做了什么事情都会记录下来（仔细想来，生活中我们在某些应用中做的事情是不是也会记录下来？答案是肯定的） 最后一个是README.md文件，通常是用来给用户看的，说明程序怎么使用，叫做帮助文档。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>包、文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块与包]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%2F</url>
    <content type="text"><![CDATA[一 什么是模块模块就是一组功能的集合体，可以通过导入模块来复用模块的功能。 比如我在同一个文件夹定义两个.py文件，分别命名为A.py和B.py，那么可以通过在A文件里通过import B来使用B文件里的名称空间。 python中，模块的使用方式都是一样的，可以分为四个通用类别： 使用python编写的.py文件 已被编译为共享库或DLL的C或C++扩展 把一系列模块组织到一起的文件夹（注：文件夹下有一个init.py文件，该文件夹称之为包） 使用C编写并链接到python解释器的内置模块 二 为何要使用模块 从文件级别组织程序，便于管理 随着需求的增多，功能也会越来越多，为了方便管理，通常将程序分成多个文件，这样项目的结构会更加清晰，方便管理。这时不仅仅可以把这些文件当做脚本去执行，还可以把他们当做模块来导入到其他的模块中，实现功能复用。 使用别人写好的模块，提高开发效率 使用别人已经写好的轮子，在自己的项目中使用，可以极大地提高开发效率。 注意：当退出python解释器的时候，重新进入那么之前定义的函数和变量都会丢失，因此通常将程序写到文件中以便永久保存，需要时可以在命令行通过python *.py方法执行。 1234567891011121314# test1.pyprint('from test1')money = 10def func1(): print('test1模块:', money) def func2(): print('test1模块') func1() def change(): global money money = 100 123# test2.pyimport test1test1.func1() 123# 运行结果from test1test1模块: 10 当在tes2t导入的时候会执行test1中的代码，所以首先会打印from test1接着执行test1中的func1函数。 三 使用模块之import1 import的使用模块可以包含可执行的语句和函数的定义，这些语句的目的是初始化模块，它们只在模块名第一次导入时才会执行（import语句可以在程序中的任意位置使用的，且针对同一个模块可以import多次，python为了防止重复导入，当第一次导入模块时就将模块的名称空间加载到内存了，后续的import语句仅是对已经加载到内存中的模块对象增加了一次引用，并不会重复执行模块内的语句） 12# test3print('from test3') 12345# test4import test3import test3import test3import test3 12# 运行结果from test3 ps:可以导入sys模块，调用sys.module查看当前加载到内存中的模块，sys.module是一个字典，内部包含模块名和模块名路径的对应关系。该字典决定了导入模块时是否需要重新导入。 2 导入模块时发生了什么运行py文件导入一个模块时，解释器做了三件事： 在执行文件中为被导入文件创建新的名称空间，在被导入模块中定义的函数和方法若是使用到了global时访问的就是这个名称空间。 在新创建的名称空间中执行模块中的包含的代码。函数定义也是‘’被执行‘’的语句，模块级别函数定义的执行将函数名放入模块全局名称空间表，可以用globals()可以查看。 在执行文件的名称空间创建被导入模块的名称来引用该名称空间。 这个名字和变量名没什么区别，都是‘’第一类‘’的，且使用句点表示法可以访问被导入模块的名称空间，导入的模块与被导入的模块是独立的两个名称空间。 3 被导入模块有独立的名称空间每个模块都是一个独立的名称空间，定义在这个模块中的函数，把这个模块的名称空间当做全局名称空间，这样就不用担心定义在不同的模块中全局变量在导入时与使用者的全局变量冲突。 测试1 1234# test5.pyimport test1money = 100print(test1.money) 123# 运行结果from test110 测试2 123456# test6import test1def func1(): print('from test6 func1')test1.func1()func1() 12345# 运行结果from test1test1模块: 10from test6 func1# 这说明 test6中的函数和test1中的函数不冲突 测试3 12345# test7import test1money = 1test1.change()print(money) 12345# 运行结果from test1test1模块: 101# 这说明test1中的change函数只是修改了test1中的全局变量，对test7中的变量没有操作权限 四 使用模块之from…import…1 from…import…与import …的区别区别就是：使用from…import…是将被导入模块中的名字直接导入到当前的名称空间中，所以在当前名称空间中，直接使用名字就可以了，不需要在前面加上模块名前缀。 from…import…导入方式的优缺点： 好处：使用方便 坏处：容易与当前执行文件的名字冲突 2 验证 验证1：当前位置直接使用test1中的函数名，执行时仍然以test1.py文件为全局名称空间 12345# 导入的函数func1，执行时仍然回到test1.py中寻找全局变量money# test8from test1 import func1money = 50func1() 123# 运行结果from test1test1模块: 10 123456# 导入的函数func2，执行时需要调用func1，仍然回到test1.py中找func1#test9.pyfrom test1 import func2def func1(): print('-----')func2() 1234# 运行结果from test1test1模块test1模块: 10 验证2：如果当前名称空间和被导入的模块中的名字重合，那么会覆盖掉前面的名字 123456# 导入的函数fun1,被当前位置定义的func1覆盖掉了# test10from test1 import func1def func1(): print('======')func1() 1234# 运行结果from test1======# 这说明func1把被导入名字func1覆盖掉了 123456# 当前位置定义的func1导入func1# test11def func1(): print('======')from test1 import func1func1() 1234# 运行结果from test1test1模块: 10# 这说明在后面导入的话会覆盖掉前面的 验证3：被导入的方法执行时，始终以源文件为准 12345# test12from test1 import money,func1money=100 #将当前位置的名字money绑定到了100print(money) #打印当前的名字func1() #读取spam.py中的名字money,仍然为1000 12345# 运行结果from the test100test1模块: 10# 可以看出运行func1的时候依然从原名称空间查找的 3 from … import *from … import * 是把被导入文件中所有不是以下划线(_)开头的名字都导入到当前名称空间。 大部分情况下不应该以这种导入方式，因为不知道被导入包中的名字是否会和当前名称空间中的名字重合造成名字覆盖。 解决方法是在被导入文件中使用all = []来控制被导入的名字，只有在all里面的才会被导入。 4 模块循环导入问题模块循环/嵌套导入抛出异常的根本原因是由于在python中模块被导入一次之后，就不会重新导入。 1234# test1.pyprint('正在导入1')from test2 import yx = '1' 1234# test2.pyprint('正在导入2')from test1 import xy = '2' 12# run.pyimport test1 1234567891011# 运行结果正在导入1正在导入2Traceback (most recent call last): File "/Users/jingxing/PycharmProjects/python全栈/day18/pack/run.py", line 6, in &lt;module&gt; import test1 File "/Users/jingxing/PycharmProjects/python全栈/day18/pack/test1.py", line 7, in &lt;module&gt; from test2 import y File "/Users/jingxing/PycharmProjects/python全栈/day18/pack/test2.py", line 8, in &lt;module&gt; from test1 import xImportError: cannot import name 'x' 分析：在run文件中执行导入test1，运行test1的代码，打印并且从test2中导入y，回到test2，打印并且从test1中导入，因为已经导入test1了（没导入完全，因为代码没执行完），所以直接找’x’，但因为在test1中的代码执行不下去，所以报错。执行文件不等于就完全导入文件了。 解决方法1：导入语句放在最后 解决方法2：导入语句放在函数中（因为在导入模块时，函数内的代码并不会执行，只会判断语法错误，所以这时候导入模块可以完全导入） 5 模块的重载考虑到性能的原因，每个模块只被导入一次，放入字典sys.module中，如果你改变了模块的内容，必须重启程序（python不支持重新加载或卸载之前导入的模块） 就算在修改已经导入的模块里面的代码对运行结果也没影响。 6 py文件区分两种用途：模块与脚本 脚本，一个文件就是整个程序，用来被执行 模块，文件中存放着一堆功能，用来被导入使用 python内置了全局变量name, 当文件被当做脚本执行时：name等于’main‘ 当文件被当做模块导入时：name等于模块名 作用：用来控制.py文件在不同的应用场景下执行不同的逻辑 12if __name__ == '__main__': pass 7 模块搜索路径模块的查找顺序是：内存中已经加载的模块–》内置模块–》sys.path路径中包含的模块 详细：在第一次导入某个模块式，会先检查该模块是否已经被加载到内存中（当前执行文件的名称空对应的内存），如果有则直接引用； ps:python解释器会在启动时自动加载一些模块到内存中，可以使用sys.module查看。 如果在内存中没有，解释器会查找同名的内建模块； 如果还没有则去sys.path给出的目录列表中查找。 了解：sys.path的初始化的值来自于： The directory containing the input script (or the current diretory whrn no files is specified). PYTHONPATH (a list of directory names, with the same syntax as the shell variable PATH). The installation-dependent default. 在初始化后，python程序可以修改sys.path，路径放在前面的优于标准库被加载。 搜索时按照sys.path中从左到右的顺序查找，位于前面的优先被查找，sys.path中还可能包含.zip归档文件和.egg文件，python会把.zip归档文件当成一个目录去处理。 .egg文件是setuptools创建的包，这是按照第三方python库和扩展时使用的一种常见格式，.egg文件实际上只是添加了额外元数据（如版本号，依赖项等）的.zip文件。 只能从.zip文件中导入.py，.pyc等文件。使用C编写的共享库和扩展块无法直接从.zip文件中加载（此时setuptools等打包系统有时能提供一种规避方法），且从.zip中加载文件不会创建.pyc或者.pyo文件，因此一定要事先创建他们，来避免加载模块是性能下降。 8 编译python文件为了提高加载模块的速度，强调强调强调：提高的是加载速度而绝非运行速度。python解释器会在pycache目录中下缓存每个模块编译后的版本，格式为：module.version.pyc。通常会包含python的版本号。例如，在CPython3.3版本下，spam.py模块会被缓存成pycache/spam.cpython-33.pyc。这种命名规范保证了编译后的结果多版本共存。 Python检查源文件的修改时间与编译的版本进行对比，如果过期就需要重新编译。这是完全自动的过程。并且编译的模块是平台独立的，所以相同的库可以在不同的架构的系统之间共享，即pyc使一种跨平台的字节码，类似于JAVA火.NET,是由python虚拟机来执行的，但是pyc的内容跟python的版本相关，不同的版本编译后的pyc文件不同，2.5编译的pyc文件不能到3.5上执行，并且pyc文件是可以反编译的，因而它的出现仅仅是用来提升模块的加载速度的，不是用来加密的。 五 包1 什么是包？包是一种通过’.模块名’来组织python模块名称的方式。 具体的：包就是一个包含有init.py文件的文件夹，所以其实我们创建包的目的就是为了用文件夹将文件/模块组织起来。 2 为何使用包？包的本质就是一个文件夹，文件夹的功能就是将同类型的文件组织起来。 其实使用包的原因和使用模块的原因是一样的，都是为了提高程序的结构性和可维护性。 3 注意事项 关于包相关的导入语句也分为import和from … import …两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入时带点的，点的左边都必须是一个包，否则非法。可以带有一连串的点，但都必须遵循这个原则。但对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。 import导入文件时，产生名称空间中的名字来源于文件，import 包，产生的名称空间的名字同样来源于文件，即包下的init.py，导入包本质就是在导入该文件 包A和包B下如果有同名模块也不会冲突，因为他们的名称空间是独立的。 4 绝对导入和相对导入包是写给别人用的，然而在包的内部也会有彼此之间互相导入的需求，这时候就有绝对导入和相对导入两种方式： 绝对导入：以包作为起点 相对导入：以.或..的方式作为起点（只能在一个包中使用，不能用于不同目录内） **包以及包所包含的模块都是用来被导入的，而不是直接执行的。而环境变量都是以执行文件为准。 5 绝对导入与相对导入总结12345678910111213绝对导入与相对导入# 绝对导入: 以执行文件的sys.path为起始点开始导入,称之为绝对导入# 优点: 执行文件与被导入的模块中都可以使用# 缺点: 所有导入都是以sys.path为起始点,导入麻烦# 相对导入: 参照当前所在文件的文件夹为起始开始查找,称之为相对导入# 符号: .代表当前所在文件的文件加,..代表上一级文件夹,...代表上一级的上一级文件夹# 优点: 导入更加简单# 缺点: 只能在导入包中的模块时才能使用 #注意: 1. 相对导入只能用于包内部模块之间的相互导入,导入者与被导入者都必须存在于一个包内 2. attempted relative import beyond top-level package # 试图在顶级包之外使用相对导入是错误的,言外之意,必须在顶级包内使用相对导入,每增加一个.代表跳到上一级文件夹,而上一级不应该超出顶级包]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名函数python内置高阶函数以及递归]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0python%E5%86%85%E7%BD%AE%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[匿名函数python定义一个函数通常使用def关键词，后面跟函数名，然后是注释、代码块等。 123def func(): '''注释''' print('from func') 这样就在全局命名空间定义了一个叫func的函数，func表示函数体的内存地址，因为func指向函数体内存地址，所以可以通过func来调用函数。 那么匿名函数呢？从名字就可看出，匿名。想想就有点像以前小时候的佚名一样，带点说不清楚的神秘色彩，现在想来之所以感觉神秘可能是因为那时候不认识‘’佚‘’这个字。。。 1234强调: 匿名函数的定义就相当于只产生一个变量在值,而没有绑定任何名字, 所以会在定义完之后就被回收,无法重复使用,只能在定义时使用一次应用:当某一个功能仅使用一次就没有再重复使用的必要了,就应该定义成匿名函数 言归正传，匿名和佚名一样没有名字或者不需要知道名字，对就是这么酷。 定义一个匿名函数使用lambda关键词，和def比较的话会发现其实定义逻辑很像。 1lambda x: x**2 定义的匿名函数的意思是参数为x，返回x的平方，返回？怎么没看到return？因为lambd引号后面的值默认返回，所以没必要加return了，但是我一定要加呢？就是这么不讲道理。那么解释器只好报错了，因为你不认同我的语法，那我也没必要惯着你了。就是这么拽。 匿名函数的使用场景通常为使用一次就结束了，不会频繁的使用。而且匿名函数通常和python里面自带的高阶函数结合使用，在某些应用场景下会达到事倍功半的效果哦。 高阶函数mapmap的意思是地图的意思，由此引申出映射表示一一对应。 翻译过来的意思是：创建一个迭代器，使用每个迭代的参数计算函数。 当最短的可迭代用尽时停止。 map函数有两个参数，第一个为某种规则的函数，第二个位多个可迭代对象。 12345def func(x): return x * 2lis = [1, 2, 3, 4, 5, 6]print(type(map(func, lis)))print(list(map(func, lis))) map函数把可迭代对象中的元素自动传给func，通过func的加工，得到一个生成器对象，通过list函数转化为一个列表。 当然，map函数可以接收多个可迭代对象，比如 123456def func(x, y): return x + ylis1 = [1,2,3,4,5,6]lis2 = [2,3,4,5,6,7,8,9,10,11]print(list(map(func, lis1,lis2)))# 结果为[3, 5, 7, 9, 11, 13] map函数会把后面迭代器对象中的元素迭代出来经过func加工，当最短的可迭代用尽是停止，所以只进行到6+7就结束了。 reducereduce是减少、合并的意思，会把可迭代对象中的元素经过函数的加工进而产生新的结果。 翻译过来就是：从左到右累加两个参数的函数到序列的项目，以便将序列减少为单个值。例如，reduce（lambda x，y：x + y，[1,2,3] ，4,5]计算（（（（（1 + 2）+3）+4）+5）。如果存在初始值，则将其放置在计算中序列的项之前，并在序列为空时用作默认值。 reduce函数有三个参数，函数和序列都是必须参数，初始值为可选参数。 应用：比如求1-100的和 12345from functools import reducedef func(x, y): return x+yprint(reduce(func, [i for i in range(1,101)]))# 结果为 5050 filterfilter的意思为过滤，通过函数的返回值对序列进行过滤。 翻译过来：返回一个迭代器，产生函数（item）为真的迭代项。 如果函数为None，则返回结果为真的项。 12345def func(x): return x.isdigit()lis = ['12', 'ad', '34', 'bc', '46']print(list(filter(func, lis)))# 结果为 ['12', '34', '46'] filter过滤结果为真的值放进迭代器中。 高阶函数和匿名函数map和匿名函数在之前map函数中的func参数都是定义了一个有名参数，然后用函数名传入map函数的，有了匿名函数就不用这么麻烦了。 123lis = [1, 2, 3, 4, 5, 6]print(list(map(lambda x: x*2, lis)))# 结果为 [2, 4, 6, 8, 10, 12] reduce和匿名函数12print(reduce(lambda x, y: x + y, [i for i in range(101)], 100))# 输出结果为 5050 filter和匿名函数12345678sala = &#123; 'MAC': 30000, 'iPhone': 9000, 'lenovo': 10000, 'xiaomi': 3000&#125;print(list(filter(lambda x: sala[x] &gt; 5000, sala)))# 输出结果为 [‘iPhone', 'lenovo'] 匿名函数的使用场景较为单一，一次性使用，随用随时定义。在某些场景下和高阶函数结合会提升效率，同时使代码更加简洁。 递归一 递归调用的定义递归调用时函数嵌套调用的一种特殊形式，函数在调用时，直接或间接地调用了自身，就是递归调用。 1234567891011121314151617181920# 直接调用自身def f1(): print('from f1') f1()f1()# 间接调用自身def f1(): print('from f1') f2()def f2(): print('from f1') f1()f2()# 调用函数会产生局部的名称空间，占用内存，因为上述这种调用会无限调用自身，python解释器的内存管理机制为了防止无限占用内存，对函数的递归调用做了层级限制，可以通过代码修改最大层级限制。import syssys.setrecursionlimit(100000) 二 递归调用的两个阶段递归调用包含两个明确的阶段：回溯，递推 回溯就是从外向里一层一层递归调用下去，回溯阶段必须要有一个明确的结束条件（不然会成为死循环），每进入下一次递归时，问题的规模都应该有所减少。 递推就是从里向外一层层结束递归。 递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈实现的，每当进入一个函数调用，在栈下面会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以递归调用次数过多，会导致栈溢出） 三 二分法从一个排序的数字列表中找到指定的数字，使用遍历的效率太低，使用二分法可以极大地缩小问题规模。 实现in的效果 123456789101112131415nums = [1,5,12,23,34,46,59,99,443]def fucn(num, nums): if len(nums) == 0: return mid_index = len(nums) // 2 if num &gt; nums[mid_index]: nums = nums[mid_index+1:] fucn(num, nums) elif num &lt; nums[mid_index]: nums = nums[:mid_index] fucn(num,nums) else: print('not exis') 实现index的效果 1234567891011121314151617181920212223nums = [1, 13, 15, 23, 27, 31, 33, 57, 73, 81, 93, 94, 97, 101] # 从小到大排列的数字列表def binary_search(find_num,nums): print(nums) if len(nums) == 0: print('not exists') return # 功能 mid_index = len(nums) // 2 if find_num &gt; nums[mid_index]: # in the right nums=nums[mid_index+1:] # 重新运行功能,传入新列表 binary_search(find_num,nums) elif find_num &lt; nums[mid_index]: # in the left nums=nums[:mid_index] # 重新运行功能,传入新列表 binary_search(find_num,nums) else: print('find it') binary_search(95,nums)]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符编码]]></title>
    <url>%2F2018%2F10%2F08%2F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[本来都以为自己完全弄懂字符编码了，昨天一个小问题给难倒了，思考了很久才得出答案，惭愧 字符编码的简介字符编码可以说每一种编程语言都会遇到的问题，为什么会有这么多的问题呢，就是因为计算机发展速度太快了，不仅计算机的诞生国要使用，第三世界国家也要使用，所以人和计算机的交流方式就变得复杂起来。像英语国家最简单，直接用一个字节也就是7bit，总共128种状态就可以满足交流需求；但是像中国等不以英语为第一母语的国家就会出很多问题了，但中文就有60000+个，那么很显然，7bit满足不了需求，所以为了满足需求，中国出了gb2312编码，不过gb2312也不能满足需求，所以又出来了gbk编码，可以表示60000+汉子。 虽然可以通过自己国家去规定本国的字符编码方式，可是这么多国家，每个国家都有自己的编码方式，那么跨过交流会变得困难起来。为了解决这种问题，在1990年开始起草unicode码，简称万国码。里面是一张超级大的对照表，包含了所有的编码集，比如：utf-8、shiftjis、gbk、iso-8859-1。既然包含这么多的对照表，那么每个国家都继续用自己的编码操作文件，但是在内存中都用unicode码，存的时候又根据unicode对照映射成自己国家的编码方式存储不就可以解决跨国交流的问题了嘛。 文本编辑器打开文件文本编辑器打开文件通常分为三步： 首先启动文本编辑器 文本编辑器将存储在硬盘中的文件读入内存 文本编辑器识别内存中文件的编码方式进而解码 第一步不用多解释了，重要在第二步和第三步。 硬盘中的文件会有一种编码方式，如下图 可以看出来有ASCII和UTF-8两种编码方式，所以当文本编辑器将它们读入内存中时，需要按照ASCII和UTF-8分别解码成unicode码（内存中默认编码都为unicode），第三步需要在显示屏上显示出来，那么需要将内存中的unicode码解码出来，那么这时候按照什么解码方式呢？如果我们没指定的话按照当前环境的编码方式，比如windows系统默认编码方式为gbk，类linux系统默认编码方式为utf-8。所以这就会出现问题了，假如在windows系统中读取utf-8编码方式的文件时 在windows下使用python2进行试验，定义了一个变量，并且是unicode编码的，当我分别是用utf-8和gbk对unicode编码时，然后打印发现utf-8码乱码了，这就说明在打印的时候会根据当前环境的编码方式进行解码，这和windows默认编码为gbk是相符的。 python中的编码在python中有两种编码：分别为文件编码以及运行代码时定义字符串的编码 第一种在前面解释了，总的来说一个文本编辑器从硬盘中读入文件时，第一步按照文件存储的编码解码为unicode码存入内存，然后根据文件头声明的编码解码（如果有文件头声明编码方式的话），否则就按照环境默认编码进行解码。 而python2和python3有很大的不同，python2默认编码为ascii，python3默认编码为utf-8，即python2编写的文件默认为ASCII编码，python3编写的文件默认为utf-8编码，但是读入内存中都需要解码为unicode。 第二种的话，在上幅图中为了演示，把字符串定义为unicode码，那么字符串前面不加’u’呢？ 按照我们之前的认识，ASCII识别不了中文，所以在print(a)时应该会报错才对啊，为什么不报错呢？这个应该是python2做的改变，当识别不了中文时，使用当前系统默认编码进行编码和解码，来证明一下，我使用linux做个试验就知道了。 真相大白了，python2这个改进不得不说挺机智的，因为历史遗留问题才导致python2的编码问题经过这样算是一种比较完美的解决方式。而完美的python3会有这种问题吗？怎么可能。python3是完美的。]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ssh免钥登陆github]]></title>
    <url>%2F2018%2F10%2F01%2Fgit-ssh%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[设置Git的user name和emai：（如果是第一次的话）$ git config --global user.name &#39;musibii&#39;$ git config --global user.email &#39;shaozuanzuan@gmail.com&#39; 生成秘钥$ ssh-keygen -t rsa -C &#39;shaozuanzuan@gmail.com&#39;从图上可以看到生成秘钥保存的地址，通常都会默认保存在家目录下面的.ssh下，前面加点表示是个隐藏目录。 添加秘钥到ssh-agentssh-agent是一个帮助程序，用于跟踪用户的身份密钥及其密码。 然后，代理可以使用密钥登录其他服务器，而无需用户再次键入密码或密码.运行ssh-agent之后，使用ssh-agent将私钥交给ssh-agent保管，其他程序需要身份验证的时候就可以将验证申请交给ssh-agent来完成整个认证过程。添加生成的ssh key到ssh-agent$ ssh-add ~/.ssh/id_rsa 登录github，添加ssh秘钥可以看到我有两个密钥，一个是macOS的，一个是Ubuntu的。 测试是否成功$ ssh -T git@github.com万万没想到，报错了。。。报错原因居然是没联网。。。靠北！！！重新联网成功了。。]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mac下配置github个人博客]]></title>
    <url>%2F2018%2F09%2F29%2FMac%E4%BD%BF%E7%94%A8Hexo%E9%85%8D%E7%BD%AEGItHub%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一 前言本来一直用博客园写博客的，奈何博客园界面惨不忍睹，而且自带的markdown编辑器更是烂的可以，于是在室友makeupstories的建议下开始尝试搭建自己的github博客，真是一路心酸啊！不过成就感也是大大滴。 二 准备工作创建Github域名和放博客的库 首先需要注册一个Github账号。 注册之后需要新建一个库(repository)来存储网站，点击首页任意位置出现的New repository按钮创建仓库，注意这个仓库名不能随便写。例如我的Github账号为musibii，那么库名为musibii.github.io。 安装Git、Nodejs和HexoHexo可以说是最流行的博客框架了，基于Nodejs，想要搭建好，需要安装Git、Nodejs和Hexo。 安装Git可以直接在命令行使用brew来安装Git$ brew install git 因为我之前已经安装了Git，所以这次给我安装了两个扩展包。 安装Nodejs为了便于管理Nodejs版本，首先安装nvm，这是Nodejs版本管理器，可以实现Nodejs多版本切换。$ curl -o- [https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh](https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh) | bash安装完成后，重启终端并执行下列命令即可安装Node.js$ nvm install \d后面跟的是Node.js的版本，今天就是被这个给坑了，应该安装较新的版本，之前安装的为 4，然后一直报错。$ nvm install 8安装后在终端输入$ nvm use node就会使用最新的nodejs版本了。 安装Hexo$ sudo npm install hexo-cli -g注意需要sudo权限，不然会出错 配置博客接下来需要使用Hexo来初始化一个博客，然后根据自己的需求更改一些自定义配置，比如字体、动画效果、主题等等。 创建博客为自己的博客创建一个文件夹，然后cd 文件夹，并执行下面的代码。$ hexo init username.github.io 更改主题 基础配置然后需要的就是在_config.yml里面修改个人信息，比如博客的主题、作者还有语言以及修改的主题名，最重要的是要和你的github仓库关联起来。其他的可以根据自己的需求酌情更改，比如我就增加了页面的动画效果Next主题动画效果 你的第一篇博客 $ hexo new &#39;你的博客名字&#39;执行完后会在‘username.github.io/source/_posts/‘目录下出现你的博客名字 博客使用markdown格式，编写完后执行$ hexo server如果出现下面的页面 在浏览器页面输入http://localhost:4000我的界面会和你们的不一样，出现了 Hello就说明成功了。 安装hexo-deployer-git –save自动部署发布工具$ npm install hexo-deployer-git --save 发布博客$ hexo deploy结束后进入博客就可以看见了！]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Hello,my name is musibii! Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
